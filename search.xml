<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>静态网页生成[gridsome]</title>
    <url>/2020/09/29/Gridsome-%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h2 id="静态网站"><a href="#静态网站" class="headerlink" title="静态网站"></a>静态网站</h2><h3 id="什么是静态网站"><a href="#什么是静态网站" class="headerlink" title="什么是静态网站"></a>什么是静态网站</h3><ul>
<li>静态网站是使用一系列模板数据及配置生成静态html文件及相关资源的工具</li>
<li>这个功能也叫作预渲染</li>
<li>生成的网站不需要类似PHP这样的服务器</li>
<li>只需要放在web server或者cdn上就可以</li>
</ul>
<h3 id="静态网站的优点"><a href="#静态网站的优点" class="headerlink" title="静态网站的优点"></a>静态网站的优点</h3><ul>
<li>不需要专业服务器，服务器成本低，只需要能托管静态文件的空间</li>
<li>响应快速，不经过后台处理，只传输内容</li>
<li>安全性更高</li>
</ul>
<h3 id="常见静态网站生成器（JAMStack-Javascript-Api-Markup-stack）"><a href="#常见静态网站生成器（JAMStack-Javascript-Api-Markup-stack）" class="headerlink" title="常见静态网站生成器（JAMStack Javascript Api Markup stack）"></a>常见静态网站生成器（JAMStack Javascript Api Markup stack）</h3><ul>
<li>jekyll(ruby)</li>
<li>hexo(node)</li>
<li>hugo(golang)</li>
<li>gatsby(node/react)</li>
<li>gridsome(node/vue)</li>
<li>next,nuxt也能用于生成静态网站，不过更多的被认为是ssr框架</li>
</ul>
<h3 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h3><ul>
<li>不适合大量路由的应用</li>
<li>不适合大量动态交互的应用，比如后台管理</li>
</ul>
<h2 id="Gridsome"><a href="#Gridsome" class="headerlink" title="Gridsome"></a>Gridsome</h2><ul>
<li>GitHub 仓库：<a href="https://github.com/gridsome/gridsome">https://github.com/gridsome/gridsome</a></li>
<li>官网：<a href="https://gridsome.org/">https://gridsome.org/</a></li>
</ul>
<h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g @gridsome&#x2F;cli</span><br></pre></td></tr></table></figure>

<p>直接使用<code>gridsome create 项目名</code>创建项目会失败，因为geidsom依赖了<a href="https://github.com/lovell/sharp">sharp</a>（用于处理图片）第三方模块，包含c++文件，另外sharp依赖libvips，这个模块很大容易下载失败。所以需要处理这个问题</p>
<p>关于解决libvips的网络问题可以参照<a href="https://sharp.pixelplumbing.com/install#chinese-mirror">这里</a>,libvips官网提供了国内的镜像</p>
<p>这里我们使用两个命令配置下镜像源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set sharp_binary_host &quot;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;sharp&quot;</span><br><span class="line"></span><br><span class="line">npm config set sharp_libvips_binary_host &quot;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;sharp-libvips&quot;</span><br></pre></td></tr></table></figure>

<p>关于编译c++扩展包可以借助<code>node-gyp</code>模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install node-gyp -g</span><br></pre></td></tr></table></figure>

<p>安装了node-gyp之后不能直接使用，windows环境下需要安装python，另外需要安装windows-build-tools<br>安装时需要使用管理员命令行才能成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --global --production windows-build-tools</span><br></pre></td></tr></table></figure>

<p>创建项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gridsome create gridsome-site</span><br></pre></td></tr></table></figure>

<p>启动项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run develop</span><br></pre></td></tr></table></figure>

<p>此时会在默认8080端口访问gridsome创建的默认应用</p>
<h3 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h3><p>在创建项目的src/pages中可以看到默认生成的两个路由组件，执行打包<code>npm run build</code>查看生成的路由静态页面</p>
<p>可以看到项目中生成了dist目录，保存了所有的静态页面，dist目录下的项目可以直接放在静态web服务上访问</p>
<p>这样生成的网站首次访问时属于服务端渲染（这个过程保存结果在静态资源里，称为预渲染）。到达客户端之后，用户拿到的是一个SPA的应用。</p>
<h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>gridsome.config.js 是项目的配置信息，比如标题<code>siteName</code>、路径前缀<code>pathPrefix</code>等，可以参照<a href="https://gridsome.org/docs/config/">gridsome配置</a></p>
<h3 id="pages路由规则"><a href="#pages路由规则" class="headerlink" title="pages路由规则"></a>pages路由规则</h3><p>pages目录下保存着项目的路由文件，默认会根据文件系统自动生成路由</p>
<h4 id="文件系统路由生成的规则"><a href="#文件系统路由生成的规则" class="headerlink" title="文件系统路由生成的规则"></a>文件系统路由生成的规则</h4><ul>
<li>src/pages/Index.vue -&gt; /</li>
<li>src/pages/AboutUs.vue -&gt; /about-us/</li>
<li>src/pages/about/Vision.vue -&gt; /about/vision/</li>
<li>src/pages/blog/Index.vue -&gt; /blog/</li>
</ul>
<h4 id="基于文件系统的动态路由"><a href="#基于文件系统的动态路由" class="headerlink" title="基于文件系统的动态路由"></a>基于文件系统的动态路由</h4><ul>
<li>src/pages/user/[id].vue -&gt; /user/:id.</li>
<li>src/pages/user/[id]/settings.vue -&gt; /user/:id/settings.</li>
</ul>
<p>在组建中通过<code>$route.params.id</code>获取动态路由的参数</p>
<p>Ex: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;user-page&#x27;</span>&gt;</span><br><span class="line">        &#123;&#123; $route.params.id &#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="api编程方式生成路由"><a href="#api编程方式生成路由" class="headerlink" title="api编程方式生成路由"></a>api编程方式生成路由</h4><p>有时候需要通过api编程方式创建组件</p>
<p>在gridsome.server.js中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">api.createPages(<span class="function">(<span class="params">&#123; createPage &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    createPage(&#123;</span><br><span class="line">      path: <span class="string">&#x27;/my-page&#x27;</span>,</span><br><span class="line">      component: <span class="string">&#x27;./src/templates/MyPage.vue&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在src/templates中创建MyPage.vue</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;my-page&#x27;</span>&gt;My Page&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>修改了<code>gridsome.server.js</code>需要使用<code>npm run develop</code> 重新启动服务</p>
<p>启动成功后访问/my-page查看刚才创建的页面</p>
<h4 id="api编程方式动态路由"><a href="#api编程方式动态路由" class="headerlink" title="api编程方式动态路由"></a>api编程方式动态路由</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">api.createPages(<span class="function">(<span class="params">&#123; createPage &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    createPage(&#123;</span><br><span class="line">      path: <span class="string">&#x27;/article/:id(\\d+)&#x27;</span>,  <span class="comment">// () 中是使用正则表达式对id做的限定，这里代表id必须为数字,如果不匹配会404</span></span><br><span class="line">      component: <span class="string">&#x27;./src/templates/Article.vue&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>./src/templates/Article.vue</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;article&#x27;</span>&gt;</span><br><span class="line">        &#123;&#123;$route.params.id&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>同样修改gridsome.server.js后需要重启</p>
<h3 id="页面head内容"><a href="#页面head内容" class="headerlink" title="页面head内容"></a>页面head内容</h3><p>使用metaInfo配置页面head中的内容，包括title，meta等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  metaInfo: &#123;</span><br><span class="line">    title: <span class="string">&#x27;About us&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h3><p>自定义404页面只需要在src/pages下创建404.vue即可</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合用于承载接口的数据，结合模板预渲染成一个一个的页面，更多参展<a href="https://gridsome.org/docs/collections/">集合</a></p>
<h4 id="数据预取，保存到集合中"><a href="#数据预取，保存到集合中" class="headerlink" title="数据预取，保存到集合中"></a>数据预取，保存到集合中</h4><p>安装<code>axios</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i axios </span><br></pre></td></tr></table></figure>

<p>gridsome.server.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">api.loadSource(<span class="keyword">async</span> (actions) =&gt; &#123;</span><br><span class="line">    <span class="comment">// Use the Data Store API here: https://gridsome.org/docs/data-store-api/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> collection = actions.addCollection(<span class="string">&#x27;Post&#x27;</span>) <span class="comment">// 集合名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> axios.get(<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> data) &#123;</span><br><span class="line">        collection.addNode(&#123;</span><br><span class="line">            id: item.id,</span><br><span class="line">            title: item.title,</span><br><span class="line">            content: item.body</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样，集合就预取保存了接口的数据，接线来得问题是如何在页面中获取这个数据</p>
<p>集合会将数据保存到GraphQL中，上述代码中通过<code>actions.addCollection(&#39;Post&#39;)</code>我们添加了集合并命名为<code>Post</code>，此时在GraphQL中</p>
<ul>
<li><code>post</code> 获取单条数据 通过 <code>id</code></li>
<li><code>allPost</code> 获取数据列表</li>
</ul>
<p>我们可以通过访问启动项目是给出的页面查看GraphQL内容</p>
<img src="/2020/09/29/Gridsome-%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/1.png" class="">

<p>访问 <code>http://localhost:8080/___explore</code></p>
<img src="/2020/09/29/Gridsome-%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/2.png" class="">

<p>点击docs可以查看所有内容<br>尝试查询一条数据，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">query&#123;</span><br><span class="line">  post (id: 1) &#123;</span><br><span class="line">    id</span><br><span class="line">    title</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/09/29/Gridsome-%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/3.png" class="">

<p>关于GraphQL内容参考<a href="https://graphql.cn/">GraphQL官网</a></p>
<h4 id="页面获取GraphQL中的数据"><a href="#页面获取GraphQL中的数据" class="headerlink" title="页面获取GraphQL中的数据"></a>页面获取GraphQL中的数据</h4><p><a href="https://gridsome.org/docs/querying-data/">Querying data页面获取数据参考地址</a></p>
<blockquote>
<p>You can query data from the GraphQL data layer into any Page, Template or Component. Queries are added with a <page-query> or <static-query> block in Vue Components.</p>
<ul>
<li>Use <page-query> in Pages &amp; Templates.</li>
<li>Use <static-query> in Components.</li>
</ul>
</blockquote>
<ul>
<li>在templates或Pages中的组件通过<code>&lt;page-query&gt;</code></li>
<li>在component中使用<code>&lt;static-query&gt;</code></li>
</ul>
<p>接下来尝试使用数据并预渲染界面</p>
<p>创建src/pages/Posts.vue</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;posts&#x27;</span>&gt;</span><br><span class="line">            &lt;h1&gt;Posts&lt;/h1&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;edge in $page.posts.edges&quot;</span> :key=<span class="string">&quot;edge.node.id&quot;</span>&gt;</span><br><span class="line">                    &lt;g-link to=<span class="string">&quot;/&quot;</span>&gt;&#123;&#123;edge.node.title&#125;&#125;&lt;/g-link&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;page-query&gt;</span><br><span class="line">query &#123;</span><br><span class="line">  posts: allPost &#123;</span><br><span class="line">    edges &#123;</span><br><span class="line">      node &#123;</span><br><span class="line">        id</span><br><span class="line">        title</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/page-query&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时可以访问到静态化的posts页面</p>
<img src="/2020/09/29/Gridsome-%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/4.png" class="">

<h4 id="静态或文章详情页面"><a href="#静态或文章详情页面" class="headerlink" title="静态或文章详情页面"></a>静态或文章详情页面</h4><ul>
<li>配置gridsome.config.js,指定模板和路由规则</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  templates: &#123;</span><br><span class="line">    <span class="comment">// Post 是集合名称</span></span><br><span class="line">    Post: [&#123;</span><br><span class="line">      path: <span class="string">&#x27;/posts/:id&#x27;</span>, <span class="comment">// 这里动态路由的id就是我们数据中心的唯一字段，不能随便写</span></span><br><span class="line">      component: <span class="string">&#x27;./src/templates/Post.vue&#x27;</span>,</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改文章列表的链接</li>
</ul>
<p>之前在posts.vue中文章链接修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;g-link to=&quot;/&quot;&gt;&#123;&#123;edge.node.title&#125;&#125;&lt;/g-link&gt;</span></span><br><span class="line"><span class="comment">// edge.node.path是我们配置gridsome.config.js之后回为列表数据添加path属性</span></span><br><span class="line">&lt;g-link :to=<span class="string">&quot;edge.node.path&quot;</span>&gt;&#123;&#123;edge.node.title&#125;&#125;&lt;/g-link&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建模板sre/templates/Page.vue</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;post&#x27;</span>&gt;</span><br><span class="line">            &lt;h1&gt;&#123;&#123; $page.post.title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;&#123; $page.post.content &#125;&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;page-query&gt;</span><br><span class="line">query ($id: ID!)&#123;</span><br><span class="line">  post (id: $id) &#123;</span><br><span class="line">    id</span><br><span class="line">    title</span><br><span class="line">    content</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/page-query&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;PostPage&#x27;</span>,</span><br><span class="line">    <span class="comment">// 这种写法无法访问 $page中的数据</span></span><br><span class="line">    <span class="comment">// metaInfo: &#123;</span></span><br><span class="line">    <span class="comment">//     title: $page.post.title</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    metaInfo() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            title: <span class="built_in">this</span>.$page.post.title </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>query ($id: ID!)</code> 中传入了变量<code>$id</code>, 变量类型是<code>ID</code>(这个类型可以通过docs里查看),<code>!</code>代表不能为空</p>
<p>接下来执行打包 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>通过打包后的dist目录可以看到项目中每篇文章都做了静态化处理</p>
<img src="/2020/09/29/Gridsome-%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/5.png" class="">


<h4 id="处理分页"><a href="#处理分页" class="headerlink" title="处理分页"></a>处理分页</h4><p>处理分页很简单，gridsome提供了Pager组件，引入并提供 需要的属性即可<br>在列表页查询列表时需要传递page相关的参数，每页条数，以及当前页</p>
<p>src/page/Posts.vue</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;posts&#x27;</span>&gt;</span><br><span class="line">            &lt;h1&gt;Posts&lt;/h1&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;edge in $page.posts.edges&quot;</span> :key=<span class="string">&quot;edge.node.id&quot;</span>&gt;</span><br><span class="line">                    &lt;!-- edge.node.path是自动生成的属性，可以跳转到详情页 --&gt;</span><br><span class="line">                    &lt;g-link :to=<span class="string">&quot;edge.node.path&quot;</span>&gt;&#123;&#123;edge.node.title&#125;&#125;&lt;/g-link&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">            &lt;!-- 使用pager组件 --&gt;</span><br><span class="line">            &lt;pager :info=<span class="string">&quot;$page.posts.pageInfo&quot;</span>/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;page-query&gt;</span><br><span class="line"># 接收url上的参数，设置每页条数和当前页码</span><br><span class="line">query ($page: Int)&#123;</span><br><span class="line">  posts: allPost (perPage: <span class="number">10</span>, <span class="attr">page</span>: $page) @paginate &#123;</span><br><span class="line">    pageInfo &#123;</span><br><span class="line">      totalPages</span><br><span class="line">      currentPage</span><br><span class="line">    &#125;</span><br><span class="line">    edges &#123;</span><br><span class="line">      node &#123;</span><br><span class="line">        id</span><br><span class="line">        title</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/page-query&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 引入Pager</span></span><br><span class="line"><span class="keyword">import</span> &#123;Pager&#125; <span class="keyword">from</span> <span class="string">&#x27;gridsome&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 注册</span></span><br><span class="line">    components: &#123;Pager&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开网页查看，点击第二页，可以看到路由变化为<code>localhost:8080/posts/2/</code></p>
<img src="/2020/09/29/Gridsome-%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90/6.png" class="">

<p>至于paper的样式自定义即可</p>
]]></content>
      <tags>
        <tag>Gridsome</tag>
      </tags>
  </entry>
  <entry>
    <title>JS异步编程</title>
    <url>/2020/08/26/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>javascript最初设计为了实现页面的交互操作，为了避免不同线程同时处理dom导致无法判断以那个结果为准，所以不得不采用单线程模式工作，</p>
<ul>
<li>同步模式与异步模式</li>
<li>事件循环与消息队列</li>
<li>异步编程方式</li>
<li>Promise异步方案、宏任务/微任务</li>
<li>Generator异步方案、Async/Await语法糖</li>
</ul>
<h3 id="同步模式，排队执行"><a href="#同步模式，排队执行" class="headerlink" title="同步模式，排队执行"></a>同步模式，排队执行</h3><p>js通过调用栈执行函数语句，正在执行的操作会入栈，操作完成后出栈<br>耗时操作会阻塞后边函数的执行</p>
<h3 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h3><p>开始执行后，js现成遇到异步操作会将异步操作放入异步调用线程（web APIs），之后立即开始下一个任务。<br>异步调用线程会在异步执行完成后，将回调函数压入消息队列中<br>在js主线程的函数栈操作完毕后，Event Loop 会循环将回调函数取出回调函数交给主线程执行</p>
<img src="/2020/08/26/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/yibu.png" class="">
<p>运行环境提供的API是以同步或者异步模式的方式工作的，比如console.log()会在主线程同步执行，当执行setTimeout时会交给异步线程去处理。</p>
<h3 id="回调函数-异步编程方案的根基"><a href="#回调函数-异步编程方案的根基" class="headerlink" title="回调函数-异步编程方案的根基"></a>回调函数-异步编程方案的根基</h3><p>回调函数<br>事件机制<br>发布订阅</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>三种状态<br>Pending、Fulfilled、Rejected。<br>Promise执行完成后的状态不可被改变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// resolve 和 reject 函数只能执行一个</span></span><br><span class="line">    resolve(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reject(new Error(&#x27;promise rejected&#x27;));</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><p>Promise then方法会返回一个新的Promise对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">123</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise === promise2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>前面then方法回调函数的返回值会作为后面then 方法回调的参数<br>后面的then方法实际上是为上一个then方法返回的promise注册回调</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">123</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// 123</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// undefined  // 上一个函数没有返回一个新的Promise或者数值，所以res是undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;上个then中返回的Promse结果&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// 上个then中返回的Promse结果  // 如果上个then函数返回了新的Promise， 相当于执行返回的Promise的then（）函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>如果promise执行中遇到了抛出异常，就会执行 onRejectd 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;手动抛出异常&#x27;</span>);</span><br><span class="line">    resolve(<span class="number">123</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// undefined  // 上一个函数没有返回一个新的Promise或者数值，所以res是undefined  </span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: 手动抛出异常</span></span><br></pre></td></tr></table></figure>

<p>上面的方式可以写成在最后添加catch方法的方式，在promise中异常会通过他很方法向后传递，因此在最后添加catch（）方法可以捕获整个链式过程中抛出的异常，相当于为整个Promise链条注册的失败回调</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;手动抛出异常&#x27;</span>);</span><br><span class="line">    resolve(<span class="number">123</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// undefined  // 上一个函数没有返回一个新的Promise或者数值，所以res是undefined  </span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 </span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;手动抛出异常&#x27;</span>);</span><br><span class="line">    resolve(<span class="number">123</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// undefined  // 上一个函数没有返回一个新的Promise或者数值，所以res是undefined  </span></span><br><span class="line">&#125;).then(<span class="literal">undefined</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当然也可以在全局为出现异常的Promise 添加异常处理，不过这种方式不推荐，因改为每一个promise添加特定的异常处理<br>浏览器环境</p>
<img src="/2020/08/26/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/2.png" class="">

<p>node环境</p>
<img src="/2020/08/26/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/3.png" class="">

<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>Promise.resolve()        快速地把一个值转化为Promise对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// Promise &#123; true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果接受一个Promise对象，则会返回该Promise对象</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(promise) === promise</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 thenable 接口</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params">onResolve, onReject</span>) </span>&#123;</span><br><span class="line">        onResolve(<span class="string">&#x27;thenable&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise.reject()     返回一个失败地Promise对象</p>
<h4 id="Promise-并行执行"><a href="#Promise-并行执行" class="headerlink" title="Promise 并行执行"></a>Promise 并行执行</h4><ul>
<li>Promise.all()<br>多个Promise 合并为一个Promise，会在下个then方法传递给回调函数 结果数组，需要注意all方法中地任意一个Promise执行了reject（）方法或者抛出异常，会导致触发整个Promise.all返回的Promise对象执行onReject回调</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">1000</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">5000</span>)</span><br><span class="line">            &#125;, <span class="number">5000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 1000, 5000 ]   // 5 s 后</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Promise.race();<br>Promise.race()方法同样会合并多个Promise，与all()不同的是，race方法会等待第一个完成的任务，并向后传递第一个执行完成的任务的结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">1000</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">5000</span>)</span><br><span class="line">    &#125;, <span class="number">5000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1000   // 1 s 后</span></span><br></pre></td></tr></table></figure>

<h4 id="微任务，promise执行顺序"><a href="#微任务，promise执行顺序" class="headerlink" title="微任务，promise执行顺序"></a>微任务，promise执行顺序</h4><p>promise（除此之外还有MutationObserver对象，node中的process.nextTick）的回调会作为微任务执行，微任务会在当前任务执行结束后立即执行，不会在消息队列的队尾排队<br>类似setTimeout 等大部分异步调用都会作为宏任务 执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;code start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Promise&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;code end&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// code start</span></span><br><span class="line"><span class="comment">// code end</span></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure>

<h3 id="Generator异步方案"><a href="#Generator异步方案" class="headerlink" title="Generator异步方案"></a>Generator异步方案</h3><p>生成器函数的调用会返回生成器对象而不是立即执行函数内容，只有调用生成器对象的next()方法函数才会开始执行</p>
]]></content>
      <tags>
        <tag>notes</tag>
        <tag>javascript</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>centOs 服务器部署</title>
    <url>/2020/11/11/centOs-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><h4 id="安装-nvm"><a href="#安装-nvm" class="headerlink" title="安装 nvm"></a>安装 nvm</h4><p>安装nvm，执行一下命另下载安装nvm并注册到bash，可以在命令行使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -qO- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;nvm-sh&#x2F;nvm&#x2F;v0.35.3&#x2F;install.sh | bash</span><br></pre></td></tr></table></figure>

<p>bash 修改后需要exit重新连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm --version</span><br></pre></td></tr></table></figure>

<h4 id="安装-node"><a href="#安装-node" class="headerlink" title="安装 node"></a>安装 node</h4><p>借助nvm安装node最新版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm install --lts</span><br></pre></td></tr></table></figure>


<p>安装 pm2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g pm2</span><br></pre></td></tr></table></figure>

<p>查看pm2 启动日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 log</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>centOS</tag>
      </tags>
  </entry>
  <entry>
    <title>centos虚拟机安装</title>
    <url>/2021/12/14/centos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="centos-虚拟机安装"><a href="#centos-虚拟机安装" class="headerlink" title="centos 虚拟机安装"></a>centos 虚拟机安装</h2><h3 id="下载镜像并创建虚拟机"><a href="#下载镜像并创建虚拟机" class="headerlink" title="下载镜像并创建虚拟机"></a>下载镜像并创建虚拟机</h3><p>略</p>
<h3 id="centos-安装"><a href="#centos-安装" class="headerlink" title="centos 安装"></a>centos 安装</h3><ol>
<li><p>打开虚拟机，上下选择键选择 install CentOS</p>
</li>
<li><p>安装完成后会提示选择语言，点继续</p>
</li>
<li><p>之后会发现 begin installation 无法点击，此时选择 installation destination</p>
<img src="/2021/12/14/centos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20211214151819195.png" class="">
</li>
<li><p>选择 i will configure partitioning , 点击 done</p>
</li>
<li><p>点击左下角 + 号</p>
<ul>
<li><p>选择 /boot , 分配1024M 空间</p>
</li>
<li><p>选择 swap , 分配4096M 空间</p>
</li>
<li><p>选择 / , 直接点击 add mount point, 自动将剩余的空间分配到根目录</p>
</li>
<li><p>点击 done</p>
<img src="/2021/12/14/centos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20211214152211656.png" class="">
</li>
<li><p>点击 accept changes</p>
</li>
</ul>
</li>
<li><p>点击 begin install</p>
</li>
<li><p>设置 root password， 点击两次done</p>
</li>
<li><p>等待安装结束后，点击 reboot</p>
</li>
</ol>
<h3 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h3><ol>
<li><p>查看VMware 虚拟网络配置</p>
<p>点击虚拟机的编辑 -&gt; 虚拟机网络编辑器 -&gt; 选择 VMnet8 NET 模式<br>查看 子网ip、子网掩码、网关ip</p>
<img src="/2021/12/14/centos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20211214153040179.png" class="">

<p>查看 起止 ip 区间</p>
<img src="/2021/12/14/centos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20211214153632288.png" class="">
</li>
<li><p>修改网络配置<br>cd /etc/sysconfig/network-scripts/目录下</p>
<p>vi ifcfg-ens32  (这个文件每个人可能都不一样，是系统随机命名的，但都是ifcfg-enxxx这种格式)</p>
<p>修改 BOOTPROTO 和 ONBOOT 字段，并追加内容如图</p>
<img src="/2021/12/14/centos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20211214154752201.png" class=""></li>
<li><p>重启网卡服务 service network restart</p>
<img src="/2021/12/14/centos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/20200406221633148.png" class="">
</li>
<li><p>ping baidu.com 检查网络状态</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>centos</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab搭建</title>
    <url>/2021/12/14/gitlab%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="gitlab代码仓库搭建"><a href="#gitlab代码仓库搭建" class="headerlink" title="gitlab代码仓库搭建"></a>gitlab代码仓库搭建</h2><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><ol>
<li><p>安装ssh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y curl policycoreutils-pythonopenssh-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>将SSH服务设置成开机自启动</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable sshd</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>启动SSH服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start sshd</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装开启防火墙,如果已经安装了防火墙并且已经在运行状态跳过此步骤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install firewalld systemd -y</span><br><span class="line"></span><br><span class="line">service firewalld  start</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加http服务到firewalld,pemmanent表示永久生效，若不加–permanent系统下次启动后就会失效。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --add-service&#x3D;http</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>重启防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl reload firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装Postfix以发送通知邮件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install postfix</span><br></pre></td></tr></table></figure>
</li>
<li><p>将postfix服务设置成开机自启动</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable postfix</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>启动postfix</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start postfix</span><br></pre></td></tr></table></figure>

<ol start="10">
<li><p>wget 用于从外网上下载插件  <code>wget -V</code> 查看版本，已安装掠过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install wget</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装vim编辑器, 系统一般会安装，可略过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install vim</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="安装gitlab"><a href="#安装gitlab" class="headerlink" title="安装gitlab"></a>安装gitlab</h3><ol>
<li><p>添加gitlab镜像<br>镜像需要跟自己的centos版本对应</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; centos 7</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gitlab-ce&#x2F;yum&#x2F;el7&#x2F;gitlab-ce-10.0.0-ce.0.el7.x86_64.rpm</span><br><span class="line">&#x2F;&#x2F; centos 8</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gitlab-ce&#x2F;yum&#x2F;el8&#x2F;gitlab-ce-12.10.1-ce.0.el8.x86_64.rpm</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装gitlab</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; centos 7</span><br><span class="line">rpm -i gitlab-ce-10.0.0-ce.0.el7.x86_64.rpm</span><br><span class="line">&#x2F;&#x2F; centos 8</span><br><span class="line">rpm -i gitlab-ce-12.10.1-ce.0.el8.x86_64.rpm</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如提示缺少相应的python依赖，手动安装即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install policycoreutils-python</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改gitlab配置文件指定服务器ip和自定义端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb</span><br></pre></td></tr></table></figure>
<p>修改 GitLab Url 模块下的 external_url</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">external_url &#39;http:&#x2F;&#x2F;ip:prot&#39;</span><br></pre></td></tr></table></figure>
<p>注意 port 端口不能被占用, 如果netstat 未安装 <code>yum -y install net-tools</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat  -anp|grep   端口号</span><br></pre></td></tr></table></figure>
<p>防火墙添加开放端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;端口号&#x2F;tcp --permanent</span><br><span class="line">&#x2F;&#x2F; success</span><br></pre></td></tr></table></figure>
<p>重新载入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br><span class="line">&#x2F;&#x2F;success</span><br></pre></td></tr></table></figure>
<p>查看防火墙端口状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --query-port&#x3D;9999&#x2F;tcp</span><br><span class="line">&#x2F;&#x2F;yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启动gitlab<br>首次等待时间会较长</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>
<p>重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure>




</li>
</ol>
<blockquote>
<p>原文地址 <a href="https://blog.csdn.net/ainixiya/article/details/103782511">https://blog.csdn.net/ainixiya/article/details/103782511</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>centos</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript 基础梳理</title>
    <url>/2020/08/27/javascript%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>构造函数Person以及实例对象person在原型链上的关系，如图所示</p>
<img src="/2020/08/27/javascript%E9%9D%A2%E8%AF%95%E9%A2%98/prototype.png" class="">

<p>每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性，实例对象可通过__proto__访问到对象的原型，这个原型指向构造函数的prototype。</p>
<p>每个原型都有一个 constructor 属性指向关联的构造函数</p>
<p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止</p>
<p>构造函数的constructor 指向 Function 构造器。</p>
<p>Function的原型指向Function.prototype</p>
<p>Function 的构造函数指向自己 Function.constructor === Function.<strong>proto</strong>.constructor === Function</p>
<p>构造函数、对象、原型之间的关系参考</p>
<img src="/2020/08/27/javascript%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF.png" class="">

<p><a href="https://www.cnblogs.com/yangdaren/p/10759868.html">js实现类的继承</a></p>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br><span class="line"><span class="comment">// local scope</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br><span class="line"><span class="comment">// local scope</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的</p>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><h4 id="执行上下文栈（函数调用栈）"><a href="#执行上下文栈（函数调用栈）" class="headerlink" title="执行上下文栈（函数调用栈）"></a>执行上下文栈（函数调用栈）</h4><p>JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文</p>
<p>为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ECStack = [];</span><br></pre></td></tr></table></figure>

<p>初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>以下方两段代码为例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ECStack.push(&lt;checkscope&gt; functionContext);</span></span><br><span class="line"><span class="comment">// ECStack.push(&lt;f&gt; functionContext);</span></span><br><span class="line"><span class="comment">// ECStack.pop();</span></span><br><span class="line"><span class="comment">// ECStack.pop();</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ECStack.push(&lt;checkscope&gt; functionContext);</span></span><br><span class="line"><span class="comment">// ECStack.pop();</span></span><br><span class="line"><span class="comment">// ECStack.push(&lt;f&gt; functionContext);</span></span><br><span class="line"><span class="comment">// ECStack.pop();</span></span><br></pre></td></tr></table></figure>

<h4 id="全局上下文和函数上下文的变量对象"><a href="#全局上下文和函数上下文的变量对象" class="headerlink" title="全局上下文和函数上下文的变量对象"></a>全局上下文和函数上下文的变量对象</h4><p>程序初始化时引擎会在执行上下文栈创建全局上下文globalContext,函数调用时会创建函数上下文functionContext</p>
<p>执行上下文包含三个部分</p>
<ul>
<li>变量对象（variable object, VO）</li>
<li>作用域链（scope chain）</li>
<li>this</li>
</ul>
<ul>
<li>全局上下文变量对象就是全局对象</li>
<li>函数上下文的变量对象<br>以下方函数代码为例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>函数创建时先初始化变量对象，只包含arguments<br>进入函数上下文时，再在变量对象上添加形参、函数声明、变量声明等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码执行阶段，会再次修改变量对象的属性值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">3</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression <span class="string">&quot;d&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考<a href="https://github.com/mqyqingfeng/Blog/issues/5">javascript深入之变量对象</a></p>
<h5 id="函数执行上下文，写出打印结果"><a href="#函数执行上下文，写出打印结果" class="headerlink" title="函数执行上下文，写出打印结果"></a>函数执行上下文，写出打印结果</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// ???</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// ???</span></span><br></pre></td></tr></table></figure>
<p>第一段会报错：Uncaught ReferenceError: a is not defined。</p>
<p>第二段会打印：1。</p>
<p>这是因为函数中的 “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中。</p>
<p>第一段执行 console 的时候， AO 的值是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        length: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。</p>
<p>当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。</p>
<h5 id="函数执行上下文，写出打印结果2"><a href="#函数执行上下文，写出打印结果2" class="headerlink" title="函数执行上下文，写出打印结果2"></a>函数执行上下文，写出打印结果2</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>会打印函数，而不是 undefined 。</p>
<p>这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p>
<p><code>function foo()</code> 与 <code>var foo = 1</code>顺序改变也一样</p>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>
<blockquote>
<p>使用Function构造器生成的函数，并不会在创建它们的上下文中创建闭包；它们一般在全局作用域中被创建。当运行这些函数的时候，它们只能访问自己的本地变量和全局变量，不能访问Function构造器被调用生成的上下文的作用域。这和使用带有函数表达式代码的 eval 不同。</p>
</blockquote>
<h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><h4 id="按顺序写出控制台打印结果"><a href="#按顺序写出控制台打印结果" class="headerlink" title="按顺序写出控制台打印结果"></a>按顺序写出控制台打印结果</h4><p>（2020 碧桂园）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> User = &#123;</span><br><span class="line">    count:<span class="number">1</span>,</span><br><span class="line">    action:&#123;</span><br><span class="line">        getCount:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getCount = User.action.getCount;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;result 1&quot;</span>,User.action.getCount())</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;result 2&quot;</span>,getCount())</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// result 2, undefined</span></span><br><span class="line"><span class="comment">// result 1, undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><p>防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。</p>
<h4 id="说一下防抖函数的应用场景，并简单说下实现方式"><a href="#说一下防抖函数的应用场景，并简单说下实现方式" class="headerlink" title="说一下防抖函数的应用场景，并简单说下实现方式"></a>说一下防抖函数的应用场景，并简单说下实现方式</h4><p>（滴滴）</p>
<p>防抖动是将多次执行变为最后一次执行，只在特定的时间内没有触发执行条件才执行一次代码<br>1、应用场景，输入框模糊搜索功能，点赞取消点赞等功能<br>2、实现方式，每次触发事件时设置一个延时器，并且取消之前的延时器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout); <span class="comment">// 每当触发的时候把前一个 setTimeout清除</span></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;搜索到相关内容&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inp = <span class="built_in">document</span>.getElementById(<span class="string">&quot;inp&quot;</span>);</span><br><span class="line">inp.addEventListener(<span class="string">&quot;input&quot;</span>, debounce(sayHi)); <span class="comment">// 防抖</span></span><br></pre></td></tr></table></figure>

<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><h4 id="基于es6的proxy方法设计一个属性拦截读取操作"><a href="#基于es6的proxy方法设计一个属性拦截读取操作" class="headerlink" title="基于es6的proxy方法设计一个属性拦截读取操作"></a>基于es6的proxy方法设计一个属性拦截读取操作</h4><p>要求实现去访问目标对象example中不存在的属性时，抛出错误：Property “$(property)” does not exist （2018 今日头条）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 案例代码</span></span><br><span class="line"><span class="keyword">const</span> man = &#123;</span><br><span class="line">    name:<span class="string">&#x27;jscoder&#x27;</span>,</span><br><span class="line">    age:<span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//补全代码</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(...)</span><br><span class="line">proxy.name   <span class="comment">// &quot;jscoder&quot;</span></span><br><span class="line">proxy.age     <span class="comment">// 22</span></span><br><span class="line">proxy.location   <span class="comment">// Property &quot;$(property)&quot; does not exist</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 答案</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(man, &#123;</span><br><span class="line">    get(target, property) &#123;</span><br><span class="line">        <span class="keyword">return</span> property <span class="keyword">in</span> target ? target[property] : <span class="built_in">console</span>.error(<span class="string">`Property &quot;<span class="subst">$&#123;property&#125;</span>&quot; does not exist`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="垃圾回收-GC"><a href="#垃圾回收-GC" class="headerlink" title="垃圾回收 GC"></a>垃圾回收 GC</h3><h4 id="说一下v8的垃圾回收机制"><a href="#说一下v8的垃圾回收机制" class="headerlink" title="说一下v8的垃圾回收机制"></a>说一下v8的垃圾回收机制</h4><p>v8内存设有上先，采用分代回收的思想，内存分为新生代和老生代，小空间用于存储新生代对象（32M|16M),新生代存放存活时间较短的对象（如局部作用域变量）</p>
<img src="/2020/08/27/javascript%E9%9D%A2%E8%AF%95%E9%A2%98/v8.png" class="">
<ul>
<li><p>新生代对象回收，新生代中用 Scavenge 算法来处理</p>
<ul>
<li>通过标记整理和复制算法实现</li>
<li>新生代内存会等分为两个空间，使用状态空间称为From，空闲空间称为To空间，From空间用于存储活动对象。</li>
<li>当对象区域快被写满时，就需要执行一次垃圾清理操作。对From空间执行标记，之后会把存活对象复制到To空间，并有序排列起来</li>
<li>接下来两个空间角色互换，直接释放掉原来的From空间</li>
</ul>
</li>
<li><p>一轮GC操作之后还存活的对象会晋升到老生代内存中，如果To空间使用率超过25%，新生代的对象也会晋升到老生代内存中(老生代对象回收，64位 1.4G 32 位 700M),老生代会存储 全局变量下的对象，一部分闭包中的数据</p>
<ul>
<li>老生代中采用 标记清除、标记整理、增量标记算法</li>
<li>通过标记清除完成垃圾空间的回收</li>
<li>采用标记整理进行空间优化，老生代不足以存储即将存储的对象，会触发标记整理操作</li>
<li>采用增量标记进行效率优化，GC操作会阻塞程序的执行，增量标记将整个标记过程拆分开来，每一个片段与程序执行交替进行。最后阻塞程序执行清除操作</li>
</ul>
</li>
</ul>
<img src="/2020/08/27/javascript%E9%9D%A2%E8%AF%95%E9%A2%98/old.png" class="">

<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="浏览器从输入url到页面展示，这中间发生了什么"><a href="#浏览器从输入url到页面展示，这中间发生了什么" class="headerlink" title="浏览器从输入url到页面展示，这中间发生了什么"></a>浏览器从输入url到页面展示，这中间发生了什么</h3><p>1、用户输入内容，浏览器会判断用户输入是搜索内容还是url</p>
<ul>
<li>如果是关键字，浏览器根据搜索引擎，合成携带关键字的url</li>
<li>如果是url，浏览器会拼接上协议，合成完整的url</li>
<li>在这之前，浏览器会判断当前页的beforeunload事件，判断是否组织页面跳转</li>
</ul>
<p>2、通过url请求资源，浏览器进程通过（IPC）把url发送给网络进程，网络进程发起请求<br>首先网络进程会判断本地缓存是否缓存了该资源，如果有直接返回给浏览器进程，如果没有该资源，进入网络请求流程</p>
<ul>
<li>通过DNS解析获取IP地址，如果是https,还需要建立TLS连接</li>
<li>通过IP与服务器建立TCP连接，建立连接后，浏览器会构建请求行请求头等信息，并把cookie相关信息添加到请求头中，然后发送给服务器</li>
<li>服务器根据请求信息生成响应数据（响应行，响应头，响应题），并发送给网络进程</li>
<li>网络进程拿到响应数据后，会判断响应行的响应状态，如果是301或302，说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，重新开始网络请求流程</li>
<li>如果响应行状态是200，浏览器会判断响应头的Content-type,如果是下载类型数据，提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束，如果是text/html,浏览器会继续执行导航流程，准备渲染进程</li>
</ul>
<p>3、浏览器将网络进程接收到的html数据提交给渲染进程</p>
<ul>
<li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</li>
<li>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；</li>
<li>等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；</li>
<li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li>
</ul>
<p>4、进入渲染流程，展示页面内容</p>
<h3 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h3><p>渲染流程就是讲javascript、html、css经过渲染模块的处理，最终输出为屏幕上的像素</p>
<p>1、构建DOM树，渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构</p>
<p>2、样式计算（Recalculate Style）</p>
<ul>
<li>处理样式表内容为浏览器可理解的结构stylesheets</li>
<li>标准化样式表中的属性值，比如blod，red，2em等属性值</li>
<li>根据继承和层叠规则计算DOM节点的样式  </li>
</ul>
<p>3、布局阶段，计算出 DOM 树中可见元素的几何位置</p>
<ul>
<li>创建布局树（不包含head标签和display：none等不可见元素）</li>
<li>布局计算，计算布局树节点的布局信息</li>
</ul>
<p>4、分层，为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）</p>
<ul>
<li>明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性</li>
<li>需要剪裁（clip）的地方也会被创建为图层</li>
</ul>
<p>5、图层绘制（Paint）为每个图层生成绘制指令列表，图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表</p>
<p>6、图块与栅格化（raster）<br>主线程将图层绘制列表提交给渲染进程合成线程，合成线程会将图层划分为图块。并按照视口附近的图块来优先生成位图（栅格化）</p>
<ul>
<li>栅格化的过程在渲染进程维护的栅格化线程池中进行</li>
<li>栅格化线程池中的线程通常借助GPU生成位图（快速栅格化）</li>
</ul>
<p>7、合成和显示</p>
<ul>
<li>图块光栅化之后，合成线程生成DrawQuad命令，通知浏览器将页面绘制到内存中，生成页面，并展示到屏幕上</li>
</ul>
<img src="/2020/08/27/javascript%E9%9D%A2%E8%AF%95%E9%A2%98/raster.png" class="">
<img src="/2020/08/27/javascript%E9%9D%A2%E8%AF%95%E9%A2%98/raster2.png" class="">
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins安装</title>
    <url>/2021/12/22/jenkins%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h3><p>Jenkins是java语言开发的，因需要jdk环境</p>
<p>搜索<code>jdk</code>安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum search java|grep jdk</span><br></pre></td></tr></table></figure>

<p>下载，默认路径 /usr/lib/jvm/</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install java</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<h3 id="jenkins安装"><a href="#jenkins安装" class="headerlink" title="jenkins安装"></a>jenkins安装</h3><p>按照官网的步骤安装</p>
<p>To use this repository, run the following command:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;jenkins.repo https:&#x2F;&#x2F;pkg.jenkins.io&#x2F;redhat-stable&#x2F;jenkins.repo</span><br><span class="line">sudo rpm --import https:&#x2F;&#x2F;pkg.jenkins.io&#x2F;redhat-stable&#x2F;jenkins.io.key</span><br></pre></td></tr></table></figure>

<p>If you’ve previously imported the key from Jenkins, the rpm –import will fail because you already have a key. Please ignore that and move on.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install epel-release # repository that provides &#39;daemonize&#39;</span><br><span class="line">yum install java-11-openjdk-devel</span><br><span class="line">yum install jenkins</span><br></pre></td></tr></table></figure>

<p>The rpm packages were signed using this key:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pub   rsa4096 2020-03-30 [SC] [expires: 2023-03-30]</span><br><span class="line">      62A9756BFD780C377CF24BA8FCEF32E745F2C3D5</span><br><span class="line">uid                      Jenkins Project</span><br><span class="line">sub   rsa4096 2020-03-30 [E] [expires: 2023-03-30]</span><br></pre></td></tr></table></figure>

<p>按照以上步骤安装时，如果提示无法连接，需要重新制作缓存,<a href="https://blog.csdn.net/Alan_Wdd/article/details/116260084">Jenkins yum [Errno 256] No more mirrors to try 解决方法</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>


<p>配置 jenkins 端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysconfig&#x2F;jenkins</span><br></pre></td></tr></table></figure>

<p>修改端口 ，<br>ps 需要检查端口占用情况 <code>netstat -anp|grep 9999</code><br>防火墙端口状态查看 <code>firewall-cmd --zone=public --query-port=9999/tcp</code><br>防火墙开启端口 <code>firewall-cmd --zone=public --add-port=端口号/tcp --permanent</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JENKINS_PORT&#x3D;&quot;9999&quot;</span><br></pre></td></tr></table></figure>

<p>启动jenkins</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service jenkins start&#x2F;stop&#x2F;restart</span><br></pre></td></tr></table></figure>

<h3 id="访问jenkins"><a href="#访问jenkins" class="headerlink" title="访问jenkins"></a>访问jenkins</h3><p>访问服务器端口<br>会看到需要初始密码，初始密码在 /var/lib/jenkins/secrets/initialAdminPassword</p>
<p>选择 Install suggested plugins 安装默认插件</p>
<p>等待安装完成后，创建管理员账户</p>
<p>ok!</p>
<h3 id="构建gitlab自动部署"><a href="#构建gitlab自动部署" class="headerlink" title="构建gitlab自动部署"></a>构建gitlab自动部署</h3><p><a href="https://www.cnblogs.com/niuben/p/12938501.html">nodejs安装</a></p>
<p>参照node 方式安装yarn 并设置全局依赖和缓存目录，并设置yarn 的软连接</p>
<p>安装git</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y git</span><br></pre></td></tr></table></figure>

<p>安装gitlab 相关插件 <code>gitlab hook plugin</code> , <code>gitlab plugin</code><br>创建jenkins 任务</p>
<p>选择构建一个自由风格的软件项目</p>
<ol>
<li>源码培训hi git 地址和密钥</li>
<li>构建触发器 选择  Build when a change is pushed to GitLab…<ul>
<li>勾选push event</li>
</ul>
</li>
<li>构建 中比那些shell 脚本</li>
<li>保存</li>
</ol>
<p>jenkins<br>系统配置 -&gt; GitHub -&gt; Github 服务器 -&gt; 高级 -&gt; 为 Github 指定另外一个 Hook URL -&gt; 保存</p>
<p>gitlab 配置 webhooks</p>
<ol>
<li>settings -&gt; integrations 或者 settings -&gt; webhooks</li>
<li>填写 jenkins 的hooks url</li>
<li>勾选 push events</li>
<li>添加</li>
<li>测试</li>
</ol>
<p>如果 gitlab hooks 测试出现 403 问题</p>
<ol>
<li>Configure Global Security -&gt; 授权策略 -&gt; Logged-in users can do anything （登录用户可以做任何事情） 点选 -&gt; 匿名用户具有可读权限 点选</li>
<li>去掉跨站点请求伪造 点选 放开<br>Manage Jenkins- &gt;Configure Global Security -&gt; CSRF Protection（跨站请求伪造保护）</li>
<li>去掉Gitlab enable authentication 点选 放开<br>系统管理 -&gt; 系统设置 -&gt; Enable authentication for ‘/project’ end-point<br>参考<a href="https://www.cnblogs.com/chenglc/p/11174530.html">Hook executed successfully but returned HTTP 403</a></li>
</ol>
<h3 id="彻底卸载Jenkins"><a href="#彻底卸载Jenkins" class="headerlink" title="彻底卸载Jenkins"></a>彻底卸载Jenkins</h3><p>如果Jenkins 安装失败需要重新安装，参考<a href="https://blog.csdn.net/weixin_37194108/article/details/106055992">彻底卸载Jenkins</a></p>
]]></content>
  </entry>
  <entry>
    <title>mobx</title>
    <url>/2021/01/14/mobx/</url>
    <content><![CDATA[<h3 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>mobx需要项目支持装饰器语法，在<strong>create-react-app</strong>项目中，进行下面的操作</p>
<p>方式一:</p>
<pre><code>  1. npm run eject
  2. npm install @babel/plugin-proposal-decorators
  3. package.json

    &quot;babel&quot;: &#123;
        &quot;plugins&quot;: [
            [
                &quot;@babel/plugin-proposal-decorators&quot;,
                &#123;
                    &quot;legacy&quot;: true
                &#125;
            ]
        ]
    &#125;</code></pre>
<p>  方式二:</p>
<pre><code>  1. npm install react-app-rewired @babel/plugin-proposal-decorators customize-cra

  2. 在项目根目录下创建 config-overrides.js

      const &#123; override, addDecoratorsLegacy &#125; = require(&quot;customize-cra&quot;);

      module.exports = override(addDecoratorsLegacy());

  3. package.json

      &quot;scripts&quot;: &#123;
          &quot;start&quot;: &quot;react-app-rewired start&quot;,
          &quot;build&quot;: &quot;react-app-rewired build&quot;,
          &quot;test&quot;: &quot;react-app-rewired test&quot;,
      &#125;</code></pre>
<p>解决vscode编辑器关于装饰器语法的警告</p>
<p>  “javascript.implicitProjectConfig.experimentalDecorators”: true</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i mobx mobx-react</span><br></pre></td></tr></table></figure>

<h4 id="上手使用"><a href="#上手使用" class="headerlink" title="上手使用"></a>上手使用</h4><p>这里通过一个简易的商品列表的功能，来演示<strong>mobx</strong>的使用</p>
<p>首先需要创建一下文件结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src&#x2F;</span><br><span class="line">---- product&#x2F;</span><br><span class="line">	 ---- store&#x2F;</span><br><span class="line">	      ---- mobx.js</span><br><span class="line">	 ---- index.js</span><br><span class="line">---- index.js</span><br></pre></td></tr></table></figure>

<p>我们在<strong>mobx.js中</strong>创建一个<strong>store</strong> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observable, action, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 通过observable修饰后的变量修改后才能被监听到</span></span><br><span class="line">	@observable list = [<span class="string">&#x27;商品1&#x27;</span>];</span><br><span class="line">	@observable isPicking = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算属性，当依赖项改变时重新计算计算属性值，需要加 get</span></span><br><span class="line">	@computed get totalNo () &#123;</span><br><span class="line">		<span class="keyword">const</span> temp = <span class="built_in">this</span>.list.filter(<span class="function"><span class="params">l</span> =&gt;</span> !l.isEat)</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			num: temp.length,</span><br><span class="line">			weight: temp.reduce(<span class="function">(<span class="params">total, l</span>) =&gt;</span> &#123;<span class="keyword">return</span> total + l.weight&#125;, <span class="number">0</span>),</span><br><span class="line">			list: temp,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	@computed get totalEat () &#123;</span><br><span class="line">		<span class="keyword">const</span> temp = <span class="built_in">this</span>.list.filter(<span class="function"><span class="params">l</span> =&gt;</span> l.isEat)</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			num: temp.length,</span><br><span class="line">			weight: temp.reduce(<span class="function">(<span class="params">total, l</span>) =&gt;</span> &#123;<span class="keyword">return</span> total + l.weight&#125;, <span class="number">0</span>),</span><br><span class="line">			list: temp,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修饰用于修改属性值得方法，.bound 修饰才能保证this指向正确</span></span><br><span class="line">	@action.bound eat = <span class="function">(<span class="params">code</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.list.find(<span class="function"><span class="params">l</span> =&gt;</span> l.code === code).isEat = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@action.bound addList = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">this</span>.list.push(&#123;</span><br><span class="line">			code: <span class="built_in">this</span>.code ++,</span><br><span class="line">			weight: <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">500</span>)</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例并导出</span></span><br><span class="line"><span class="keyword">const</span> product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> product;</span><br></pre></td></tr></table></figure>

<p>创建好的<strong>store</strong>需要在全局引入，并放入容器中方便子组件获取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> product <span class="keyword">from</span> <span class="string">&#x27;./product/store/mobx&#x27;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider product=&#123;product&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>接下来我们在组件中尝试使用它</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; inject, observer &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@inject(<span class="string">&#x27;product&#x27;</span>) <span class="comment">// 注入product这个store</span></span><br><span class="line">@observer  <span class="comment">// 当数据改变时会响应式通知组件更新</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> &#123; list, addList, totalNo, totalEat, eat &#125; = <span class="built_in">this</span>.props.product;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">				&lt;h2&gt;苹果篮子&lt;/h2&gt;</span><br><span class="line">				&lt;hr/&gt;</span><br><span class="line">				&lt;div className=<span class="string">&quot;total&quot;</span>&gt;</span><br><span class="line">					&lt;div className=<span class="string">&quot;hastotal&quot;</span>&gt;</span><br><span class="line">						&lt;div&gt;当前&lt;/div&gt;</span><br><span class="line">						&lt;div&gt;&#123;totalNo.num&#125;个苹果，&#123;totalNo.weight&#125;克&lt;/div&gt;</span><br><span class="line">					&lt;/div&gt;</span><br><span class="line">					&lt;div className=<span class="string">&quot;nototal&quot;</span>&gt;</span><br><span class="line">						&lt;div&gt;已吃掉&lt;/div&gt;</span><br><span class="line">						&lt;div&gt;&#123;totalEat.num&#125;个苹果，&#123;totalEat.weight&#125;克&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">					&lt;/div&gt;</span><br><span class="line">				&lt;/div&gt;</span><br><span class="line">				&#123;totalNo.list.map(<span class="function"><span class="params">l</span> =&gt;</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;appleitem&quot;</span>&gt;</span></span></span><br><span class="line">						&lt;div className=&quot;button&quot;&gt;</span><br><span class="line">							&lt;button onClick=&#123;() =&gt; &#123;eat(l.code)&#125;&#125;&gt;吃掉&lt;/button&gt;</span><br><span class="line"><span class="xml">						<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">						&lt;div className=&quot;appleImage&quot;&gt;</span><br><span class="line">							&lt;img src=&#123;apple&#125; /&gt;</span><br><span class="line"><span class="xml">						<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">						&lt;div className=&quot;title&quot;&gt;</span><br><span class="line">							红苹果 - &#123;l.code&#125;号</span><br><span class="line"><span class="xml">						<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">						&lt;div className=&quot;wiehgt&quot;&gt;</span><br><span class="line">							&#123;l.weight&#125;克</span><br><span class="line"><span class="xml">						<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">				&#125;)&#125;</span><br><span class="line">				&lt;p className=<span class="string">&quot;pickWrapper&quot;</span>&gt;</span><br><span class="line">					&lt;button className=<span class="string">&quot;pick&quot;</span> onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">						<span class="built_in">this</span>.props.product.addList(<span class="string">&#x27;商品&#x27;</span>)</span><br><span class="line">					&#125;&#125;&gt;添加一个商品&lt;/button&gt;</span><br><span class="line">				&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>这样就可以看到<strong>list</strong>数据在页面中展示了</p>
]]></content>
      <tags>
        <tag>mobx</tag>
      </tags>
  </entry>
  <entry>
    <title>react-hooks</title>
    <url>/2021/01/20/react-hooks/</url>
    <content><![CDATA[<h3 id="react-hooks"><a href="#react-hooks" class="headerlink" title="react hooks"></a>react hooks</h3><h4 id="userState"><a href="#userState" class="headerlink" title="userState"></a>userState</h4><p><strong>useState</strong> 在使用声明时可以传一个函数，这个函数可以用于动态的给 <strong>useState</strong> 附初始值，而函数中的代码又只会执行一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过这种方式也可以动态的附初始值，但是函数组件在每次调用的时候都会计算一次初始值，这无疑是浪费性能的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> num = props.num * <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">const</span> [count, setCount] = useState(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过useState附初始值动态设置初始数值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> [count, setCount] = useState(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> props.num * <span class="number">100</span>;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="设置状态值得函数使用细节"><a href="#设置状态值得函数使用细节" class="headerlink" title="设置状态值得函数使用细节"></a>设置状态值得函数使用细节</h5><p><strong>useState</strong>结构的第二的参数是设置值的函数，这个函数可以接受值，也可以接收一个函数。如上面的 <strong>setCount</strong> 在调用时可以传入一个函数，这个函数接收一个形参 ，代表当前值，函数返回要更改的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setCount(<span class="number">123</span>); <span class="comment">// 直接设置数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到原始值并返回新值</span></span><br><span class="line">setCount(<span class="function">(<span class="params">count</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面提到的 <strong>setCount</strong> 函数是异步的，比如下面的例子，返回的结果是1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = setState(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	setCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上边的代码中当 <strong>handle</strong>函数被调用时， <strong>setCount</strong> 会修改 <strong>count</strong> 的值，但是由于 <strong>set</strong> 函数是异步执行的，所以 打印的 <strong>count</strong> 值 任然为1</p>
<p>为了解决这个问题，可以将打印结果的代码放到 <strong>setCount</strong>传入的函数中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">funtion handle() &#123;</span><br><span class="line">	setCount(<span class="function"><span class="params">count</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> newcount = count + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">console</span>.log(newcount);</span><br><span class="line">		<span class="keyword">return</span> newcount;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h4><p><strong>useReducer</strong> 类似 <strong>redux</strong> , 用于统一管理状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>: <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">default</span>: <span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Num</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> [count, dispatcn] = useReducer(reducer, <span class="number">0</span>); <span class="comment">// 第一个参数是reducer处理函数，第二个是初始值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="xml">		dispatch(&#123;type: &#x27;increment&#x27;&#125;);</span></span><br><span class="line"><span class="xml">	&#125;&#125;&gt;&#123;count&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h4><p>用户跨组件跨层级传递数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在上层组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123;React, createContext, useContext&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = createContext()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;100&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">Foo</span>/&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">context.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子孙组件</span></span><br><span class="line"><span class="comment">// 在useContext 之前的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">context.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">		&#123;</span></span><br><span class="line"><span class="xml">			// 通过context.Consumer包裹 的 函数会接受一个形参，这个形参就是外层传入的value的值</span></span><br><span class="line"><span class="xml">			value =&gt; &#123;</span></span><br><span class="line"><span class="xml">				return <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">			&#125;</span></span><br><span class="line"><span class="xml">		&#125;</span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">context.Consumer</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是使用useContext之后的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> value = useContext(context); <span class="comment">// 传入上层生成的content</span></span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">		&#123;value&#125;</span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="useEffect-处理副作用"><a href="#useEffect-处理副作用" class="headerlink" title="useEffect 处理副作用"></a>useEffect 处理副作用</h4><p><strong>useEffect</strong> 注意卸载时的细节</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这种写法只有在App被卸载时才会打印 “卸载”</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&#x27;卸载&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, [])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种写法只要函数组件执行（比如state改变，props改变，父组件更新等）就会打印“卸载”</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&#x27;卸载&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="useEffect-相比生命周期函数的优点"><a href="#useEffect-相比生命周期函数的优点" class="headerlink" title="useEffect 相比生命周期函数的优点"></a>useEffect 相比生命周期函数的优点</h5><ul>
<li><strong>useEffect</strong>由于可以多次调用，因此可以按照用途把代码进行分类</li>
<li>简化重复代码，使组件内部代码更清晰。比如常常 <strong>componentDidmount</strong> 和 <strong>componentDidUpdate</strong> 会执行一些相同的逻辑</li>
</ul>
<h5 id="useEffect-第二个参数"><a href="#useEffect-第二个参数" class="headerlink" title="useEffect 第二个参数"></a>useEffect 第二个参数</h5><p><strong>useEffect</strong> 第二个参数可以不传也可以传数组，空数组代表只在挂载时执行一次，如果数组中有值，则会在第一次和人一个数组项发生改变时执行</p>
<h5 id="useEffect-处理异步"><a href="#useEffect-处理异步" class="headerlink" title="useEffect 处理异步"></a>useEffect 处理异步</h5><p><strong>useEffect</strong> 如果写成 <strong>async</strong> 函数，执行会报错，因为 <strong>useEffect</strong> 只能返回一个函数，这个函数用于 组件卸载时使用，或者不返回内容。而 <strong>async</strong> 函数会返回一个 <strong>promise</strong> 这是 <strong>useEffect</strong> 中不被允许的</p>
<p>我们可以这样来写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">		<span class="keyword">const</span> &#123;data&#125; = <span class="keyword">await</span> axios.get();</span><br><span class="line">		setData(data);</span><br><span class="line">	&#125;)()</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	axios.get().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">		setData(data.data);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> getData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> &#123;data&#125; = <span class="keyword">await</span> axios.get();</span><br><span class="line">	setData(data);</span><br><span class="line">&#125;</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	getData();</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h4><p>类似于 <strong>Vue</strong> 中的计算属性，可以根据某个值得变化计算新值<br><strong>useMemo</strong> 会缓存计算结果，如果监测值没有变化，组件重新渲染也不会重新计算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reuslt = useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> count * <span class="number">2</span>;</span><br><span class="line">&#125;, [count])</span><br></pre></td></tr></table></figure>

<h4 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h4><p>用于函数组件的性能优化，如果组建中数据没有发生变化，阻止组件更新，类似类组件使用的 <strong>PureComponent</strong></p>
<p><strong>React.memo</strong> 是一个高阶组件（HOC， 高阶组件用于共享代码，逻辑复用）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MemoCon = React.memo(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 &lt;MemoCon&gt;时 只要name不变就不会重新渲染</span></span><br></pre></td></tr></table></figure>

<p><strong>memo</strong> 也可以通过传递第二个参数，来进行深度比较</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Name</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.obj.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MemoCon = React.memo(Name, <span class="function">(<span class="params">preProps, newProps</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (preProps.name === newProps.name) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回 true 代表不用更新</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回false 代表需要更新</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback()"></a>useCallback()</h4><p>用于函数组件的性能优化，可以缓存函数，使组件重新渲染时获得相同的函数实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">	const test &#x3D; useCallback(() &#x3D;&gt; &#123;console.log(&#39;test&#39;)&#125;, []);</span><br><span class="line">	return &lt;MemoTest test&#x3D;&#123;test&#125;&#x2F;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，如果<strong>test</strong>不使用<strong>useCallback</strong>包装，会导致组件render时，每次给 <strong>MemoTest</strong> 的 <strong>test</strong> 都是一个新的函数实例，从而导致 <strong>memo</strong> 没有发挥作用</p>
<h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef()"></a>useRef()</h4><h5 id="useRef-用于获取-DOM-对象"><a href="#useRef-用于获取-DOM-对象" class="headerlink" title="useRef 用于获取 DOM 对象"></a><strong>useRef</strong> 用于获取 <strong>DOM</strong> 对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> ref = useRef();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 可以通过 ref.current 获取到对应的dom元素</span></span><br><span class="line">	<span class="keyword">const</span> change = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(ref.current.value);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;change&#125;/</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用于保存数据"><a href="#用于保存数据" class="headerlink" title="用于保存数据"></a>用于保存数据</h5><p>比如可以用于保存 唯一实例，在state改变后仍然可以拿到之前的实例</p>
<p>这里以一个计时器的功能为例，点击按钮清除计时器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function App () &#123;</span><br><span class="line">	const timer &#x3D; useRef(null);</span><br><span class="line">		</span><br><span class="line">	useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">		timer.current &#x3D; setInterval(..)</span><br><span class="line">	&#125;, [])</span><br><span class="line">	</span><br><span class="line">	return &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123;</span><br><span class="line">		cleatInterval(timer.current)</span><br><span class="line">	&#125;&#125;&gt;清除计时器&lt;&#x2F;button&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h3><ul>
<li><p>用于函数组件封装共享逻辑</p>
</li>
<li><p>自定义Hook是一个函数，以use开头</p>
</li>
<li><p>自定义Hook就是逻辑和内置Hook的组合</p>
</li>
</ul>
<p>这里以实现一个时钟为例，演示 自定义 <strong>Hook</strong> 的逻辑复用方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 自定义时钟 hook</span><br><span class="line">function useTime() &#123;</span><br><span class="line">	const [time, setTime] &#x3D; useState(&#39;&#39;)</span><br><span class="line">	useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">		const timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">			const date &#x3D; new Date();</span><br><span class="line">			setTime(&#96;$&#123;date.getHours()&#125;:$&#123;date.getMinutes()&#125;:$&#123;date.getSeconds()&#125;&#96;)</span><br><span class="line">		&#125;, 1000);</span><br><span class="line">		return () &#x3D;&gt; &#123;</span><br><span class="line">			clearInterval(timer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, [])</span><br><span class="line"></span><br><span class="line">	return time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">    &#x2F;&#x2F; 直接使用hook， 并接受返回值</span><br><span class="line">	const time &#x3D; useTime();</span><br><span class="line">	</span><br><span class="line">	return &lt;div&gt;</span><br><span class="line">		&#123;time&#125;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再以一个表单为例，抽离双向绑定的逻辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function useInput(initialValue) &#123;</span><br><span class="line">	const [value, setValue] &#x3D; useState(initialValue);</span><br><span class="line">	return &#123;</span><br><span class="line">		value,</span><br><span class="line">		onChange: e &#x3D;&gt; setValue(e.target.value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">	const username &#x3D; useInput(&#39;along&#39;);</span><br><span class="line">	const password &#x3D; useInput(&#39;123456&#39;);</span><br><span class="line"></span><br><span class="line">	const submit &#x3D; e &#x3D;&gt; &#123;</span><br><span class="line">		e.preventDefault();</span><br><span class="line">		console.log(username.value, password.value);</span><br><span class="line">	&#125;</span><br><span class="line">	return &lt;form onSubmit&#x3D;&#123;submit&#125;&gt;</span><br><span class="line">		&lt;input type&#x3D;&quot;text&quot; &#123;...username&#125;&#x2F;&gt;</span><br><span class="line">		&lt;input type&#x3D;&quot;password&quot; &#123;...password&#125;&#x2F;&gt;</span><br><span class="line">		&lt;input type&#x3D;&quot;submit&quot;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;form&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="React-router-dom-提供的路由钩子函数"><a href="#React-router-dom-提供的路由钩子函数" class="headerlink" title="React-router-dom 提供的路由钩子函数"></a>React-router-dom 提供的路由钩子函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;BrowserRouter&gt;</span><br><span class="line">    &lt;Link to&#x3D;&quot;&#x2F;home&quot;&gt;首页&lt;&#x2F;Link&gt;</span><br><span class="line">    &lt;Link to&#x3D;&quot;&#x2F;test&#x2F;1&quot;&gt;代码联系&lt;&#x2F;Link&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125; &#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;test&#x2F;:appid&quot; component&#x3D;&#123;App&#125; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;BrowserRouter&gt;,</span><br><span class="line">  document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&lt;Link&gt;</span><br></pre></td></tr></table></figure>

<p>当时用 <strong>react-router-dom</strong> 定义路由时，每个路由模块内部的 <strong>props</strong> 会 自动注入 <strong>history ** **location</strong> <strong>match</strong> 几个属性，用于获得当前组件的路由相关的信息。我们可以直接通过<strong>props</strong>拿到对应的属性，不过，如果组件有多层嵌套，比如 <strong>App</strong> 组件中使用了 <strong><Test/></strong> 组件 ，在 <strong>Test</strong> 组件中如果要取到 路由相关的信息，需要 <strong>App</strong> 将 <strong>props</strong> 向下传递，在组建嵌套较深时我们需要逐层传递无疑会非常麻烦。</p>
<p>因此 <strong>react-router-dom</strong> 为我们提供了几个 内置 <strong>hook</strong> ，方便我们在组件中拿到 路由相关的参数，而不必考虑 组件嵌套的层级</p>
<ul>
<li><p><strong>useHistory</strong> 获取 props 中的 history 对象</p>
</li>
<li><p><strong>useLocation</strong> 获取 props 中的 location 对象</p>
</li>
<li><p><strong>useRouteMatch</strong> 获取 props 中的 match 对象</p>
</li>
<li><p><strong>useParams</strong> 获取 props 中的 match 属性下的 params 对象</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route path&#x3D;&quot;&#x2F;test&quot; component&#x3D;&#123;App&#125; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不适用 路由 相关 hook, 路由相关的属性需要逐层传递</span><br><span class="line">function Test(props) &#123;</span><br><span class="line">    return props.history</span><br><span class="line">&#125;</span><br><span class="line">function App(porps) &#123;</span><br><span class="line">	return &lt;div&gt;&lt;Test history&#x3D;&#123;props.history&#125;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 路由 hook， 可以直接拿到路由参数</span><br><span class="line">function Test() &#123;</span><br><span class="line">    const history &#x3D; useHistory();</span><br><span class="line">    return history</span><br><span class="line">&#125;</span><br><span class="line">function App() &#123;</span><br><span class="line">	return &lt;div&gt;&lt;Test&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="react-hooks-实现原理"><a href="#react-hooks-实现原理" class="headerlink" title="react hooks 实现原理"></a>react hooks 实现原理</h3><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><p>实现一个简易的 <strong>useState</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let state &#x3D; []; &#x2F;&#x2F; 用于保存所有useState 的 value 值</span><br><span class="line">let setters &#x3D; []; &#x2F;&#x2F; 用于保存 所有 useState 的 setter ， 即useState 返回数组的 第二项</span><br><span class="line">let stateIndex &#x3D; 0; &#x2F;&#x2F; 用于 记录当前 value 和 setter 的 索引。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用于创建一个 闭包的 setter ， 来修改对应索引的 state 数组中的值</span><br><span class="line">const createSetter &#x3D; (stateIndex) &#x3D;&gt; &#123;</span><br><span class="line">	return (value) &#x3D;&gt; &#123;</span><br><span class="line">		state[stateIndex] &#x3D; value;</span><br><span class="line">		render();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; useState 实现， 接收一个默认值，在首次调用时 设置value 为默认值， 从第二次开始从 state 数组中取</span><br><span class="line">function useState(initialState) &#123;</span><br><span class="line">    &#x2F;&#x2F; 当 索引 能在 state 数组中取到值时， 返回 state 数组中对应的值，否则返回 传入的默认值</span><br><span class="line">	state[stateIndex] &#x3D; stateIndex &lt; state.length ? state[stateIndex] : initialState;</span><br><span class="line">    &#x2F;&#x2F; 创建setter 并 保存到 setters 数组的对应位置</span><br><span class="line">	setters.push(createSetter(stateIndex));</span><br><span class="line">    &#x2F;&#x2F; 取到对应的 value 和 setter</span><br><span class="line">	const value &#x3D; state[stateIndex];</span><br><span class="line">	const setter &#x3D; setters[stateIndex];</span><br><span class="line">    &#x2F;&#x2F; 索引指针向后移以为，待下一个 useState 使用</span><br><span class="line">	stateIndex ++;</span><br><span class="line">	return [value, setter];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当 useState 的 setter 被执行时调用，重新渲染 整个应用，并 将 索引 内置</span><br><span class="line">function render() &#123;</span><br><span class="line">	stateIndex &#x3D; 0;</span><br><span class="line">	ReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#39;root&#39;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 程序入口</span><br><span class="line">function App() &#123;</span><br><span class="line">	const [count, setCount] &#x3D; useState(0);</span><br><span class="line">	const [name, setName] &#x3D; useState(&#39;along&#39;);</span><br><span class="line">	return &lt;div&gt;</span><br><span class="line">		&lt;div&gt;&#123;count&#125;&lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123;setCount(count + 1)&#125;&#125;&gt;加&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;div&gt;&#123;name&#125;&lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123;setName(&#39;文龙&#39;)&#125;&#125;&gt;改名&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;</span><br><span class="line">		</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 首次渲染</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App&#x2F;&gt;,</span><br><span class="line">  document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>由上面的实现代码可以看出，useState的顺序很重要，如果<strong>useState</strong> 顺序发生了改变，会导致取值出现问题 【ps：这里只是演示 useState的实现原理，上述代码在一些场景会有问题】</p>
<h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><p>接着上面 <strong>useState</strong> 的代码，来实现一下 <strong>useEffect</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let preDepsArr &#x3D; []; &#x2F;&#x2F; 定义一个全局变量用来保存上一次 useEffect 的依赖数组， 如果 useEffect 没有传递第二个参数，则不会在这里保存</span><br><span class="line">let effectIndex &#x3D; 0; &#x2F;&#x2F; 类似于 useState 的 stateIndex, 用于记录 当前 useEffect 的索引。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; render函数中要额外重置一下 effectIndex</span><br><span class="line">function render() &#123;</span><br><span class="line">	stateIndex &#x3D; 0;</span><br><span class="line">	effectIndex &#x3D; 0;</span><br><span class="line">	ReactDOM.render(&lt;Root&#x2F;&gt;, document.getElementById(&#39;root&#39;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function useEffect(callback, depsArr) &#123;</span><br><span class="line">	if (Object.prototype.toString.call(callback) !&#x3D;&#x3D; &#39;[object Function]&#39;) throw new Error(&#39;第一个参数需要是函数&#39;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 如果没有传递第二个参数，直接调用callback执行</span><br><span class="line">	if (typeof depsArr &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">		callback();</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if (Object.prototype.toString.call(depsArr) !&#x3D;&#x3D; &#39;[object Array]&#39;) throw new Error(&#39;第二个参数要么不传，要么必须是数组&#39;);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 拿到上一次的依赖，第一次执行时肯定没有这个依赖值</span><br><span class="line">		let preDeps &#x3D; preDepsArr[effectIndex];</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 定义一个变量，用于表示依赖是否发生过变化</span><br><span class="line">		&#x2F;&#x2F; 如果 上一次的依赖不存在，说明发生了变化，直接赋值 hasChange 为 true</span><br><span class="line">		&#x2F;&#x2F; 如果 上一次的依赖  存在，比对新旧依赖数组的每一项，如果有一项发生改变，赋值 hasChange 为 true</span><br><span class="line">		let hasChange &#x3D; preDeps </span><br><span class="line">			? depsArr.every((dep, index) &#x3D;&gt; dep &#x3D;&#x3D;&#x3D; preDeps[index]) &#x3D;&#x3D;&#x3D; false </span><br><span class="line">			: true;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 如果发生了改变，执行回调函，并将新的依赖数组替换掉原来的依赖数组</span><br><span class="line">		if (hasChange) &#123;</span><br><span class="line">			callback();</span><br><span class="line">			preDepsArr[effectIndex] &#x3D; depsArr;</span><br><span class="line">		&#125;</span><br><span class="line">		effectIndex ++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">	const [count, setCount] &#x3D; useState(0);</span><br><span class="line">	const [name, setName] &#x3D; useState(&#39;along&#39;);</span><br><span class="line">	</span><br><span class="line">	useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">		console.log(&#39;count改变了&#39;)</span><br><span class="line">	&#125;, [count])</span><br><span class="line">	</span><br><span class="line">	useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">		console.log(&#39;name改变了&#39;)</span><br><span class="line">	&#125;, [name])</span><br><span class="line">	</span><br><span class="line">	return &lt;&gt;</span><br><span class="line">		&lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123;setCount(count + 1)&#125;&#125;&gt;&#123;count&#125;&lt;&#x2F;button&gt;</span><br><span class="line">		&lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123;setName(&#39;阿龙&#39;)&#125;&#125;&gt;&#123;name&#125;&lt;&#x2F;button&gt;</span><br><span class="line">	&lt;&#x2F;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里并没有实现 useEffect 回调函数有返回值的情况</p>
<h4 id="useReducer-1"><a href="#useReducer-1" class="headerlink" title="useReducer"></a>useReducer</h4><p><strong>useReducer</strong> 原理非常简单，它实际上是 <strong>useState</strong> 和 <strong>redux</strong> 设计思想的结合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function useReducer(reducer, initialState) &#123;</span><br><span class="line">	const [state, setState] &#x3D; useState(initialState); &#x2F;&#x2F; 内部使用 useState 保存状态</span><br><span class="line">	const dispatch &#x3D; (action) &#x3D;&gt; &#123;</span><br><span class="line">		setState(reducer(state, action));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return [state, dispatch];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">	function reducer(state, action) &#123;</span><br><span class="line">		switch(action.type) &#123;</span><br><span class="line">			case &#39;incre&#39;: return state + 1;</span><br><span class="line">			case &#39;decre&#39;: return state - 1; </span><br><span class="line">			default: return state;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	const [num, dispatch] &#x3D; useReducer(reducer, 0);</span><br><span class="line"></span><br><span class="line">	return &lt;&gt;</span><br><span class="line">		&lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123;dispatch(&#123;type: &#39;incre&#39;&#125;)&#125;&#125;&gt;&#123;num&#125;&lt;&#x2F;button&gt;</span><br><span class="line">	&lt;&#x2F;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>npm安装过程</title>
    <url>/2021/01/21/npm%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>以安装gulp-imagemin为例</p>
<p>请求一个接口 <a href="https://registry.npmjs.com/gulp">https://registry.npmjs.com/gulp</a> 你的镜像地址 + 项目名</p>
<p>这个接口会返回json数据</p>
<p>下载某个npm模块后，回家压倒node_modules中，检查木块的package.json 的 scripts ，是否有 install 和 postinstall， 这两个会自动执行</p>
]]></content>
  </entry>
  <entry>
    <title>react 性能优化</title>
    <url>/2021/01/20/react-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="React-性能优化"><a href="#React-性能优化" class="headerlink" title="React 性能优化"></a>React 性能优化</h3><p>核心减少渲染真实DOM的频率,减少Diff比对次数</p>
<h4 id="1-组件卸载前做清理操作"><a href="#1-组件卸载前做清理操作" class="headerlink" title="1. 组件卸载前做清理操作"></a>1. 组件卸载前做清理操作</h4><p>组建中注册的事件计时器等在组件卸载时做清理操作</p>
<h4 id="2-使用纯组件降低组件重新渲染的频率"><a href="#2-使用纯组件降低组件重新渲染的频率" class="headerlink" title="2. 使用纯组件降低组件重新渲染的频率"></a>2. 使用纯组件降低组件重新渲染的频率</h4><p>纯组件指在输入相同的state props 时呈现相同的输出</p>
<ul>
<li><strong>PureComponent</strong> 内部通过对当props和state进行浅比较，减少不必要的diff<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>也可以通过生命周期函数 <strong>shouComponentUpdate</strong> 来阻止组件不必要的渲染</li>
</ul>
<h4 id="3-React-memo"><a href="#3-React-memo" class="headerlink" title="3. React.memo"></a>3. React.memo</h4><p>用于函数组件，类似类组件使用的 <strong>PureComponent</strong></p>
<p><strong>React.memo</strong> 是一个高阶组件（HOC， 高阶组件用于共享代码，逻辑复用）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MemoCon = React.memo(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 &lt;MemoCon&gt;时 只要name不变就不会重新渲染</span></span><br></pre></td></tr></table></figure>

<p><strong>memo</strong> 也可以通过传递第二个参数，来进行深度比较</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Name</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.obj.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MemoCon = React.memo(Name, <span class="function">(<span class="params">preProps, newProps</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (preProps.name === newProps.name) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回 true 代表不用更新</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回false 代表需要更新</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="4-shouComponentUpdate-减少组件渲染频率"><a href="#4-shouComponentUpdate-减少组件渲染频率" class="headerlink" title="4. shouComponentUpdate 减少组件渲染频率"></a>4. shouComponentUpdate 减少组件渲染频率</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Con</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.state.name !== nextState.name) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-懒加载"><a href="#5-懒加载" class="headerlink" title="5.懒加载"></a>5.懒加载</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123;lazy, Suspense&#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">const About &#x3D; lazy(() &#x3D;&gt; import(&#39;.&#x2F;About&#39;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">	&lt;Switch&gt;</span><br><span class="line">		&lt;Route path&#x3D;&quot;&#x2F;about&quot;&gt;</span><br><span class="line">			&lt;Suspense fallback&#x3D;&#123;&lt;div&gt;loading...&lt;&#x2F;div&gt;&#125;&gt;</span><br><span class="line">				&lt;About&#x2F;&gt;</span><br><span class="line">			&lt;&#x2F;Suspense&gt;</span><br><span class="line">		&lt;&#x2F;Route&gt;</span><br><span class="line">	&lt;&#x2F;Switch&gt;</span><br><span class="line">&lt;&#x2F;BrowserRouter&gt;</span><br></pre></td></tr></table></figure>

<h4 id="6-Fragment-来避免额外的标记"><a href="#6-Fragment-来避免额外的标记" class="headerlink" title="6. Fragment 来避免额外的标记"></a>6. Fragment 来避免额外的标记</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;React.Fragment&gt;</span><br><span class="line">	&lt;div&gt;1&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div&gt;1&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;React.Fragment&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者直接</span><br><span class="line">&lt;&gt;</span><br><span class="line">	&lt;div&gt;1&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div&gt;1&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="7-不要使用内联函数定义"><a href="#7-不要使用内联函数定义" class="headerlink" title="7. 不要使用内联函数定义"></a>7. 不要使用内联函数定义</h4><p>在使用内联函数后， <strong>render</strong> 每次运行都会创建函数的新实例,造成性能开销</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 内联函数方式</span><br><span class="line">class Con extends Component &#123;</span><br><span class="line"></span><br><span class="line">	render () &#123;</span><br><span class="line">		return &lt;input</span><br><span class="line">			onChange&#x3D;&#123;e &#x3D;&gt; &#123;console.log(e.target.value)&#125;&#125;</span><br><span class="line">		&#x2F;&gt;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;推荐这样写</span><br><span class="line">class Con extends Component &#123;</span><br><span class="line"></span><br><span class="line">	log &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class="line">		console.log(e.target.value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	render () &#123;</span><br><span class="line">		return &lt;input</span><br><span class="line">			onChange&#x3D;&#123;this.log&#125;</span><br><span class="line">		&#x2F;&gt;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-在构造函数中this绑定"><a href="#8-在构造函数中this绑定" class="headerlink" title="8. 在构造函数中this绑定"></a>8. 在构造函数中this绑定</h4><p>通过 <strong>fn(){}</strong> 的形式声明函数时，可以通过在构造函数中绑定 <strong>this</strong> 也可以通过调用的地方绑定 <strong>this</strong>,不过两者的方式也存在区别</p>
<p>在 调用的地方 绑定 <strong>this</strong> 会造成与内联函数一样的问题，每次调用 render 都会生成一个新的函数实例，从而产生性能问题，（并且会影响子组件里的 <strong>componentDidUpdate</strong>失效 ）</p>
<p>而 <strong>constroctor</strong> 中执行会只绑定一次，推荐使用这种用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">class Con extends Component &#123;</span><br><span class="line">	constructor(props) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	fn() &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	render() &#123;</span><br><span class="line">		return &lt;button onClick&#x3D;&#123;this.fn.bind(this)&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">class Con extends Component &#123;</span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.fn &#x3D; this.fn.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	fn() &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	render() &#123;</span><br><span class="line">		return &lt;button onClick&#x3D;&#123;this.fn&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以借助箭头函数来书写，这里看下箭头函数编译后的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Con</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;fn&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后相当于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Con</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="built_in">super</span>(props)</span><br><span class="line">        <span class="built_in">this</span>.fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;fn&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-箭头函数使用情景"><a href="#9-箭头函数使用情景" class="headerlink" title="9. 箭头函数使用情景"></a>9. 箭头函数使用情景</h4><p>箭头函数在this指向上有一定优势， 但是也有不利的一面</p>
<p>箭头函数会将函数绑定到实例对象上，添加的是实例对象属性， 而不是原型对象属性，如果组件多次调用，每个组件实例对象上都会有相同的函数实例，会产生一定的性能开销</p>
<p>那么在构造函数中绑定 <strong>this</strong> 不也是实例对象属性吗，没错。上面一点我们也看过箭头函数编译后的代码了。不过这里需要探讨的是，在什么情况下更适合使用箭头函数，什么情况下更适合使用普通函数。</p>
<p>这里举一个栗子, 场景是我们有一个组件，需要从接口获取公司人员的数组，数组中的每一个人包含id，所属领导id等信息，现在在这个组件中需要将数组处理成一个树形的包含关系，在界面上显示一个包含层级关系的公司员工列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Con extends Component &#123;</span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		super(props);</span><br><span class="line">		this.state &#x3D; &#123;</span><br><span class="line">			peopletree: []</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	componentDidMount() &#123;</span><br><span class="line">		&#x2F;&#x2F; 模拟从服务器获取到了数据 data， 代表公司的所有人员集合</span><br><span class="line">		const data &#x3D; [</span><br><span class="line">				&#123;</span><br><span class="line">					belong: null,</span><br><span class="line">					id: &#39;1&#39;,</span><br><span class="line">					name: &#39;张三&#39;,</span><br><span class="line">					position: &#39;部门总监&#39;,</span><br><span class="line">				&#125;,</span><br><span class="line">				&#123;</span><br><span class="line">					belong: &#39;1&#39;,</span><br><span class="line">					id: &#39;2&#39;,</span><br><span class="line">					name: &#39;李四&#39;,</span><br><span class="line">					position: &#39;前端leader&#39;</span><br><span class="line">				&#125;,</span><br><span class="line">				&#x2F;&#x2F; ...</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">    	&#x2F;&#x2F; 调用实例方法</span><br><span class="line">		this.setPeopleTree(data);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	setPeopleTree &#x3D; (list) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用原型属性方法拿到结果</span><br><span class="line">		const peopletree &#x3D; this.reduceListToTreeList(list);</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            peopletree</span><br><span class="line">        &#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	reduceListToTreeList(list) &#123;</span><br><span class="line">        &#x2F;&#x2F;处理逻辑 省略</span><br><span class="line">		&#x2F;&#x2F; 这里直接模拟返回处理完成的结果</span><br><span class="line">		return [&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                belong: null,</span><br><span class="line">                id: &#39;1&#39;,</span><br><span class="line">                name: &#39;张三&#39;,</span><br><span class="line">                position: &#39;部门总监&#39;,</span><br><span class="line">            	under: [</span><br><span class="line">            		&#123;</span><br><span class="line">            			belong: &#39;1&#39;,</span><br><span class="line">                         id: &#39;2&#39;,</span><br><span class="line">                         name: &#39;李四&#39;,</span><br><span class="line">                         position: &#39;前端leader&#39;,</span><br><span class="line">            			under: [...]</span><br><span class="line">        			&#125;</span><br><span class="line">            	]</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;]</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        ... &#x2F;&#x2F; 渲染界面</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个栗子中，通过 处理列表返回树的方法 <strong>reduceListToTreeList</strong> 由于内部不需要使用 <strong>this</strong>， 通过普通函数声明方式将其挂载到组件原型属性上，不必在每个实例声明相同逻辑的函数，减少一定的性能开销</p>
<p>所以，在类组件里的某些不使用this的函数中，可以使用普通函数的声明方法挂载到原型对象属性上。（ps: 当然了，如果有需要也可以把原型属性方法提取到工具类里使用）</p>
<h4 id="10-避免使用内联样式属性"><a href="#10-避免使用内联样式属性" class="headerlink" title="10. 避免使用内联样式属性"></a>10. 避免使用内联样式属性</h4><p>内联样式会被编译成js代码，然后映射上元素上。需要额外执行js脚本，需要浪费一些性能。</p>
<p>另外，通过内联样式也会导致组件每次render都会实例化一个样式对象，产生一定的开销。如果一定要使用内联js样式，尽量提取样式对象到外层吧。</p>
<p>推荐使用引入 <strong>css</strong> 文件的方式。</p>
<p>ps：这里再提一种非常少见也是错误使用的方法，比如在调用一个 <strong>memo</strong> 优化后的组件，给这个组件传递了 <strong>style</strong> （react是不允许使用style作为属性传递的，如果在组件内部获取 <strong>props.style</strong> 会报错。但是如果内部没有这么做，仅仅是父组件在调用 <strong>memo</strong> 优化的组件时传递了 内联 <strong>style</strong> 是不会报错的），那么每次父组件<strong>render</strong> ， 子组件都会<strong>render</strong>。 </p>
<p>通过这点只是为了提示大家在<strong>render</strong>中尽量不要动态的声明对象、函数。因为</p>
<ul>
<li>每次都要声明新的对象，之前的对象浏览器又要额外做垃圾回收。</li>
<li>会导致接收对象参数的 纯组件 无谓的渲染</li>
</ul>
<h4 id="11-优化条件渲染"><a href="#11-优化条件渲染" class="headerlink" title="11. 优化条件渲染"></a>11. 优化条件渲染</h4><p>频繁的挂载卸载组建是消耗性能的操作，因此需要减少挂载和卸载次数</p>
<p>在 <strong>React</strong> 中经常通过条件来渲染不同的界面</p>
<p>比如这里我有一个经过memo优化的组件 <strong>MemoFooter</strong> 和一个普通组件 <strong>Header</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Header () &#123;</span><br><span class="line">	useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">		console.log(&#39;header挂载&#39;)</span><br><span class="line">		return () &#x3D;&gt; &#123;</span><br><span class="line">			console.log(&#39;header卸载&#39;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	return &lt;div&gt;header&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Footer () &#123;</span><br><span class="line">	useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">		console.log(&#39;footer挂载&#39;);</span><br><span class="line">		return () &#x3D;&gt; &#123;</span><br><span class="line">			console.log(&#39;footer卸载&#39;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	return &lt;div&gt;footer&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const MemoFooter &#x3D; React.memo(Footer);</span><br></pre></td></tr></table></figure>

<p>然后在 <strong>App</strong> 组件中条件渲染 <strong>Header</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function App () &#123;</span><br><span class="line">	const [staff, setStaff] &#x3D; useState(false);</span><br><span class="line">	useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">		setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">			setStaff(true);</span><br><span class="line">		&#125;, 5000)</span><br><span class="line">	&#125;, [])</span><br><span class="line"></span><br><span class="line">	if (staff) &#123;</span><br><span class="line">		return &lt;&gt;</span><br><span class="line">			&lt;Header&#x2F;&gt;</span><br><span class="line">			&lt;MemoFooter&#x2F;&gt;</span><br><span class="line">		&lt;&#x2F;&gt;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return &lt;&gt;</span><br><span class="line">			&lt;MemoFooter&#x2F;&gt;</span><br><span class="line">		&lt;&#x2F;&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的情况中，五秒后会看到控制台打印</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer挂载</span><br><span class="line">&#x2F;&#x2F; 5s 后</span><br><span class="line">footer卸载</span><br><span class="line">header挂载</span><br><span class="line">footer挂载</span><br></pre></td></tr></table></figure>

<p>推荐优化条件语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function App () &#123;</span><br><span class="line">	const [staff, setStaff] &#x3D; useState(false);</span><br><span class="line">	useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">		setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">			setStaff(true);</span><br><span class="line">		&#125;, 5000)</span><br><span class="line">	&#125;, [])</span><br><span class="line"></span><br><span class="line">	return &lt;&gt;</span><br><span class="line">	 	&#123; staff &amp;&amp; &lt;Header&#x2F;&gt; &#125;</span><br><span class="line">	 	&lt;MemoFooter&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优化后 控制台打印情况为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer挂载</span><br><span class="line">&#x2F;&#x2F; 5s后</span><br><span class="line">header挂载</span><br></pre></td></tr></table></figure>



<h4 id="12-不要在render中更改应用程序的状态"><a href="#12-不要在render中更改应用程序的状态" class="headerlink" title="12. 不要在render中更改应用程序的状态"></a>12. 不要在render中更改应用程序的状态</h4><p><strong>render</strong>中继续使用 更改程序状态，就会发生 <strong>render</strong> 方法无限调用导致程序崩溃</p>
<p>render中</p>
<ul>
<li>不要使用 <strong>setState</strong></li>
<li>不要通过其他手段查询更改原生 <strong>DOM</strong> 元素</li>
</ul>
<h4 id="13-为组件创建错误边界"><a href="#13-为组件创建错误边界" class="headerlink" title="13. 为组件创建错误边界"></a>13. 为组件创建错误边界</h4><p>默认情况下组件错误会导致整个应用程序中断，创建错误便捷确保在特定组建发生错误时程序不会中断</p>
<p>错误边界可以捕获子组件在渲染时发生的错误，当错误发生时，将错误记录下来，并可以显示备用UI界面</p>
<p>错误边界涉及两个生命周期函数</p>
<ul>
<li>getDerivedStateFromError， 静态方法，返回一个对象，该对象会和state进行合并，用于更改应用程序状态 </li>
<li>componentDidCatch，用于记录应用程序错误信息，该方法的参数就是错误对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Child() &#123;</span><br><span class="line">	throw new Error(&#39;Child 内部渲染出 错了&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		super(props);</span><br><span class="line">		this.state &#x3D;&#123;</span><br><span class="line">			error: false</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	componentDidCatch(e) &#123;</span><br><span class="line">		console.log(e.message, &#39;发送请求服务器记录错误日志&#39;)</span><br><span class="line">	&#125;</span><br><span class="line">	static getDerivedStateFromError(e) &#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			error: e</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	render() &#123;</span><br><span class="line">		const &#123;error&#125; &#x3D; this.state;</span><br><span class="line">		return error ? &lt;&gt;阿偶，出错了: &#123;error.message&#125;&lt;&#x2F;&gt; : &lt;Child&#x2F;&gt; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<strong>App</strong>组件渲染后，由于<strong>Child</strong>内部错误，<strong>App</strong>中会捕获到<strong>Child</strong>中的异常，调用 <strong>componentDidCatch</strong> 中的方法，并渲染错误替代界面。</p>
<p>由于是开发模式并使用了<strong>create-react-app</strong>，会看到这个界面，</p>
<img src="/2021/01/20/react-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20210121112546301.png" class="">
<p><img src="./react-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20210121112546301.png" alt="image-20210121112546301"></p>
<p>生产环境下，可以直接看到替代界面</p>
<img src="/2021/01/20/react-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20210121112833454.png" class="">
<p><img src="./react-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20210121112833454.png" alt="image-20210121112833454"></p>
<h4 id="14-避免数据结构突变"><a href="#14-避免数据结构突变" class="headerlink" title="14. 避免数据结构突变"></a>14. 避免数据结构突变</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.state &#x3D; &#123;</span><br><span class="line">	name: &#39;along&#39;,</span><br><span class="line">	age: 12,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render () &#123;</span><br><span class="line">	return &lt;div&gt;</span><br><span class="line">		&#123;this.state.name&#125;</span><br><span class="line">		&#123;this.state.age&#125;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="15-为列表数据添加唯一标识key"><a href="#15-为列表数据添加唯一标识key" class="headerlink" title="15. 为列表数据添加唯一标识key"></a>15. 为列表数据添加唯一标识key</h4><p>添加唯一标识来优化遍历节点的<strong>diff</strong>性能,这有利于<strong>react</strong>内部优化</p>
<h4 id="16-节流和防抖"><a href="#16-节流和防抖" class="headerlink" title="16. 节流和防抖"></a>16. 节流和防抖</h4><p>节流限制频率，防抖限制连续</p>
<p>react中的一些场景如果没有进行节流防抖会导致多次的无效的render</p>
<p>节流</p>
<ul>
<li>下拉加载</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!canRun) <span class="keyword">return</span>;</span><br><span class="line">		canRun = <span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, ...arguments);</span><br><span class="line">			canRun = <span class="literal">true</span>;</span><br><span class="line">		&#125;, time)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>防抖， 只在一段操作的最后执行操作</p>
<ul>
<li>关键字提示</li>
<li>wendow.onResize, </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">clearInterval</span>(timer);</span><br><span class="line">		<span class="built_in">setTimeout</span>(fn, time);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-外部使用-CDN-加载"><a href="#17-外部使用-CDN-加载" class="headerlink" title="17. 外部使用 CDN 加载"></a>17. 外部使用 CDN 加载</h4><p>内容交付网络 （CDN）, 指得是地理上分散的服务器组，他们提供网络内容的快速交付</p>
<p>好处</p>
<ul>
<li>突破浏览器对同一域下并发请求的数量限制，可以将不同的资源放到不同的CDN中</li>
<li>当你向CDN发送请求是，会通过理你最近的数据中心进行相应，减少延迟</li>
<li>多个网站引用的相同资源会有缓存，比如之前网站缓存了 <strong>jquery</strong></li>
</ul>
<h4 id="18-依赖优化"><a href="#18-依赖优化" class="headerlink" title="18. 依赖优化"></a>18. 依赖优化</h4><p>项目中以来的第三方包，但是没有使用包中的所有代码，可以通过插件对以来进行优化，比如<strong>antd</strong>的按需引入</p>
<h4 id="19-长列表优化（虚拟列表）"><a href="#19-长列表优化（虚拟列表）" class="headerlink" title="19. 长列表优化（虚拟列表）"></a>19. 长列表优化（虚拟列表）</h4><p>在渲染大数据量的列表时，如果一层行全部渲染会感到明显的卡顿。</p>
<p>此时我们可以 通过 <strong>可视区渲染</strong> 来提升性能，即只渲染页面可视区域及附近的列表项，在滚动列表时动态更新列表项 </p>
<p>在<strong>react</strong>中可以借助<strong>react-virtualized</strong> 来进行 <strong>可视区渲染</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于渲染每一行的内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rowRenderer</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">	key,         <span class="regexp">//</span> <span class="regexp">//</span> 唯一key，这个是组件帮我们生成的</span></span></span><br><span class="line"><span class="function"><span class="params">	index,       <span class="regexp">//</span> 索引号</span></span></span><br><span class="line"><span class="function"><span class="params">	isScrolling, <span class="regexp">//</span> 当前项是否正在滚动中</span></span></span><br><span class="line"><span class="function"><span class="params">	isVisible,   <span class="regexp">//</span> 当前项在List中是否可见的</span></span></span><br><span class="line"><span class="function"><span class="params">	style        <span class="regexp">//</span> 给每一个行数添加该样式,包含了定位信息</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		&lt;div</span><br><span class="line">			key=&#123;key&#125;</span><br><span class="line">			style=&#123;style&#125;</span><br><span class="line">		&gt;</span><br><span class="line">			&#123;list[index]&#125;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">const</span> list = [...]; <span class="comment">// 一个大数据列表</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">List</span></span></span></span><br><span class="line"><span class="xml">			// 组件的宽度</span></span><br><span class="line"><span class="xml">			width=&#123;300&#125;</span></span><br><span class="line"><span class="xml">			// 组件的高度</span></span><br><span class="line"><span class="xml">			height=&#123;50&#125;</span></span><br><span class="line"><span class="xml">			rowCount=&#123;list.length&#125;</span></span><br><span class="line"><span class="xml">			// 每行的高度</span></span><br><span class="line"><span class="xml">			rowHeight=&#123;20&#125;</span></span><br><span class="line"><span class="xml">			rowRenderer=&#123;rowRenderer&#125;</span></span><br><span class="line"><span class="xml">		/&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>react</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router原理</title>
    <url>/2020/08/27/vue-router%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="vue-router-原理"><a href="#vue-router-原理" class="headerlink" title="vue-router 原理"></a>vue-router 原理</h2><p>模拟实现一个<code>vue-router</code>,详见 <a href="https://github.com/alongithub/vue-router-source/blob/master/src/vuerouter/index.js">vuerouter/index.js</a></p>
<p>借助vuecli 搭建一个vue-router项目，替换掉VueRouter部分为我们自定义的类，目前实现的功能</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> history 模式</li>
<li><input checked="" disabled="" type="checkbox"> hash 模式</li>
<li><input checked="" disabled="" type="checkbox"> router-view</li>
<li><input checked="" disabled="" type="checkbox"> router-link</li>
</ul>
<h3 id="vue-router-结构"><a href="#vue-router-结构" class="headerlink" title="vue-router 结构"></a>vue-router 结构</h3><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><table>
<thead>
<tr>
<th>VueRouter</th>
</tr>
</thead>
<tbody><tr>
<td>+ options <br/> + data <br/> + routeMap</td>
</tr>
<tr>
<td>+ Constructor(Options):VueRouter <br/> _ install(Vue): void <br/> + init(): void <br/> + initEvent(): void <br/> + createRouteMap(): void <br/> + initComponents(Vue): void</td>
</tr>
</tbody></table>
<ul>
<li><p><code>options</code> 记录构造函数中的对象</p>
</li>
<li><p><code>data</code> 响应式对象</p>
<ul>
<li><code>current</code> 记录当前路由地址</li>
</ul>
</li>
<li><p><code>routeMap</code> 记录路由和组件的对应关系 </p>
</li>
<li><p><code>install</code> 静态方法实现<code>vue</code>插件</p>
</li>
<li><p><code>initEvent</code> 监听浏览器地址变化</p>
</li>
<li><p><code>createRouteMap</code> 出事话<code>routeMap</code> 属性，把构造函数的路由规则转换成键值对存在routeMap中</p>
</li>
<li><p><code>initComponents</code> 创建<code>router-link</code>和<code>router-view</code>两个组件</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 响应式原理</title>
    <url>/2020/10/27/vue3-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isObject = <span class="function"><span class="params">val</span> =&gt;</span> val !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于判断目标是否是对象，是对象进行代理</span></span><br><span class="line"><span class="keyword">const</span> convert = <span class="function"><span class="params">target</span> =&gt;</span> isObject(target) ? reactive(target) : target;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断对象本身是否有目标属性</span></span><br><span class="line"><span class="keyword">const</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty</span><br><span class="line"><span class="keyword">const</span> hasOwn = <span class="function">(<span class="params">target, key</span>) =&gt;</span> hasOwnProperty.call(target, key);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><ul>
<li>接收一个参数， 判断是否是对象</li>
<li>创建拦截器对象handler，设置get/set/deleteProperty<ul>
<li>get 中调用track收集依赖</li>
<li>set/deleteProperty 中调用trigger触发更新</li>
</ul>
</li>
<li>返回Proxy对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * reactive函数接收target参数，将其代理成响应式对象并返回响应式对象</span></span><br><span class="line"><span class="comment"> * reactive只能处理对象和数组，不能处理原始数据类型</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(target)) <span class="keyword">return</span> target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handler = &#123;</span><br><span class="line">        get(target, key, receiver) &#123;</span><br><span class="line">            <span class="comment">// 收集依赖</span></span><br><span class="line">            track(target, key);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">            <span class="comment">// 如果是对象，代理然后返回</span></span><br><span class="line">            <span class="comment">// 在访问的时候才会对深层的对象进行代理，惰性代理，提升性能</span></span><br><span class="line">            <span class="keyword">return</span> convert(result);</span><br><span class="line">        &#125;,</span><br><span class="line">        set(target, key, value, receiver) &#123;</span><br><span class="line">            <span class="keyword">const</span> oldValue = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">            <span class="comment">// 默认返回true，oldvalue等于value时返回true，但不触发更新</span></span><br><span class="line">            <span class="keyword">let</span> result = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (oldValue !== value) &#123;</span><br><span class="line">                result = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 触发更新</span></span><br><span class="line">                trigger(target, key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;,</span><br><span class="line">        deleteProperty(target, key) &#123;</span><br><span class="line">            <span class="keyword">const</span> haskey = hasOwn(target, key);</span><br><span class="line">            <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.deleteProperty(target, key);</span><br><span class="line">            <span class="keyword">if</span> (haskey &amp;&amp; result) &#123;</span><br><span class="line">                <span class="comment">// 触发更新</span></span><br><span class="line">                trigger(target, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h3><ul>
<li>effect函数接收一个函数</li>
<li>effect首先在全局缓存接收到的参数callback</li>
<li>执行callback函数，在这个函数中由于读取了响应式数据，会触发handler中get中的track函数，收集依赖</li>
<li>依赖收集完成后，清除全局缓存的callback引用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * effect函数接收一个函数，这个函数会在第一次和依赖的响应式对象发生变化时执行</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    activeEffect = callback;</span><br><span class="line">    callback(); <span class="comment">// callback会收集响应式对象属性，此时可以来收集依赖</span></span><br><span class="line">    activeEffect = <span class="literal">null</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="track"><a href="#track" class="headerlink" title="track"></a>track</h3><ul>
<li>track 函数用于收集依赖，接收响应式对象和属性名</li>
<li>在上方的effect中，在全局缓存了一个activeEffect,方便track能访问，当执行到callback()时，会访问相应对象的属性，相应对象handler方法的get方法中会首先调用track收集依赖。track方法只在activeEffect有值时继续执行，所以在effect调用时访问响应式属性才会真正进入track方法收集依赖。也就是effect方法调用时的回调函数第一次执行时才会收集依赖</li>
<li>track函数外部会声明一个targetMap,用于保存响应式对象的所有被依赖属性和回调函数的集合。targetMap 结构实例  {target:{key1: <a href="Set">cb1, cb2</a>, key2: <a href="Set">cb</a>}(Map)}(WeakMap)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * track 函数用于收集依赖</span></span><br><span class="line"><span class="comment"> * 在上方的effect中，在全局缓存了一个activeEffect,方便track能访问</span></span><br><span class="line"><span class="comment"> * 当执行到callback()时，会访问相应对象的属性，相应对象handler方法的get方法中会首先调用track收集依赖。</span></span><br><span class="line"><span class="comment"> * track方法只在activeEffect有值时继续执行，所以在effect调用时访问响应式属性才会真正进入track方法收集依赖。也就是effect方法调用时的回调函数第一次执行时才会收集依赖</span></span><br><span class="line"><span class="comment"> * track函数外部会声明一个targetMap,用户保存响应式对象的所有被依赖属性和回调函数的集合。targetMap 结构实例  &#123;target:&#123;key1: [cb1, cb2](Set), key2: [cb](Set)&#125;(Map)&#125;(WeakMap)</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">let</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!activeEffect) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.get(target);</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">        targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dep = depsMap.get(key);</span><br><span class="line">    <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">        depsMap.set(key, (dep = <span class="keyword">new</span> <span class="built_in">Set</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">    dep.add(activeEffect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h3><ul>
<li>trigger函数用于触发更新，接收响应式对象和属性名</li>
<li>通过响应式对象和属性名从targetMap取出所有的回调函数。依次执行处罚更新</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * trigger函数用于触发更新,查找这个属性是否有对应的回调函数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> depsMap = targetMap.get(target);</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> dep = depsMap.get(key);</span><br><span class="line">    <span class="keyword">if</span> (dep) &#123;</span><br><span class="line">        dep.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">            effect()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul>
<li>ref 用于将一个变量处理成响应式，可以用于处理基础数据类型或者对象</li>
<li>返回一个带有__v_isRef标识的对象，并将参数处理成响应式（如果是基本数据类型直接保存到value中）保存到返回对象的value中，value通过getter/setter拦截。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ref 用于将一个变量处理成响应式，可以用于处理基础数据类型或者对象</span></span><br><span class="line"><span class="comment"> * 最终返回一个对象r，如果r的value在effct中被访问，会注册依赖</span></span><br><span class="line"><span class="comment"> * 同样，r的value被修改时，也会触发回调</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * ref可以把基本数据类型数据转换成响应式数据，可以通过value属性访问，模板中使用可以省略.value</span></span><br><span class="line"><span class="comment"> * ref返回的对象，重新复制成对象也是响应式的</span></span><br><span class="line"><span class="comment"> * reactive返回的的对象，重新复制丢失响应式</span></span><br><span class="line"><span class="comment"> * reactive返回的对象不可以解构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">raw</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否是ref创建的对象，是直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isObject(raw) &amp;&amp; raw.__v_isRef) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是对象，是的话转换成响应式对象，否则返回raw</span></span><br><span class="line">    <span class="keyword">let</span> value = convert(raw);</span><br><span class="line">    <span class="keyword">const</span> r = &#123;</span><br><span class="line">        __v_isRef: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">            track(r, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue !== value) &#123;</span><br><span class="line">                raw = newValue;</span><br><span class="line">                value = convert(raw);</span><br><span class="line">                trigger(r, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><ul>
<li>toRefs 接收一个 reactive返回的响应式对象，将该对象的所有属性通过ref函数处理返回，并返回一个包装对象</li>
<li>通过这种方式返回的对象，解构之后仍然是响应式</li>
<li>其实就是利用了结构赋值时引用传递的原理</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toRefs 接收一个 reactive返回的响应式对象，将该对象的所有属性处理成ref</span></span><br><span class="line"><span class="comment"> * 返回的格式（将值包装到value中），并返回一个包装对象，</span></span><br><span class="line"><span class="comment"> * 通过这种方式返回的对象，解构之后仍然是响应式</span></span><br><span class="line"><span class="comment"> * 其实就是利用了赋值时引用传递的原理</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toRefs</span>(<span class="params">proxy</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = proxy <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? <span class="keyword">new</span> <span class="built_in">Array</span>(proxy.length) : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> proxy) &#123;</span><br><span class="line">        ret[key] = toProxyRef(proxy, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toRefs 内部调用的函数，用于将一个响应式的属性值处理成响应式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toProxyRef</span> (<span class="params">proxy, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> r = &#123;</span><br><span class="line">        __v_isRef: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> proxy[key];</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">            proxy[key] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><ul>
<li>computed 是effect包装，接收一个函数getter， 返回一个响应式的对象（计算属性）</li>
<li>内部调用effect，收集依赖，当依赖的响应式对象改变时，会触发getter修改返回的响应式对象的值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * computed 是effect包装，返回一个响应式的对象（计算属性）</span></span><br><span class="line"><span class="comment"> * 当依赖数据改变时，会修改返回的响应式对象的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">computed</span> (<span class="params">getter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = ref(); <span class="comment">// 创建一个空的ref，不在effectn内部创建为了保持对象是同一引用</span></span><br><span class="line"></span><br><span class="line">    effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        result.value = getter();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vue源码</tag>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>vue全家桶+ts+eslint项目搭建</title>
    <url>/2020/10/29/vue%E5%85%A8%E5%AE%B6%E6%A1%B6-ts-eslint%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="安装脚手架工具"><a href="#安装脚手架工具" class="headerlink" title="安装脚手架工具"></a>安装脚手架工具</h3><p>安装@vue-cli</p>
<p>我这里用的是@vue-cli v4.5.8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @vue-cli -g</span><br></pre></td></tr></table></figure>


<h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue create boss</span><br></pre></td></tr></table></figure>


<p>选择一个预设，这里选第三个手动配置选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? Please pick a preset:</span><br><span class="line">  Default ([Vue 2] babel, eslint)</span><br><span class="line">  Default (Vue 3 Preview) ([Vue 3] babel, eslint)</span><br><span class="line">&gt; Manually select features  手动配置选项  </span><br></pre></td></tr></table></figure>

<p>选择需要的功能到项目中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? Check the features needed for your project:</span><br><span class="line"> ( ) Choose Vue version  选择vue版本不勾选默认vue2</span><br><span class="line"> (*) Babel</span><br><span class="line"> (*) TypeScript</span><br><span class="line"> ( ) Progressive Web App (PWA) Support</span><br><span class="line"> (*) Router</span><br><span class="line"> (*) Vuex</span><br><span class="line"> (*) CSS Pre-processors</span><br><span class="line">&gt;(*) Linter &#x2F; Formatter</span><br><span class="line"> ( ) Unit Testing</span><br><span class="line"> ( ) E2E Testing   </span><br></pre></td></tr></table></figure>

<p>是否使用 class 风格，建议勾选</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Use class-style component syntax? (Y&#x2F;n) y  </span><br></pre></td></tr></table></figure>

<p>手否使用ts只编译类型相关部分，babel编译常规js部分，建议勾选</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? (Y&#x2F;n) y</span><br></pre></td></tr></table></figure>

<p>是否使用history模式，这里建议no,history更美观但是兼容性比hash模式差一些</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Use history mode for router? (Requires proper server setup for index fallback in production) (Y&#x2F;n) n </span><br></pre></td></tr></table></figure>

<p>选择css预处理器，如果使用sass建议选择第一项，dart-sass性能更好,这个根据个人需要选择</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): (Use arrow keys)</span><br><span class="line">&gt; Sass&#x2F;SCSS (with dart-sass)</span><br><span class="line">  Sass&#x2F;SCSS (with node-sass)</span><br><span class="line">  Less</span><br><span class="line">  Stylus  </span><br></pre></td></tr></table></figure>

<p>选择代码校验规则,我这里选用Standard代码风格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pick a linter &#x2F; formatter config:</span><br><span class="line">  ESLint with error prevention only</span><br><span class="line">  ESLint + Airbnb config</span><br><span class="line">&gt; ESLint + Standard config</span><br><span class="line">  ESLint + Prettier</span><br><span class="line">  TSLint (deprecated) </span><br></pre></td></tr></table></figure>

<p>选择触发代码校验的时机,第一项是在保存代码时，第二项是自动修正和代码提交时，这里全选</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Pick additional lint features:</span><br><span class="line"> (*) Lint on save</span><br><span class="line">&gt;(*) Lint and fix on commit </span><br></pre></td></tr></table></figure>

<p>babel,eslint,配置信息单独存放到自己的配置文件中，方便以后的修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys)</span><br><span class="line">&gt; In dedicated config files</span><br><span class="line">  In package.json   </span><br></pre></td></tr></table></figure>

<p>是否保存当前配置方便下次快速生成项目，这里不需要</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Save this as a preset for future projects? (y&#x2F;N) n</span><br></pre></td></tr></table></figure>

<p>接下来会开始安装依赖和创建项目</p>
<h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><p>进入项目并启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<h2 id="初始化文件调整"><a href="#初始化文件调整" class="headerlink" title="初始化文件调整"></a>初始化文件调整</h2><h3 id="scr-app-vue"><a href="#scr-app-vue" class="headerlink" title="scr/app.vue"></a>scr/app.vue</h3><p>删除不必要的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=<span class="string">&quot;scss&quot;</span>&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="src-router-index-ts"><a href="#src-router-index-ts" class="headerlink" title="src/router/index.ts"></a>src/router/index.ts</h3><p>清空路由规则</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter, &#123; RouteConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: <span class="built_in">Array</span>&lt;RouteConfig&gt; = [</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<h3 id="src-views-src-components-src-assets"><a href="#src-views-src-components-src-assets" class="headerlink" title="src/views, src/components, src/assets"></a>src/views, src/components, src/assets</h3><p>删除目录下的文件</p>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>src/utils 工具模块</p>
<p>src/styles 全局相关样式</p>
<p>src/services 存储接口API函数</p>
<h2 id="使用TS"><a href="#使用TS" class="headerlink" title="使用TS"></a>使用TS</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>如果项目在vuecli初始创建时没有选用Ts,可以使用 @vue/cli 安装 TypeScript 插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue add @vue&#x2F;typescript</span><br></pre></td></tr></table></figure>

<h3 id="开始类型推断的用法"><a href="#开始类型推断的用法" class="headerlink" title="开始类型推断的用法"></a>开始类型推断的用法</h3><p>Options Api 不会提供类型提示，如果需要使用类型推断，需要使用 extend、component或者class 写法</p>
<p>要想提供ts支持，需要在script标签添加lang=”ts”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>要让 TypeScript 正确推断 Vue 组件选项中的类型，您需要使用 Vue.component 或 Vue.extend 定义组件：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> Component = Vue.extend(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 类型推断已启用</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> Component = &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这里不会有类型推断，</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 因为 TypeScript 不能确认这是 Vue 组件的选项</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果您在声明组件时更喜欢基于类的 API，则可以使用官方维护的 vue-class-component 装饰器：</p>
</blockquote>
<ul>
<li>引入装饰器Component</li>
<li>通过@Component包装导出的类</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// @Component 修饰符注明了此类为一个 Vue 组件</span></span></span><br><span class="line">    @Component(&#123;</span><br><span class="line"><span class="javascript">    <span class="comment">// 所有的组件选项都可以放在这里</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &#x27;<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>Click!<span class="tag">&lt;/<span class="name">button</span>&gt;</span>&#x27;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 初始数据可以直接声明为实例的 property</span></span></span><br><span class="line"><span class="javascript">    message: string = <span class="string">&#x27;Hello!&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 组件方法也可以直接声明为实例的方法</span></span></span><br><span class="line"><span class="javascript">    onClick (): <span class="keyword">void</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.alert(<span class="built_in">this</span>.message)</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用ESLINT"><a href="#使用ESLINT" class="headerlink" title="使用ESLINT"></a>使用ESLINT</h2><p>自定义规范</p>
<p>.eslintrc.js中可以自定义规则</p>
<p>我这里追加了规则</p>
<img src="/2020/10/29/vue%E5%85%A8%E5%AE%B6%E6%A1%B6-ts-eslint%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/1.png" class="">

<p><a href="https://eslint.bootcss.com/docs/rules/">更多规则参照这里</a><br><a href="https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/eslint-plugin">Ts相关规则参照这里</a><br><a href="https://eslint.vuejs.org/rules/">Vue相关规则参照这里</a></p>
<p>可以根据团队和个人喜好自行配置，修改.eslintrc.js需要重启服务，如果重启不生效手动删除node_modules/.cache再启动</p>
<p>*有时候一些配置会与vscode默认的格式化格式不一致，此时需要修改vscode的配置，或者修改eslint配合</p>
<p>比如这里我用的规则设置了tab缩进，但是当使用vscode的alt+shift+f自动格式化时，vscode会将缩进替换成空格</p>
<p>此时可以打开设置，搜索indent，找到Vetur › Format › Options: Use Tabs项，选中</p>
<img src="/2020/10/29/vue%E5%85%A8%E5%AE%B6%E6%A1%B6-ts-eslint%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/altf.png" class="">

<h2 id="Element-UI-组件库"><a href="#Element-UI-组件库" class="headerlink" title="Element UI 组件库"></a>Element UI 组件库</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></table></figure>

<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>引入方式可以全部引入也可按需引入，这里我配置完整引入，按需引入方式参照<a href="https://element.eleme.cn/#/zh-CN/component/quickstart">这里</a></p>
<p>在 main.js 中写入以下内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI);</span><br></pre></td></tr></table></figure>

<h2 id="style-样式"><a href="#style-样式" class="headerlink" title="style 样式"></a>style 样式</h2><h3 id="style文件夹"><a href="#style文件夹" class="headerlink" title="style文件夹"></a>style文件夹</h3><blockquote>
<p>src/styles<br>├── index.scss # 全局样式（在入口模块被加载生效），引入其他样式文件（比如下方的样式文件以及element的样式等）并在main中引入<br>├── mixin.scss # 公共的 mixin 混入（可以把重复的样式封装为 mixin 混入到复用的地方）<br>├── reset.scss # 重置基础样式<br>└── variables.scss # 公共样式变量</p>
</blockquote>
<h3 id="全局样式变量"><a href="#全局样式变量" class="headerlink" title="全局样式变量"></a>全局样式变量</h3><p>比如我在 variables.scss中定义样式变量</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$primary-color</span>: <span class="number">#40586F</span>; </span><br><span class="line"><span class="variable">$success-color</span>: <span class="number">#51cf66</span>; </span><br><span class="line"><span class="variable">$warning-color</span>: <span class="number">#fcc419</span>; </span><br><span class="line"><span class="variable">$danger-color</span>: <span class="number">#ff6b6b</span>; </span><br><span class="line"><span class="variable">$info-color</span>: <span class="number">#868e96</span>; <span class="comment">// #22b8cf; </span></span><br><span class="line"><span class="variable">$body-bg</span>: <span class="number">#E9EEF3</span>; <span class="comment">// #f5f5f9; </span></span><br><span class="line"><span class="variable">$sidebar-bg</span>: <span class="number">#F8F9FB</span>; </span><br><span class="line"><span class="variable">$navbar-bg</span>: <span class="number">#F8F9FB</span>; </span><br><span class="line"><span class="variable">$font-family</span>: system-ui, -apple-system, <span class="string">&quot;Segoe UI&quot;</span>, Roboto, Helvetica, Arial, sans-serif;</span><br></pre></td></tr></table></figure>

<p>创建 vue.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    css: &#123;</span><br><span class="line">        loaderOptions: &#123;</span><br><span class="line">            scss: &#123;</span><br><span class="line">                <span class="comment">// scss 加载是自动注入这行代码</span></span><br><span class="line">                prependData: <span class="string">&#x27;@import &quot;~@/styles/variables.scss&quot;;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改vue.config.js需要重启项目</p>
<p>之后再任意文件中就可以使用variables中的样式变量了</p>
<p>比如我在App.vue中直接使用样式变量，而不需要引入变量所在的文件</p>
<img src="/2020/10/29/vue%E5%85%A8%E5%AE%B6%E6%A1%B6-ts-eslint%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/scss.png" class="">

<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>开发过程中用于代理后台接口，处理跨域问题</p>
<p>通过配置vue.config.js来处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">&#x27;/front&#x27;</span>: &#123;</span><br><span class="line">                target: <span class="string">&#x27;http://a.com&#x27;</span>,</span><br><span class="line">                <span class="comment">// ws: true, // 意思是转发websorket</span></span><br><span class="line">                changeOrigin: <span class="literal">true</span> <span class="comment">// 设置请求头中的 host 为 target，防止后端反向代理服务器无法 识别 </span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&#x27;/user&#x27;</span>: &#123;</span><br><span class="line">                target: <span class="string">&#x27;http://b.com&#x27;</span>,</span><br><span class="line">                changeOrigin: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="请求模块封装"><a href="#请求模块封装" class="headerlink" title="请求模块封装"></a>请求模块封装</h2><p>安装axios</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install axios -S</span><br></pre></td></tr></table></figure>

<p>src/utils/request.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> request = axios.create(&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> request;</span><br></pre></td></tr></table></figure>

<p>// 待补充</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="创建文件目录"><a href="#创建文件目录" class="headerlink" title="创建文件目录"></a>创建文件目录</h3><p>在src/views中创建文件</p>
<p>src/views/home/index.vue 主页<br>src/views/user/index.vue 用户管理<br>src/views/role/index.vue 角色管理<br>src/views/login/index.vue 登录界面<br>src/views/error-page/404.vue 404界面</p>
<h3 id="配置路由规则"><a href="#配置路由规则" class="headerlink" title="配置路由规则"></a>配置路由规则</h3><p>src/router/index.ts</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes: <span class="built_in">Array</span>&lt;RouteConfig&gt; = [</span><br><span class="line">	&#123;</span><br><span class="line">		path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">		name: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">		<span class="comment">// 懒加载模块，单独打包，webpackChunkName 可以手动配置打包后的文件名字，方便调试</span></span><br><span class="line">		component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;home&#x27; */</span> <span class="string">&#x27;@/views/home/index.vue&#x27;</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		path: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">		name: <span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">		component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;login&#x27; */</span> <span class="string">&#x27;@/views/login/index.vue&#x27;</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		path: <span class="string">&#x27;/role&#x27;</span>,</span><br><span class="line">		name: <span class="string">&#x27;role&#x27;</span>,</span><br><span class="line">		component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;role&#x27; */</span> <span class="string">&#x27;@/views/role/index.vue&#x27;</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		path: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line">		name: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">		component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;user&#x27; */</span> <span class="string">&#x27;@/views/user/index.vue&#x27;</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		path: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">		name: <span class="string">&#x27;404&#x27;</span>,</span><br><span class="line">		component: <span class="function">() =&gt;</span> <span class="keyword">import</span>((<span class="comment">/* webpackChunkName: &#x27;404&#x27; */</span> <span class="string">&#x27;@/views/error-page/404.vue&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h2 id="界面布局"><a href="#界面布局" class="headerlink" title="界面布局"></a>界面布局</h2>]]></content>
      <tags>
        <tag>vue项目</tag>
      </tags>
  </entry>
  <entry>
    <title>vue响应式原理</title>
    <url>/2020/08/27/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="VUE-响应式原理"><a href="#VUE-响应式原理" class="headerlink" title="VUE 响应式原理"></a>VUE 响应式原理</h2><h3 id="数据响应式原理"><a href="#数据响应式原理" class="headerlink" title="数据响应式原理"></a>数据响应式原理</h3><p>Vue 2.x</p>
<blockquote>
<p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
</blockquote>
<p>defineProperty 代码示例，详见 <a href="./test/defineproperty.html">defineProty示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    msg: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据劫持</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">&#x27;msg&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 可枚举</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 可配置(可以使用delete删除)</span></span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    get() &#123;</span><br><span class="line">        <span class="comment">// 需要用一个新的字段保存实际的msg值，因为在get中如果访问msg会导致重复触发getter</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get:&#x27;</span>, data._msg);</span><br><span class="line">        <span class="keyword">return</span> data._msg;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    set(newValue) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;set:&#x27;</span>, newValue);</span><br><span class="line">        <span class="keyword">if</span> (newValue === data._msg) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data._msg = newValue;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>).textContent = data._msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">data.msg = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data.msg);</span><br></pre></td></tr></table></figure>

<p>Vue 3.x</p>
<p>Proxy 代码示例， 详见 <a href="./test/proxy.html">Proxy示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    msg: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">    get (target, key) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get, key: &#x27;</span>, key, target[key]);</span><br><span class="line">        <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, key, newValue) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;set, key:&#x27;</span>, key, newValue);</span><br><span class="line">        <span class="keyword">if</span> (target[key] === newValue) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        target[key] = newValue;</span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>).textContent = target[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">vm.msg = <span class="string">&#x27;along&#x27;</span>;</span><br><span class="line"></span><br><span class="line">vm.count = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<h3 id="发布订阅模式-与-观察者模式"><a href="#发布订阅模式-与-观察者模式" class="headerlink" title="发布订阅模式 与 观察者模式"></a>发布订阅模式 与 观察者模式</h3><p>发布订阅模式</p>
<p>vue和node事件基于发布订阅模式</p>
<p>vue 自定义事件示例,实现兄弟组件间的通讯</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eventBus.js 事件中心</span></span><br><span class="line"><span class="keyword">let</span> eventBus = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册两个事件，A、B 在created生命周期中注册两个订阅者，C 发布事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A,vue </span></span><br><span class="line">created() &#123;</span><br><span class="line">    eventBus.$on(<span class="string">&#x27;datachange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;datachange, then 1&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B.vue</span></span><br><span class="line">created() &#123;</span><br><span class="line">    eventBus.$on(<span class="string">&#x27;datachange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;datachange, then 2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C.vue</span></span><br><span class="line"><span class="comment">// 触发事件，发布者</span></span><br><span class="line">methods: &#123;</span><br><span class="line">    onDataChange() &#123;</span><br><span class="line">        eventBus.$emit(<span class="string">&#x27;datachange&#x27;</span>, &#123;<span class="attr">text</span>: <span class="string">&#x27;along&#x27;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟实现 事件中心 详见 <a href="./test/eventemitter.html">eventemitter</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件触发器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.subs = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $on(eventType, handler) &#123;</span><br><span class="line">        <span class="comment">// 如果没有注册过该事件，设置该事件为空数组</span></span><br><span class="line">        <span class="built_in">this</span>.subs[eventType] = <span class="built_in">this</span>.subs[eventType] || [];</span><br><span class="line">        <span class="built_in">this</span>.subs[eventType].push(handler);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    $emit(eventType) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.subs[eventType]) &#123;</span><br><span class="line">            <span class="built_in">this</span>.subs[eventType].forEach(<span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">                handler(); </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> em = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">em.$on(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click then 1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">em.$on(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click then 2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">em.$emit(<span class="string">&#x27;click&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>观察者模式</p>
<p>vue响应式机制使用了观察者模式</p>
<p>观察者模式没有事件中心，只有发布者和订阅者，发布者需要知道订阅者的存在</p>
<ul>
<li>观察者模式中，订阅者称为观察者，Watcher<ul>
<li>update(), 观察者需要实现update方法，定义事件发生时具体要做的事情</li>
</ul>
</li>
<li>发布者，Dep<ul>
<li>subs: 存储观察者的数组</li>
<li>addSub(): 注册添加观察者</li>
<li>notify(): 事件发生时，通知所有的观察者update()方法</li>
</ul>
</li>
</ul>
<p>观察者模式代码示例，详见<a href="./test/depwatcher.html"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 发布者</span><br><span class="line">class Dep &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        &#x2F;&#x2F; 记录所有的订阅者</span><br><span class="line">        this.subs &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addSub(sub) &#123;</span><br><span class="line">        if (sub &amp;&amp; sub.update) &#123;</span><br><span class="line">            this.subs.push(sub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notify() &#123;</span><br><span class="line">        this.subs.forEach(sub &#x3D;&gt; &#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 订阅者</span><br><span class="line">class Watcher &#123;</span><br><span class="line">    update() &#123;</span><br><span class="line">        console.log(&#39;update&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; test</span><br><span class="line">let dep &#x3D; new Dep();</span><br><span class="line">let watcher &#x3D; new Watcher();</span><br><span class="line"></span><br><span class="line">dep.addSub(watcher);</span><br><span class="line"></span><br><span class="line">dep.notify();</span><br></pre></td></tr></table></figure>

<p>观察者模式和发布订阅模式的区别</p>
<ul>
<li>观察者模式由具体目标调度，当时间触发，Dep就会调用观察者的方法，观察者和发布者之间存在依赖关系</li>
<li>发布/订阅模式由事件中心调度，发布者和订阅者不需要知道对方的存在</li>
</ul>
<p><img src="./readmeimg/diffofwatcher.png"></p>
<h3 id="vue-响应式原理总览"><a href="#vue-响应式原理总览" class="headerlink" title="vue 响应式原理总览"></a>vue 响应式原理总览</h3><p><img src="./readmeimg/vue.png"></p>
<h4 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h4><ul>
<li>负责接收初始化参数</li>
<li>负责把data中的属性注入到Vue中，转换为getter/setter</li>
<li>负责调用Observer监听data中属性的变换</li>
<li>负责调用Compiler解析指令/差值表达式</li>
</ul>
<p>类图<br>|  VUE   |<br>|  —-  |<br>| + $options <br/> + $el <br/> + $data|<br>| - _proxyDate() | </p>
<h4 id="Observer-数据劫持"><a href="#Observer-数据劫持" class="headerlink" title="Observer 数据劫持"></a>Observer 数据劫持</h4><ul>
<li>负责把data中的数据转换成响应式数据</li>
<li>data中的某个属性是对象时，把该对象属性也转换成响应式数据</li>
<li>数据变化时发送通知</li>
</ul>
<p>类图<br>|  Observer   |<br>|  —-  |<br>| + walk() <br/> + defineReactive|</p>
<h4 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h4><ul>
<li>编译模板，解析指令差值表达式</li>
<li>负责页面的首次渲染</li>
<li>数据变化时更新视图</li>
</ul>
<p>类图<br>|  Compiler   |<br>|  —-  |<br>| + el <br/> + vm|<br>| + compile(el) <br/> + compilerElement(node) <br/> + compileText(node) <br/> + isDirective(attrName) <br> + isTextNode(node) <br/> + isElementNode(node) |</p>
<ul>
<li>compile(el) 解析节点，如果是文本节点，解析差值表达式，如果是元素节点解析指令</li>
<li>compileElement(node) 解析元素节点</li>
<li>compileText(node) 解析文本节点</li>
<li>isDirective(attrName) 判断属性是否是指令</li>
</ul>
<h4 id="Dep-Dependency"><a href="#Dep-Dependency" class="headerlink" title="Dep(Dependency)"></a>Dep(Dependency)</h4><ul>
<li>收集依赖，添加观察者</li>
<li>通知所有观察者更新数据</li>
</ul>
<p>类图<br>|  Dep   |<br>|  —-  |<br>| + subs |<br>| + addSub(sub) <br/> + notify() | </p>
<h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><ul>
<li>数据变化时dep通知所有watcher 更新视图</li>
<li>自身实例化时 注册到dep 对象中</li>
</ul>
<p>类图<br>|  Watcher   |<br>|  —-  |<br>| + vm <br/> + key <br/> + cb <br/> + oldValue |<br>| + update() | </p>
<h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><p>了解了响应式原理的几个部分，本项目简易实现一个响应式vue</p>
<p>目前实现的功能</p>
<ul>
<li><input disabled="" type="checkbox"> 差值表达式 <ul>
<li><input checked="" disabled="" type="checkbox"> 绑定值 <code>&#123;&#123;data&#125;&#125;</code></li>
<li><input disabled="" type="checkbox"> 表达式 <code>&#123;&#123;data + 1&#125;&#125;</code></li>
<li><input disabled="" type="checkbox"> …</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> 模板指令<ul>
<li><input checked="" disabled="" type="checkbox"> <code>v-text</code></li>
<li><input checked="" disabled="" type="checkbox"> <code>v-html</code></li>
<li><input checked="" disabled="" type="checkbox"> <code>v-model</code> 双向绑定</li>
<li><input disabled="" type="checkbox"> <code>v-on</code><ul>
<li><input checked="" disabled="" type="checkbox"> 绑定<code>vue</code>中的<code>methods</code> </li>
<li><input disabled="" type="checkbox"> …</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack</title>
    <url>/2020/08/27/webpack/</url>
    <content><![CDATA[<h2 id="WEBPACK"><a href="#WEBPACK" class="headerlink" title="WEBPACK"></a>WEBPACK</h2><h3 id="模块化问题"><a href="#模块化问题" class="headerlink" title="模块化问题"></a>模块化问题</h3><ul>
<li>兼容问题：  ES6 =&gt; ES5</li>
<li>模块文件多，网络请求频繁：  打包多个模块到一起</li>
<li>所有的前端资源都需要模块化：  打包不同类型文件</li>
</ul>
<h3 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h3><ul>
<li>webpack <ul>
<li>模块打包 Module bundler</li>
<li>模块加载 loader</li>
<li>代码拆分 Code Splitting</li>
<li>资源模块 Asset Module</li>
</ul>
</li>
</ul>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add webpack webpack-cli --dev</span><br></pre></td></tr></table></figure>

<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>webpack 4 支持零配置打包，可以通过index.html中引入的script找到所有相关文件并打包</p>
<p>也可以通过修改配置自定义</p>
<p>创建 webpack.config.js 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    mode: &#39;none&#39;,</span><br><span class="line">    entry: &#39;.&#x2F;src&#x2F;index.js&#39;, &#x2F;&#x2F; 相对路径不能省略 .&#x2F;</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &#39;bundle.js&#39;,</span><br><span class="line">        path: path.join(__dirname, &#39;output&#39;), &#x2F;&#x2F; 指定输出文件路径，必须是一个绝对路径</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="webpack-原理"><a href="#webpack-原理" class="headerlink" title="webpack 原理"></a>webpack 原理</h4><h4 id="webpack-资源加载-Loader"><a href="#webpack-资源加载-Loader" class="headerlink" title="webpack 资源加载 Loader"></a>webpack 资源加载 Loader</h4><p>webpack 加载资源的方式</p>
<ul>
<li><p>遵循ES Modules 标准的import声明</p>
</li>
<li><p>遵循CommonJS标准的require函数</p>
</li>
<li><p>遵循AMD标准的define函数和require函数</p>
</li>
<li><p>样式代码中的@import指令和url函数</p>
</li>
<li><p>HTML代码中图片标签的src属性</p>
</li>
</ul>
<p>loader 加载器类型大致分为三类</p>
<ul>
<li>编译转换类</li>
<li>文件操作类型  比如文件拷贝</li>
<li>代码检查类   eslint</li>
</ul>
<p>每一种资源都需要特定的加载器来加载。</p>
<p>通过webpack 配置文件中的 module.rules 来配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;test: &#x2F;.css$&#x2F;, use: &#39;css-loader&#39;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="处理css"><a href="#处理css" class="headerlink" title="处理css"></a>处理css</h5><p><code>[&#39;style-loader&#39;,&#39;css-loader&#39;]</code></p>
<h5 id="文件资源加载-图片字体"><a href="#文件资源加载-图片字体" class="headerlink" title="文件资源加载, 图片字体"></a>文件资源加载, 图片字体</h5><p><code>[&#39;file-loader&#39;]</code> file-loader 会在打包时将目标复制到输出文件夹，并将输出模块的路径作为返回值返回</p>
<p><code>[&#39;url-loader&#39;]</code> url-loader 采用Data urls 协议，（url直接表示文件内容），将文件转换成base64 直接写到代码中</p>
<p>最好的方式是较小的资源使用url-loader 转换，较大的文件使用file-loader 拷贝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    test: &#x2F;\.(png|jpg|jpeg|gif)$&#x2F;,</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: &#39;url-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">            esModule: false,</span><br><span class="line">            limit: 10 * 1024,</span><br><span class="line">            &#x2F;&#x2F; outputPath: &#39;images&#x2F;&#39;,</span><br><span class="line">            &#x2F;&#x2F; name: &#39;[name].[hash:5].[ext]&#39;,</span><br><span class="line">            &#x2F;&#x2F; publicPath: &#39;&#39;, &#x2F;&#x2F; 可以写cdn地址</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="编译-ES6"><a href="#编译-ES6" class="headerlink" title="编译 ES6"></a>编译 ES6</h5><p><code>yarn add babel-loader @babel/core @babel/preset-env --dev</code></p>
<p>配置 规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: &#x2F;\.js$&#x2F;,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader: &#39;babel-loader&#39;,</span><br><span class="line">            options: &#123;</span><br><span class="line">                presets: [&#39;@babel&#x2F;preset-env&#39;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="自定义-loader"><a href="#自定义-loader" class="headerlink" title="自定义 loader"></a>自定义 loader</h4><p>实现一个md转html的loader</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> marked = <span class="built_in">require</span>(<span class="string">&#x27;marked&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数 source 就是读取到的文件文本</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">source</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> html = marked(source);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loader管道的最后一个loader必须要分会一段js脚本文本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`module.exports = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(html)&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h4><p>通过配置webpack的plugins数组配置插件</p>
<h5 id="自动清除输出目录"><a href="#自动清除输出目录" class="headerlink" title="自动清除输出目录"></a>自动清除输出目录</h5><p>clean-webpack-plugin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123;CleanWebpackPlugin&#125; &#x3D; require(&#39;clean-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new CleanWebpackPlugin(),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自动生成html-html-webpack-plugin"><a href="#自动生成html-html-webpack-plugin" class="headerlink" title="自动生成html html-webpack-plugin"></a>自动生成html html-webpack-plugin</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const HtmlWebpakPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpakPlugin(&#123;</span><br><span class="line">            title: &#39;vue-app&#39;, </span><br><span class="line">            url: &#39;&#x2F;&#39;, &#x2F;&#x2F; 自定义参数</span><br><span class="line">            template: &#39;.&#x2F;public&#x2F;index.html&#39;, </span><br><span class="line">            filename: &#39;index.html&#39;,</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="复制文件-copy-webpack-plugin"><a href="#复制文件-copy-webpack-plugin" class="headerlink" title="复制文件  copy-webpack-plugin"></a>复制文件  copy-webpack-plugin</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const CopyWebpackPlugin &#x3D; require(&#39;copy-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new CopyWebpackPlugin(&#123;</span><br><span class="line">            patterns: [</span><br><span class="line">                &#123;</span><br><span class="line">                    from: &#39;public&#x2F;favicon.ico&#39;,</span><br><span class="line">                    to: &#39;&#39;</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插件实现原理"><a href="#插件实现原理" class="headerlink" title="插件实现原理"></a>插件实现原理</h4><p>通过钩子机制实现</p>
<p>插件必须是一个函数或者包含apply 方法的对象</p>
<p>一般都会定义一个类型，通过实例来实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 实现一个去处打包后文件注释的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> </span>&#123;</span><br><span class="line">    <span class="comment">// apply 方法会在webpack启动时被调用</span></span><br><span class="line">    apply (compiler)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;webpack 启动 &#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// emit 钩子在webpack准备往目标目录输出文件时执行,</span></span><br><span class="line">        <span class="comment">// 第一个参数是插件名称， 第二个参数函数的参数是打包过程的上下文</span></span><br><span class="line">        compiler.hooks.emit.tap(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 获取即将写入的资源信息</span></span><br><span class="line">            <span class="keyword">const</span> assets = compilation.assets</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> assets) &#123;</span><br><span class="line">                <span class="comment">// key 就是 资源文件名称</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.endsWith(<span class="string">&#x27;.js&#x27;</span>))&#123;</span><br><span class="line">                    <span class="comment">// 这里只处理js文件</span></span><br><span class="line">                    <span class="comment">// source方法返回文件文本内容</span></span><br><span class="line">                    <span class="keyword">const</span> value = compilation.assets[key].source();</span><br><span class="line">                    <span class="comment">// 通过正则替换掉注释信息</span></span><br><span class="line">                    <span class="keyword">const</span> withoutComments = contents.replace(<span class="regexp">/\/\*\*+\*\//g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                    compilation.assets[key] = &#123;</span><br><span class="line">                        source: <span class="function">() =&gt;</span> withoutComments,</span><br><span class="line">                        size: <span class="function">() =&gt;</span> withoutComments.length, <span class="comment">// 返回内容方法，必须</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    historyApiFallback: true, &#x2F;&#x2F;historyApiFallback设置为true那么所有的路径都执行index.html。</span><br><span class="line">    overlay: true, &#x2F;&#x2F; 将错误显示在html之上</span><br><span class="line">    port: 8080,</span><br><span class="line">    progress: true,</span><br><span class="line">    contentBase: &#39;.&#x2F;dist&#39;,</span><br><span class="line">    open: false,</span><br><span class="line">    hot: true,</span><br><span class="line">    disableHostCheck: true,  &#x2F;&#x2F; 没有这项ie 会重复报错，</span><br><span class="line">    historyApiFallback: true,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h4><h4 id="treeShaking"><a href="#treeShaking" class="headerlink" title="treeShaking"></a>treeShaking</h4><p>去除未引用代码</p>
<p>treeShaking会在生产环境下自动开启，其他环境下可以通过配置usedExports和minimize来手动开启treeShaking</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    usedExports: true,</span><br><span class="line">    minimize: true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack搭建react脚手架</title>
    <url>/2020/09/23/webpack%E6%90%AD%E5%BB%BAreact%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    <content><![CDATA[<h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><h4 id="1-安装webpack"><a href="#1-安装webpack" class="headerlink" title="1. 安装webpack"></a>1. 安装webpack</h4><p>初始化项目，初始化package.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p>安装webpack包，webpack</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack webpack-cli -D</span><br></pre></td></tr></table></figure>

<p>创建文件  src/index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;along&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>创建文件  webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 如果配置多页应用，需要这样配置</span></span><br><span class="line">    <span class="comment">// entry: &#123;</span></span><br><span class="line">    <span class="comment">//     index: &#x27;./src/index.js&#x27;,</span></span><br><span class="line">    <span class="comment">//     home: &#x27;./src/home.js&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        <span class="comment">// filename: &#x27;[name].[hash:8].js&#x27;,</span></span><br><span class="line">        <span class="comment">// 如果配置多页应用必须这样配置</span></span><br><span class="line">        filename: <span class="string">&#x27;index.[hash:8].js&#x27;</span>,</span><br><span class="line">        <span class="comment">// 打包文件路径 该路径为绝对路径</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">        <span class="comment">// 静态资源引用会统一加一个路径，比如加上cdn地址</span></span><br><span class="line">        <span class="comment">// publicPath: &#x27;http://www.baidu.com&#x27;,</span></span><br><span class="line">        publicPath: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 开发环境中使用devtool做源码映射</span></span><br><span class="line">    <span class="comment">// source-map  大而全 单独生成源码map文件, 标识凑无的列和行</span></span><br><span class="line">    <span class="comment">// eval-source-map 同上，但是产生单独的文件，将映射打包到打包后的js文件里</span></span><br><span class="line">    <span class="comment">// cheap-module-source-map  单独文件，不会映射列</span></span><br><span class="line">    <span class="comment">// cheap-module-eval-source-map 不产生文件，不映射列</span></span><br><span class="line">    devtool: <span class="string">&#x27;cheap-module-source-map&#x27;</span>,</span><br><span class="line">    watch: <span class="literal">true</span>, <span class="comment">// 监控代码变化实时打包,文件变化后自动打包</span></span><br><span class="line">    watchOptions: &#123;</span><br><span class="line">        <span class="comment">// 忽略监视node_modules中的文件</span></span><br><span class="line">        ignored: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="comment">// aggregateTimeout: 500,  // 文件变化时防抖，500ms内没有再次变化再执行打包</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行打包命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure>

<p>可以看到 /build/index.js 打包后的结果,为了以后执行命令方便将命令写入package.json中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    ...  </span><br><span class="line">    &quot;scripts&quot;: &#123;    </span><br><span class="line">        &quot;build&quot;: &quot;webpack&quot;,  </span><br><span class="line">    &#125;  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后打包执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<h4 id="2-webpack-dev-server"><a href="#2-webpack-dev-server" class="headerlink" title="2. webpack-dev-server"></a>2. webpack-dev-server</h4><p>webpack-dev-server 内部通过express实现静态资源服务，不会生成打包文件，而是在内存中打包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack-dev-server -D</span><br></pre></td></tr></table></figure>

<p>package.js添加命令</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">	...  </span><br><span class="line">	&quot;scripts&quot;: &#123;    </span><br><span class="line">		...    </span><br><span class="line">		&quot;dev&quot;: &quot;webpack-dev-server&quot;,  </span><br><span class="line">	&#125;  </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>打开服务地址可以看到自动生成了一个项目的文件服务</p>
<p>修改webpack-dev-server的配置，在webpack.config.js中添加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	devServer: &#123;</span><br><span class="line">        port: <span class="number">8006</span>,</span><br><span class="line">        progress: <span class="literal">true</span>, <span class="comment">// 打包进度</span></span><br><span class="line">        <span class="comment">// 静态服务文件夹,如果存在该文件夹，静态服务则会以此文件夹作为根路径</span></span><br><span class="line">        contentBase: <span class="string">&#x27;./build&#x27;</span>,</span><br><span class="line">        open: <span class="literal">true</span>, <span class="comment">// 打包完成后打开浏览器</span></span><br><span class="line">        <span class="comment">// 将错误信息输出到页面上显示</span></span><br><span class="line">        overlay: &#123;</span><br><span class="line">            warnings: <span class="literal">true</span>,</span><br><span class="line">            errors: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 跨域代理</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="comment">// 将/api 开头的接口代理到目标地址，如果是所有请求可以填/</span></span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                target: <span class="string">&#x27;http://localhost:8089&#x27;</span>,</span><br><span class="line">                <span class="comment">// pathRewrite: &#123;</span></span><br><span class="line">                <span class="comment">//     &#x27;/api&#x27;: &#x27;&#x27;,</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>如果contentBase中指定的文件夹存在，则会看到指定文件夹的文件服务，如果不存在，会看到  Cannot GET /</p>
<h4 id="3-区分环境"><a href="#3-区分环境" class="headerlink" title="3. 区分环境"></a>3. 区分环境</h4><p>实际打包时需要开发环境和生产环境，我们需要分别来配置两种环境</p>
<p>借助  webpack-merge  合并配置文件</p>
<p>借助  yargs-parser  获取脚本参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack-merge yargs-parser -D</span><br></pre></td></tr></table></figure>

<p>创建两个文件,将webpack.config.js中的配置拆分到生产和开发环境的配置文件中</p>
<p>config/webpack.development.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devtool: <span class="string">&#x27;cheap-module-source-map&#x27;</span>,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        port: <span class="number">8006</span>,</span><br><span class="line">        progress: <span class="literal">true</span>, <span class="comment">// 打包进度</span></span><br><span class="line">        <span class="comment">// 静态服务文件夹,如果存在该文件夹，静态服务则会以此文件夹作为根路径</span></span><br><span class="line">        contentBase: <span class="string">&#x27;./build&#x27;</span>,</span><br><span class="line">        open: <span class="literal">true</span>, <span class="comment">// 打包完成后打开浏览器</span></span><br><span class="line">        <span class="comment">// 将错误信息输出到页面上显示</span></span><br><span class="line">        overlay: &#123;</span><br><span class="line">            warnings: <span class="literal">true</span>,</span><br><span class="line">            errors: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 跨域代理</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="comment">// 将/api 开头的接口代理到目标地址，如果是所有请求可以填/</span></span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                target: <span class="string">&#x27;http://localhost:8089&#x27;</span>,</span><br><span class="line">                <span class="comment">// pathRewrite: &#123;</span></span><br><span class="line">                <span class="comment">//     &#x27;/api&#x27;: &#x27;&#x27;,</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>config/webpack.production.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    watch: <span class="literal">true</span>, <span class="comment">// 监控代码变化实时打包,文件变化后自动打包</span></span><br><span class="line">    watchOptions: &#123;</span><br><span class="line">        <span class="comment">// 忽略监视node_modules中的文件</span></span><br><span class="line">        ignored: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="comment">// aggregateTimeout: 500,  // 文件变化时防抖，500ms内没有再次变化再执行打包</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> argv = <span class="built_in">require</span>(<span class="string">&#x27;yargs-parser&#x27;</span>)(process.argv.slice(<span class="number">2</span>)); <span class="comment">// 获取参数</span></span><br><span class="line"><span class="keyword">const</span> &#123;merge&#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> _mode = argv.mode || <span class="string">&#x27;development&#x27;</span>; <span class="comment">// 获取当前模式</span></span><br><span class="line"><span class="keyword">const</span> _isEnvDevelopment = _mode === <span class="string">&#x27;development&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> _isEnvProduction = _mode === <span class="string">&#x27;production&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> _mergeConfig = <span class="built_in">require</span>(<span class="string">`./config/webpack.<span class="subst">$&#123;_mode&#125;</span>.js`</span>); <span class="comment">// 引入对应的文件</span></span><br><span class="line"><span class="keyword">const</span> baseConfig = &#123;</span><br><span class="line">    mode: _mode ,</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;index.[hash:8].js&#x27;</span>,</span><br><span class="line">        <span class="comment">// 打包文件路径 该路径为绝对路径</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">        <span class="comment">// 静态资源引用会统一加一个路径，比如加上cdn地址</span></span><br><span class="line">        <span class="comment">// publicPath: &#x27;http://www.baidu.com&#x27;,</span></span><br><span class="line">        publicPath: _isEnvDevelopment ? <span class="string">&#x27;/&#x27;</span> : <span class="string">&#x27;/build/&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = merge(_mergeConfig, baseConfig);</span><br></pre></td></tr></table></figure>

<p>修改package.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	&quot;scripts&quot;: &#123;</span><br><span class="line">       &quot;dev&quot;: &quot;webpack-dev-server --mode development&quot;,</span><br><span class="line">       &quot;build&quot;: &quot;webpack --mode production&quot;</span><br><span class="line">     &#125;,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-html-webpack-plugin、clean-webpack-plugin、copy-webpack-plugin"><a href="#4-html-webpack-plugin、clean-webpack-plugin、copy-webpack-plugin" class="headerlink" title="4.html-webpack-plugin、clean-webpack-plugin、copy-webpack-plugin"></a>4.html-webpack-plugin、clean-webpack-plugin、copy-webpack-plugin</h4><p>借助 html-webpack-plugin 可以自动将打包后的js文件插入到模板html中，clean-webpack-plugin   可以每次打包前删除之前的打包目录, copy-webpack-plugin 可以指定文件每次打包时复制一份到打包目录下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin clean-webpack-plugin copy-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p>webpack.config.js 引入 html-webpack-plugin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br></pre></td></tr></table></figure>

<p>webpack.config.js 中插入配置项</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    ...        </span><br><span class="line">	plugins: [</span><br><span class="line">        <span class="comment">// 如果是多页应用，应当new多个HtmlWebpackPlugin实例，并分别指定template、filename、chunks</span></span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="comment">// 模板html路径</span></span><br><span class="line">            template: &#x27;./public/index.html&#x27;,</span><br><span class="line">            filename: &#x27;index.html&#x27;, // 打包后的文件名称</span><br><span class="line">            minify: _isEnvProduction ? &#123; // 压缩html production 环境配置此项</span><br><span class="line">                removeAttributeQuotes: true, // 去除双引号 </span><br><span class="line">                collapseWhitespace: true, // 折叠空行</span><br><span class="line">                hash: true, // 插入js在？后加一个hash戳，防止缓存，当然也可以每次生成js时在文件名引入hash</span><br><span class="line">            &#125; : &#123;&#125;</span><br><span class="line">            <span class="comment">//chunks: [&#x27;home&#x27;], // 指定html模板要引入的js文件，名字与入口中的文件名对应，一般在打包多页应用时会用到，默认没有该配置会引入所有入口文件</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack.production.js  中引入  clean-webpack-plugin 和 copy-webpack-plugin</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;copy-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">        <span class="comment">// 每次打包将项目下的readme.txt文件复制到打包文件下</span></span><br><span class="line">        <span class="keyword">new</span> CopyWebpackPlugin([&#123;</span><br><span class="line">            <span class="keyword">from</span>: <span class="string">&#x27;readme.txt&#x27;</span>, <span class="comment">// 把项目中的readme.txt每次打包复制到build文件下</span></span><br><span class="line">            to: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;]),</span><br><span class="line">    ]</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建html模板文件  public/index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>along-cli<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span>no javascript<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建readme.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个文件用于测试，copy-webpack-plugin</span><br></pre></td></tr></table></figure>

<p>修改  src/index.js  内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>).innerHTML = <span class="string">&quot;along&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>可以看到弹出的界面中along字样</p>
<h4 id="5-样式处理"><a href="#5-样式处理" class="headerlink" title="5.样式处理"></a>5.样式处理</h4>]]></content>
      <tags>
        <tag>react</tag>
        <tag>webpack</tag>
        <tag>ts</tag>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2021/01/06/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>一、位运算<br>二进制：计算机中所有数据的存储和运算都是以二进制（补码）的形式进行的, 数字是四个字节，一个字节为8位，则一个数字是由32位二进制表示的<br>    a -&gt; 97, A -&gt; 65, ‘0’ -&gt; 48<br>举例：5 , -5<br>    原码：<br>    5: 0000 0000  0000 0000  0000 0000  0000 0101<br>    -5:1000 0000  0000 0000  0000 0000  0000 0101<br>    反码：（将原码）符号位不变，数值位取反（0变1，1变0）<br>    5: 0000 0000  0000 0000  0000 0000  0000 0101<br>    -5:1111 1111  1111 1111  1111 1111  1111 1010<br>    补码：负数等于反码+1,如果负数反码全是1, 则最后补码全是0, 正数与源码反码一样。<br>    5: 0000 0000  0000 0000  0000 0000  0000 0101<br>    -5:1111 1111  1111 1111  1111 1111  1111 1011<br>结论：正数的原码、反码、补码都是一样的<br>    0：0000 0000  0000 0000  0000 0000  0000 0000<br>    -0:1000 0000  0000 0000  0000 0000  0000 0000<br>位运算符：7个<br>    &amp;（按位与，and）：两个数字同为1，则为1，否则就是0<br>    |（按位或，or）：两个数字只要有一个是1，则结果为1<br>    ^（按位异或，xor）：两个数字不相同为1，相同为0<br>    ~（按位取反，not）：0变1，1变0<br>    &lt;&lt;（左移，shl）：a shl b，把二进制数a左移b位，在后面补0，相当于a乘以2的b次方，保留符号位<br>    &gt;&gt;（右移，shr）：把a右移b位（去掉末b位），相当于a除以2的b次方，高位补原符号位（0或1）， 保留符号位<br>    &gt;&gt;&gt;（无符号右移）：把a右移b位（去掉末b位），相当于a除以2的b次方，高位补0</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>, b = <span class="number">-5</span>, c = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a b c 的 补码分别为</span></span><br><span class="line"><span class="comment">// 5: 0000 0000 0000 0000 0000 0000 0000 0101</span></span><br><span class="line"><span class="comment">// -5:1000 0000 0000 0000 0000 0000 0000 0101</span></span><br><span class="line"><span class="comment">// 2  0000 0000 0000 0000 0000 0000 0000 0010</span></span><br><span class="line">a &amp; c  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">a | c <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">a ^ c <span class="comment">// 7 </span></span><br><span class="line">   </span><br><span class="line">~a    <span class="comment">// -6  // 5 的补码全取反=&gt; 1111 1111 1111 1111 1111 1111 1111 1010 =&gt; 减去1算出反码 =&gt; 1111 1111 1111 1111 1111 1111 1111 1001 =&gt; 反码推算出源码 =&gt;  1000 0000 0000 0000 0000 0000 0000 0110 =&gt; -6</span></span><br><span class="line"></span><br><span class="line">~b    <span class="comment">// 4   //  -5 的补码1111 1111  1111 1111  1111 1111  1111 1011全取反 =&gt; 0000 0000 0000 0000 0000 0000 0000 0100 =&gt; 推导出源码 =&gt; 4</span></span><br><span class="line"></span><br><span class="line">a &lt;&lt; <span class="number">2</span> <span class="comment">// 20	// 0000 0000 0000 0000 0000 0000 0001 0100 </span></span><br><span class="line"></span><br><span class="line">b &gt;&gt; <span class="number">2</span> <span class="comment">// -2</span></span><br><span class="line"></span><br><span class="line">b &lt;&lt; <span class="number">2</span> <span class="comment">// -20</span></span><br><span class="line"></span><br><span class="line">b &gt;&gt;&gt; <span class="number">2</span> <span class="comment">// 1073741822</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p>&amp; 按位与</p>
<ul>
<li>取模 a % b == a &amp; (b - 1) , 只能在b 为 2^n时使用</li>
<li>奇偶数判断,正负数都可以<ul>
<li>偶数 a &amp; 1 = 0;</li>
<li>奇数 a &amp; 1 = 1;</li>
</ul>
</li>
</ul>
<p>^ 异或<br>    一个数字异或另一个数字两次等于概数本身</p>
<ul>
<li>两数字交换<ul>
<li>a = 3, b = 4<ul>
<li>a = a ^ b</li>
<li>b = a ^ b</li>
<li>a = a ^ b</li>
<li>=&gt; a = 4, b = 3</li>
</ul>
</li>
</ul>
</li>
<li>给定一个数组，这个数组中所有的数字都出现两次，只有一个数字出现一次，找出出现一次的数字<ul>
<li>[2,3,4,3,2,5,5]<ul>
<li>遍历数组中的数字，一直执行异或操作</li>
<li>2 ^ 3 ^ 4 ^ 3 ^ 2 ^ 5 ^ 5 =&gt; 4 </li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>原型链继承</title>
    <url>/2020/10/23/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h2><img src="/2020/10/23/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF.png" class="">

<p>每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性，实例对象可通过__proto__访问到对象的原型，这个原型指向构造函数的prototype。</p>
<p>每个原型都有一个 constructor 属性指向关联的构造函数</p>
<p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止</p>
<p>构造函数的constructor 指向 Function 构造器。</p>
<p>Function的原型指向Function.prototype</p>
<p>Function 的构造函数指向自己 Function.constructor === Function.<strong>proto</strong>.constructor === Function</p>
]]></content>
      <tags>
        <tag>原型链</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘</title>
    <url>/2020/09/04/%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<h3 id="eslint-关闭校验"><a href="#eslint-关闭校验" class="headerlink" title="eslint 关闭校验"></a>eslint 关闭校验</h3><h4 id="关闭段落校验"><a href="#关闭段落校验" class="headerlink" title="关闭段落校验"></a>关闭段落校验</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint-disable *&#x2F;</span><br><span class="line">    代码块</span><br><span class="line">&#x2F;* eslint-enable *&#x2F;</span><br></pre></td></tr></table></figure>


<h4 id="关闭当前行校验"><a href="#关闭当前行校验" class="headerlink" title="关闭当前行校验"></a>关闭当前行校验</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一行代码 &#x2F;&#x2F; eslint-disable-line</span><br></pre></td></tr></table></figure>
<h4 id="关闭下一行校验"><a href="#关闭下一行校验" class="headerlink" title="关闭下一行校验"></a>关闭下一行校验</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; eslint-disable-next-line</span><br><span class="line">下一行的代码</span><br></pre></td></tr></table></figure>

<h4 id="关闭对这单一文件的校验"><a href="#关闭对这单一文件的校验" class="headerlink" title="关闭对这单一文件的校验"></a>关闭对这单一文件的校验</h4><p>在文件头部加上注释,eslint在校验的时候会跳过后续的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint-disable *&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="git-命令"><a href="#git-命令" class="headerlink" title="git 命令"></a>git 命令</h3><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<h4 id="切换到分支"><a href="#切换到分支" class="headerlink" title="切换到分支"></a>切换到分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkout 分支名称 </span><br></pre></td></tr></table></figure>

<h4 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch 分支 </span><br></pre></td></tr></table></figure>

<h4 id="新建分支并切换"><a href="#新建分支并切换" class="headerlink" title="新建分支并切换"></a>新建分支并切换</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b 分支 </span><br></pre></td></tr></table></figure>

<h3 id="centOS-部署"><a href="#centOS-部署" class="headerlink" title="centOS 部署"></a>centOS 部署</h3><h4 id="后台运行程序"><a href="#后台运行程序" class="headerlink" title="后台运行程序"></a>后台运行程序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup (启动服务命令node build&#x2F;server.js) &amp;</span><br></pre></td></tr></table></figure>

<h4 id="查看所有后台进程"><a href="#查看所有后台进程" class="headerlink" title="查看所有后台进程"></a>查看所有后台进程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jobs</span><br></pre></td></tr></table></figure>

<h4 id="查看后台进程"><a href="#查看后台进程" class="headerlink" title="查看后台进程"></a>查看后台进程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -aux</span><br></pre></td></tr></table></figure>

<h4 id="查看node相关进程"><a href="#查看node相关进程" class="headerlink" title="查看node相关进程"></a>查看node相关进程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps aux|grep node</span><br><span class="line"># 或者</span><br><span class="line">ps -ef|grep node</span><br></pre></td></tr></table></figure>

<h4 id="删除进程"><a href="#删除进程" class="headerlink" title="删除进程"></a>删除进程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -9 (进程id)</span><br></pre></td></tr></table></figure>

<h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp 源文件 目标路径</span><br></pre></td></tr></table></figure>

<h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv 源 目标</span><br></pre></td></tr></table></figure>

<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -i 源      &#x2F;&#x2F; -i 删除前询问</span><br></pre></td></tr></table></figure>

<h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch 文件</span><br></pre></td></tr></table></figure>

<h4 id="用户切换"><a href="#用户切换" class="headerlink" title="用户切换"></a>用户切换</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su 用户名</span><br></pre></td></tr></table></figure>

<h4 id="查看ip"><a href="#查看ip" class="headerlink" title="查看ip"></a>查看ip</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure>

<h4 id="查看关闭防火墙"><a href="#查看关闭防火墙" class="headerlink" title="查看关闭防火墙"></a>查看关闭防火墙</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall -amd --state    查看防火墙状态</span><br><span class="line">systemctl stop firewalld.service   停止</span><br><span class="line">systemctl disable firewalld.service  禁止开机启动</span><br></pre></td></tr></table></figure>

<h4 id="查看端口占用情况"><a href="#查看端口占用情况" class="headerlink" title="查看端口占用情况"></a>查看端口占用情况</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -tunlp|grep 端口号</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title>微信开发者工具</title>
    <url>/2020/11/19/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>微信开发者工具是基于NW实现的，开发工具中所有功能、按钮、模块都是用web实现的，我们可以通过打开隐藏调试工具找到每个部分的代码</p>
<h4 id="在开发工具控制台，使用命令"><a href="#在开发工具控制台，使用命令" class="headerlink" title="在开发工具控制台，使用命令"></a>在开发工具控制台，使用命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openInspect()</span><br></pre></td></tr></table></figure>

<p>打开chromw devtool</p>
<img src="/2020/11/19/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/devtools.png" class="">

<p>点击Apps -&gt; inspect</p>
<p>此时就打开了隐藏的调试工具，切换到控制台的Elements,可以看到微信开发工具中的每一个部分的web代码</p>
<img src="/2020/11/19/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/tool.png" class="">

<p>通过 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementsByTagName(&#39;webview&#39;)</span><br></pre></td></tr></table></figure>
<p>可以看到小程序的几个webview</p>
<img src="/2020/11/19/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/webview.png" class="">

<p>通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementsByTagName(&#39;webview&#39;)[0].showDevTools(true, null)</span><br></pre></td></tr></table></figure>
<p>打开小程序的渲染层</p>
<img src="/2020/11/19/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/renderview.png" class="">





]]></content>
  </entry>
  <entry>
    <title>手写Promise</title>
    <url>/2020/09/23/%E6%89%8B%E5%86%99promise/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存实例状态</span></span><br><span class="line">    status = PENDING;</span><br><span class="line">    value = <span class="literal">undefined</span>; <span class="comment">// 成功时的返回值</span></span><br><span class="line">    reason = <span class="literal">undefined</span>; <span class="comment">// 失败时的返回值</span></span><br><span class="line">    successCallback = []; <span class="comment">// 异步成功回调</span></span><br><span class="line">    failCallback = []; <span class="comment">// 异步失败回调</span></span><br><span class="line">    <span class="comment">// executor 执行器，promise创建实例时传入的回调函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="comment">// 捕获执行器中的错误</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(<span class="built_in">this</span>.resolve, <span class="built_in">this</span>.reject); <span class="comment">// 执行器立即执行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="built_in">this</span>.reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 状态更改后无法再次更改</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">this</span>.status = FULFILLED;</span><br><span class="line">        <span class="comment">// 保存成功后的值，方便then方法中拿到</span></span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="comment">// 判断successCallback 成功回调是否存在，存在说明 resolve是异步任务执行后被调用的</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.successCallback.length) &#123;</span><br><span class="line">            <span class="built_in">this</span>.successCallback.shift()(); <span class="comment">// 弹出数组首部函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 状态更改后无法再次更改</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">this</span>.status = REJECTED;</span><br><span class="line">        <span class="comment">// 保存失败的原因，方便then中拿到</span></span><br><span class="line">        <span class="built_in">this</span>.reason = reason;</span><br><span class="line">        <span class="comment">// failCallback 失败回调是否存在，存在说明 reject是异步任务执行后被调用的</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.failCallback.length) &#123;</span><br><span class="line">            <span class="built_in">this</span>.failCallback.shift()(); <span class="comment">// 弹出数组首部函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    then(successCallback, failCallback) &#123;</span><br><span class="line">        <span class="comment">// then方法可以不传递回调函数，自动将promise返回结构向之后的then函数传递</span></span><br><span class="line">        successCallback = successCallback ? successCallback : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        failCallback = failCallback ? failCallback : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// then 链式调用返回新的实例</span></span><br><span class="line">        <span class="keyword">let</span> thenPromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 判断状态</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">                <span class="comment">// 因为同步执行时resolvePromise拿不到thenPromise，</span></span><br><span class="line">                <span class="comment">// 所以让这段代码在return thenPromise后执行</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 捕获then中成功回调的错误</span></span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="keyword">let</span> x = successCallback(<span class="built_in">this</span>.value);</span><br><span class="line">                        resolvePromise(thenPromise, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                        reject(err); <span class="comment">// 把错误信息传递给下一个then方法</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;, <span class="number">0</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 捕获then中成功回调的错误</span></span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="keyword">let</span> x = failCallback(<span class="built_in">this</span>.reason);</span><br><span class="line">                        resolvePromise(thenPromise, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                        reject(err); <span class="comment">// 把错误信息传递给下一个then方法</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;, <span class="number">0</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果执行器中的rosolve或reject是异步执行的</span></span><br><span class="line">                <span class="comment">// then会立即执行，此时，将then中的两个参数保存到实例中</span></span><br><span class="line">                <span class="built_in">this</span>.successCallback.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="comment">// 捕获then中成功回调的错误</span></span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="keyword">let</span> x = successCallback(<span class="built_in">this</span>.value);</span><br><span class="line">                            resolvePromise(thenPromise, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                            reject(err); <span class="comment">// 把错误信息传递给下一个then方法</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                    &#125;, <span class="number">0</span>)</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="built_in">this</span>.failCallback.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="comment">// 捕获then中成功回调的错误</span></span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="keyword">let</span> x = failCallback(<span class="built_in">this</span>.reason);</span><br><span class="line">                            resolvePromise(thenPromise, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                            reject(err); <span class="comment">// 把错误信息传递给下一个then方法</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                    &#125;, <span class="number">0</span>)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> thenPromise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> (callback) &#123;</span><br><span class="line">        <span class="comment">// 无论promise状态是成功还是失败，都会调用finally的callback,并把promise返回结果继续向下传递</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 如果finaly方法返回了promise, 之后的then方法会等待该promise执行结束</span></span><br><span class="line">            <span class="keyword">return</span> MyPromise.resolve( callback() ).then(<span class="function">() =&gt;</span> value)</span><br><span class="line">        &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> MyPromise.resolve( callback() ).then(<span class="function">() =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;) </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span>(failCallback) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, failCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> all (array) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = [];</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">addData</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">                result[key] = value;</span><br><span class="line">                index ++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (index === array.length) &#123;</span><br><span class="line">                    resolve(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// MyPromise.all([&#x27;a&#x27;, &#x27;b&#x27;, new MyPromise(r =&gt; &#123;r(&#x27;p1&#x27;)&#125;)])</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">                <span class="keyword">let</span> current = array[i];</span><br><span class="line">                <span class="keyword">if</span> (current <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                    <span class="comment">// promise对象, 如果成功添加到结果中，如果失败直接reject</span></span><br><span class="line">                    current.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                        addData(i, value)</span><br><span class="line">                    &#125;, reject)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 普通值, 直接放入返回结果中</span></span><br><span class="line">                    addData(i, array[i])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(value);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">thenPromise, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果then的回调返回了then函数返回的promise对象，报错</span></span><br><span class="line">    <span class="comment">// let p = promise.then(v =&gt; &#123;return p&#125;)</span></span><br><span class="line">    <span class="keyword">if</span> (thenPromise === x) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;MyPromise&gt;&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// promise.then(v =&gt; &#123;return x&#125;);</span></span><br><span class="line">    <span class="comment">// 判断x的值是普通值还是promise对象</span></span><br><span class="line">    <span class="comment">// 如果是普通值，直接调用resolve</span></span><br><span class="line">    <span class="comment">// 如果是promise对象，查看promise对象的返回的结果</span></span><br><span class="line">    <span class="comment">// 再根据promise对象返回的结果决定用resolve 还是调用reject</span></span><br><span class="line">    <span class="keyword">if</span>(x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        <span class="comment">// promise对象 , 调用then查看回调状态</span></span><br><span class="line">        <span class="comment">// x.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span></span><br><span class="line">        x.then(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = MyPromise;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Promise</tag>
        <tag>Promise源码</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化</title>
    <url>/2020/08/27/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="模块化的发展阶段"><a href="#模块化的发展阶段" class="headerlink" title="模块化的发展阶段"></a>模块化的发展阶段</h3><h4 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a>stage1</h4><p>最初的模块化依赖文件划分的约定来实现，这种方式存在一些问题</p>
<ul>
<li>污染全局作用域</li>
<li>命名冲突</li>
<li>无法管理模块依赖关系</li>
</ul>
<h4 id="stage2"><a href="#stage2" class="headerlink" title="stage2"></a>stage2</h4><p>命名空间方式，将第一阶段的每个模块包裹在一个全局对象里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var moduleA &#x3D; &#123;</span><br><span class="line">    name: &#39;along&#39;,</span><br><span class="line">    method1: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="stage3"><a href="#stage3" class="headerlink" title="stage3"></a>stage3</h4><p>IIFE  立即执行函数提供私有空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(function($) &#123;</span><br><span class="line">    var name &#x3D; &quot;along&quot;;</span><br><span class="line"></span><br><span class="line">    function method1() &#123;</span><br><span class="line">        console.log(name + &#39;method1&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function method2() &#123;</span><br><span class="line">        console.log(name + &#39;method2&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对于要暴露给外部的成员变量或方法，通过挂载到window上来实现</span><br><span class="line">    window.moduleB &#x3D; &#123;</span><br><span class="line">        method1,</span><br><span class="line">        method2,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(JQuery) &#x2F;&#x2F; 通过传入参数作为模块的依赖声明</span><br></pre></td></tr></table></figure>

<h4 id="state4"><a href="#state4" class="headerlink" title="state4"></a>state4</h4><p>模块化规范出现，node 的 CommonJS 规范</p>
<ul>
<li>一个文件是一个模块</li>
<li>每个模块有单独的作用域</li>
<li>通过<code>module.exports</code> 导出成员</li>
<li>通过<code>require</code>函数载入模块</li>
</ul>
<p>CommonJS 是以同步方式加载模块，不适合浏览器端 ，浏览器早期使用<code>AMD(Asynchronous Module Definition)</code> 规范（异步模块定义规范）, 比如 <code>require.js</code> 库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; requirejs 定义模块</span><br><span class="line">&#x2F;&#x2F; 第一个参数是模块名称，第二个参数数组是依赖模块，第三个函数体的参数依次是依赖模块的导出成员</span><br><span class="line">define(&#39;module&#39;, [&#39;jquery&#39;, &#39;.&#x2F;module2&#39;], function($, module2) &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过return 导出成员</span><br><span class="line">    return &#123;</span><br><span class="line">        start: function() &#123;</span><br><span class="line">            $(&#39;body&#39;).animate(&#123;margin: &#39;200px&#39;&#125;);</span><br><span class="line">            module2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果一个模块不需要定义模块（不需要导出成员，可以只加载其他模块）</span><br><span class="line">require([&#39;.&#x2F;module1&#39;], function() &#123;</span><br><span class="line">    module1.start();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AMD</code> 使用复杂（需要写稍多的代码）</li>
<li>模块js文件请求频繁 </li>
</ul>
<p>于 <code>AMD</code> 同期，淘宝出现 <code>CMD(Commen Module Definition)</code>(通用模块定义规范) 规范的 <code>sea.js</code></p>
<p><code>CMD</code>规范希望写出的代码能与<code>CommenJS</code>类似，从而减轻开发成本，不过后气<code>CMD</code>规范的方式被 <code>require.js</code>兼容了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; CMD 规范 类似CommonJS 规范</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">    var $ &#x3D; require(&#39;jquery&#39;);</span><br><span class="line"></span><br><span class="line">    module.exports &#x3D; function() &#123;</span><br><span class="line">        $(&#39;body&#39;).append(&#39;&lt;p&gt;module&lt;&#x2F;p&gt;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="stage5"><a href="#stage5" class="headerlink" title="stage5"></a>stage5</h4><p>模块化标准出现</p>
<ul>
<li>浏览器端 <code>ES Modules</code>  (ES6特性，因为存在兼容问题，)</li>
<li>node <code>CommonJS</code>  </li>
</ul>
<h3 id="ES-Modules"><a href="#ES-Modules" class="headerlink" title="ES Modules"></a>ES Modules</h3><p>特性</p>
<p>通过给<code>script</code>添加<code>type=&quot;module&quot;</code> 属性，就可以以ES Module 标准执行其中的JS代码</p>
<ul>
<li><code>ES Modules</code> 会自动采用严格模式， 忽略<code>&#39;use strice&#39;</code>   严格模式下this不能指向<code>window</code>  </li>
<li><code>ES Modules</code>运行在单独的私有作用域中</li>
<li><code>ES Modules</code>通过<code>CORS</code>方式请求外部JS模块 ，服务端必须支持<code>CORS</code>,不能以文件形式访问，只能用http server</li>
<li><code>ES Modules</code>的<code>script</code>标签会延迟执行脚本， 相当于给 添加了 <code>defer</code> 属性 <script defer src=""></script></li>
</ul>
<h4 id="ES-Modules-导入导出"><a href="#ES-Modules-导入导出" class="headerlink" title="ES Modules 导入导出"></a>ES Modules 导入导出</h4><p>直接导出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .&#x2F;module.js</span><br><span class="line">export var name &#x3D; &#39;along&#39;;</span><br><span class="line">export functiion hello () &#123;</span><br><span class="line">    console.log(&#39;along&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app.js</span><br><span class="line">import &#123;name, hello&#125; from &#39;.&#x2F;module.js&#39;;</span><br></pre></td></tr></table></figure>

<p>底部统一导出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .&#x2F;module.js</span><br><span class="line">const foo &#x3D; &#39;along&#39;;</span><br><span class="line">functiion hello () &#123;</span><br><span class="line">    console.log(&#39;along&#39;);</span><br><span class="line">&#125;</span><br><span class="line">export &#123;foo, hello&#125;; &#x2F;&#x2F; 底部统一导出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app.js</span><br><span class="line">import &#123;foo&#125; from &#39;.&#x2F;module.js&#39;</span><br><span class="line">console.log(foo)</span><br></pre></td></tr></table></figure>

<p>底部统一导出时可以重命名， 并且在引入时也可以定义一个新的名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .&#x2F;module.js</span><br><span class="line">const name &#x3D; &#39;along&#39;;</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">    name as alongname,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app.js</span><br><span class="line">import &#123;alongname&#125; from &#39;.&#x2F;module.js&#39;; &#x2F;&#x2F; 需要使用别名导入</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; import &#123;alongname as newname&#125; from &#39;.&#x2F;module.js&#39;;</span><br></pre></td></tr></table></figure>

<p>特殊用法，默认导出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .&#x2F;module.js</span><br><span class="line">var name &#x3D; &#39;along&#39;;</span><br><span class="line">export default name;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app.js</span><br><span class="line">import a from &#39;.&#x2F;module.js&#39;;  &#x2F;&#x2F; 导入时可以根据需要重新定义引入变量名称</span><br></pre></td></tr></table></figure>


<h4 id="ES-Modules-导入导出误区"><a href="#ES-Modules-导入导出误区" class="headerlink" title="ES Modules 导入导出误区"></a>ES Modules 导入导出误区</h4><ul>
<li><code>ES Modules</code>导入导出的时候要注意，在底部统一导出时(如 <code>export &#123;name, age&#125;</code>), 导出的并不是一个对象，这里的花括号只是一种 export 单独使用时的固定语</li>
<li>在引入时(如<code>import &#123;name, age&#125; from &#39;./module.js&#39;</code>), 并不是对象的结构。</li>
<li>如果需要导出对象，需要使用 <code>export default &#123;name, age&#125;</code>的方式</li>
<li><code>ES Modules</code> 导出的对象成员导出的是引用地址</li>
<li>通过 <code>ES Modules</code> 引入的成员是只读成员，不能重新赋值</li>
</ul>
<h4 id="ES-Modults-导入误区"><a href="#ES-Modults-导入误区" class="headerlink" title="ES Modults 导入误区"></a>ES Modults 导入误区</h4><ul>
<li><code>import &#123;name&#125; from &#39;./module.js&#39;</code> <code>from</code> 后的模块路径不能省略后缀名</li>
<li><code>import</code> 后的模块路径不能默认导入<code>index.js</code></li>
<li>可以通过绝对路径或者全路径引入 比如 <code>&#39;/lib/tool.js&#39;</code>  或者 <code>&#39;http://localhost:3000/lib/tool.js&#39;</code></li>
<li>不需要提取成员只需要执行模块时，可以导入空<code>import &#123;&#125; from &#39;./module.js&#39;</code>  或者写成 <code>import &#39;./module.js&#39;</code></li>
<li>提取成员较多可以将所有导出成员通过<code>as</code>放入一个对象中<code>import * as mod from &#39;./module.js&#39;</code></li>
<li><code>import</code>关键字只能出现在最顶层，不能将路径存放在变量中导入，如果想通过动态导入模块，可以使用<code>import(&#39;./module.js&#39;).then(function(module) &#123;&#125;)</code>方式</li>
<li>同时提取默认成员和命名成员 <code>import title, &#123;name, age&#125; from &#39;./module.js&#39;</code> 或者 <code>import &#123;name, age, default as title&#125; from &#39;./module.js&#39;</code></li>
</ul>
<h4 id="ES-Modules-导出"><a href="#ES-Modules-导出" class="headerlink" title="ES Modules 导出"></a>ES Modules 导出</h4><ul>
<li>导入时直接导出<code>export &#123;name, age&#125; from &#39;./module.js&#39;</code></li>
</ul>
<h4 id="ES-Modules-浏览器-Polyfill"><a href="#ES-Modules-浏览器-Polyfill" class="headerlink" title="ES Modules 浏览器 Polyfill"></a>ES Modules 浏览器 Polyfill</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// promise polyfill</span><br><span class="line">// nomodule 属性只会在不支持es module 的浏览器工作，如果不添加，es module 会分别被 es module polyfill 和 浏览器执行，导致在支持es module 的浏览器中， 下方的 foo 被打印两次</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/promise-polyfill@8.1.3/dist/polyfill.min.js&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// es module polyfill</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/browse/browser-es-module-loader@0.4.1/dist/babel-browser-build.js&quot;</span> /&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/browse/browser-es-module-loader@0.4.1/dist/browser-es-module-loader.js&quot;</span> /&gt;</span></span></span></span><br><span class="line"></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(foo);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ES-Module-Node-环境支持情况"><a href="#ES-Module-Node-环境支持情况" class="headerlink" title="ES Module Node 环境支持情况"></a>ES Module Node 环境支持情况</h4><p>node 版本大于 8.5</p>
<p>目前仍处在实验阶段，node不建议在生产环境中使用</p>
<h4 id="ES-Module-Node-Babel"><a href="#ES-Module-Node-Babel" class="headerlink" title="ES Module Node Babel"></a>ES Module Node Babel</h4>]]></content>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>脚手架工具</title>
    <url>/2020/08/27/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="脚手架工具"><a href="#脚手架工具" class="headerlink" title="脚手架工具"></a>脚手架工具</h2><p>特定项目脚手架，比如</p>
<ul>
<li>creat-react-app</li>
<li>vue-cli</li>
</ul>
<p>通用脚手架工具</p>
<ul>
<li>Yeoman</li>
<li>plop</li>
</ul>
<h3 id="Yeoman-通用脚手架"><a href="#Yeoman-通用脚手架" class="headerlink" title="Yeoman 通用脚手架"></a>Yeoman 通用脚手架</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn global add yo</span><br><span class="line">yarn global add generator-node</span><br></pre></td></tr></table></figure>
<p>我再安装时出现了yo不是内部命令的问题<br>将yarn添加到path 重新执行上述命令，可以通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn global bin</span><br></pre></td></tr></table></figure>
<p>查看yarn全局安装路径</p>
<p>创建生成器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yo node</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? The name above already exists on npm, choose another? Yes</span><br><span class="line">? Module Name along-yo  &#x2F;&#x2F; 生成器名称</span><br><span class="line">? Description test yeoman &#x2F;&#x2F; 描述</span><br><span class="line">? Project homepage url https:&#x2F;&#x2F;github.com&#x2F;alongithub&#x2F;along-yo &#x2F;&#x2F; 访问地址</span><br><span class="line">? Author&#39;s Name along &#x2F;&#x2F; 作者</span><br><span class="line">? Author&#39;s Email 1792108796@qq.com &#x2F;&#x2F; 邮箱</span><br><span class="line">? Author&#39;s Homepage https:&#x2F;&#x2F;github.com&#x2F;alongithub &#x2F;&#x2F; 作者主页</span><br><span class="line">? Package keywords (comma to split) node,test,yeoman &#x2F;&#x2F; 关键字</span><br><span class="line">? Send coverage reports to coveralls No &#x2F;&#x2F; 覆盖率</span><br><span class="line">? Enter Node versions (comma separated)</span><br></pre></td></tr></table></figure>

<p>已进入到相应目录使用 yo 指令生成项目，可是却在其他文件夹下生成了项目。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Just found a &#96;.yo-rc.json&#96; in a parent directory.</span><br><span class="line">Setting the project root at: &#x2F;Users&#x2F;Pacos</span><br></pre></td></tr></table></figure>

<p>找到 .yo-rc.json 文件，删除既可以解决。</p>
<h3 id="Yeoman-Sub-Generator"><a href="#Yeoman-Sub-Generator" class="headerlink" title="Yeoman Sub Generator"></a>Yeoman Sub Generator</h3><p>如果只需要生成项目结构的一部分，比如增加eslint，或者单独增加一个readme，可以使用yeoman 提供的sub generator 功能</p>
<p>比如使用 generator-node 提供的cli子集生成cli应用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yo node:cli</span><br></pre></td></tr></table></figure>

<p>之后yo会重写package.json, 自动写入 bin, dependencies 信息,并创建cli基础结构</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;bin&quot;: &quot;lib/cli.js&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;meow&quot;: &quot;^3.7.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动创建的cli   lib/cli.js</span></span><br><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> meow = <span class="built_in">require</span>(<span class="string">&#x27;meow&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> yeomandemo = <span class="built_in">require</span>(<span class="string">&#x27;./&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cli = meow(<span class="string">`</span></span><br><span class="line"><span class="string">Usage</span></span><br><span class="line"><span class="string">  $ yeomandemo [input]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options</span></span><br><span class="line"><span class="string">  --foo  Lorem ipsum. [Default: false]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Examples</span></span><br><span class="line"><span class="string">  $ yeomandemo</span></span><br><span class="line"><span class="string">  unicorns</span></span><br><span class="line"><span class="string">  $ yeomandemo rainbows</span></span><br><span class="line"><span class="string">  unicorns &amp; rainbows</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure>
<p>之后先通过命令安装package中的依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn   </span><br><span class="line">&#x2F;&#x2F; 或者npm install</span><br></pre></td></tr></table></figure>

<p>link到全局范围</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn link</span><br></pre></td></tr></table></figure>

<p>通过创建的项目名称即可在全局使用cli命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yeomandemo --help</span><br></pre></td></tr></table></figure>

<pre style="background: #000; color: #ccc">
C:\Users\admin\Desktop\yeomandemo>yeomandemo --help
  yodemo

  Usage
    $ yeomandemo [input]

  Options
    --foo  Lorem ipsum. [Default: false]

  Examples
    $ yeomandemo
    unicorns
    $ yeomandemo rainbows
    unicorns & rainbows
</pre>

<h3 id="以generator-webapp为例，创建一个webapp项目"><a href="#以generator-webapp为例，创建一个webapp项目" class="headerlink" title="以generator-webapp为例，创建一个webapp项目"></a>以generator-webapp为例，创建一个webapp项目</h3><p>安装对应的generator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn global add generator-webapp</span><br></pre></td></tr></table></figure>

<p>执行generator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yo webapp</span><br></pre></td></tr></table></figure>

<p>之后根据提示选择需要的依赖即可创建webapp项目，由于这个生成器存在一些c++模块所以安装时会比较慢</p>
<p>执行启动就可以看到界面了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure>
<p><img src="/20200616191859687/20200617112953463.png" alt="image"><br><img src="/20200616191859687/20200617111505906.png" alt="npm 镜像源"></p>
<h3 id="创建自己的generator"><a href="#创建自己的generator" class="headerlink" title="创建自己的generator"></a>创建自己的generator</h3><p>创建Generator项目需要遵循一定的结构</p>
<pre style="background: #000; color: #ccc">
├ generators/ ·····································  生成器目录
|  ├ app/ ·········································  默认生成器目录
|  |  └ index.js ··································  默认生成器入口实现
|  └ component/ ···································  sub generator 目录
|     └ index.js ··································  sub generator 实现
└ package.json
</pre>

<ol>
<li><p>创建生成器目录  generator-alongtest， 初始化项目, 安装 yeoman-generator模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd generator-alongtest</span><br><span class="line">yarn init</span><br><span class="line">yarn add yeoman-generator</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建generator 规定的项目结构 ，app/index.js 中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; generator入口</span><br><span class="line">const Generator &#x3D; require(&#39;yeoman-generator&#39;);</span><br><span class="line">module.exports &#x3D; class extends Generator &#123;</span><br><span class="line">    writing() &#123;</span><br><span class="line">        &#x2F;&#x2F; yeoman 在生成文件阶段自动调用此方法</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 使用yeoman的fs方法在项目中创建一个temp.txt文件，文件内容是一个随机浮点数</span><br><span class="line">        this.fs.write(</span><br><span class="line">            this.destinationPath(&#39;temp.txt&#39;),</span><br><span class="line">            Math.random().toString()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将自定义generator link到全局</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn link</span><br></pre></td></tr></table></figure></li>
<li><p>新建一个项目文件夹，如 test，</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd test</span><br><span class="line">yo alongtest</span><br></pre></td></tr></table></figure>
<p>此时可以看到test文件夹自动生成了temp.txt文件</p>
<pre style="background:#000;color:#ccc">
C:\Users\admin\Desktop\alontest>yo alongtest
   create temp.txt 
</pre>

<h3 id="接收用户输入并通过模板创建文件"><a href="#接收用户输入并通过模板创建文件" class="headerlink" title="接收用户输入并通过模板创建文件"></a>接收用户输入并通过模板创建文件</h3><ol>
<li>app 下创建模板文件夹templates，和项目文件index.html,package.json<br>这里只用两个文件代表初始化项目中的所有文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;templates&#x2F;index.html</span><br><span class="line">&#x2F;&#x2F; 模板文件</span><br><span class="line">&#x2F;&#x2F; 内部通过EJ5 模板标记输出数据</span><br><span class="line">&#x2F;&#x2F; 其他的EJS 语法也支持</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;</span><br><span class="line">            &lt;%&#x3D; name %&gt;</span><br><span class="line">        &lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">         &lt;%if (name) &#123;%&gt;</span><br><span class="line">            project &lt;%&#x3D; name%&gt;</span><br><span class="line">        &lt;%&#125; else &#123;%&gt;</span><br><span class="line">            no name</span><br><span class="line">        &lt;%&#125;%&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; package.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;&lt;%&#x3D; name%&gt;&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">    &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">    &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">    &quot;dependencies&quot;: &#123;</span><br><span class="line">      &quot;yeoman-generator&quot;: &quot;^4.10.1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>入口文件 app/index.js<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; generator入口</span><br><span class="line">const Generator &#x3D; require(&#39;yeoman-generator&#39;);</span><br><span class="line">module.exports &#x3D; class extends Generator &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取用户输入</span><br><span class="line">    prompting() &#123;</span><br><span class="line">        return this.prompt([</span><br><span class="line">            &#123;</span><br><span class="line">                type: &#39;input&#39;,</span><br><span class="line">                name: &#39;name&#39;,</span><br><span class="line">                message: &#39;your project name&#39;,</span><br><span class="line">                default: this.appname, &#x2F;&#x2F; 自动取到了当前项目目录</span><br><span class="line">            &#125;,</span><br><span class="line">        ]).then(answer &#x3D;&gt; &#123;</span><br><span class="line">            this.answer &#x3D; answer;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writing() &#123;</span><br><span class="line">        const filelist &#x3D; [&#39;index.html&#39;, &#39;package.json&#39;];</span><br><span class="line">        &#x2F;&#x2F; yeoman 在生成文件阶段自动调用此方法</span><br><span class="line">        &#x2F;&#x2F; this.fs.write(</span><br><span class="line">        &#x2F;&#x2F;     this.destinationPath(&#39;temp.txt&#39;),</span><br><span class="line">        &#x2F;&#x2F;     Math.random().toString()</span><br><span class="line">        &#x2F;&#x2F; )</span><br><span class="line"></span><br><span class="line">        filelist.forEach(file &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 通过模板引擎吸入文件到目标目录</span><br><span class="line">            &#x2F;&#x2F; 找到模板文件</span><br><span class="line">            const tmpl &#x3D; this.templatePath(file)</span><br><span class="line">            &#x2F;&#x2F; 输出目标路径</span><br><span class="line">            const output &#x3D; this.destinationPath(file);</span><br><span class="line">            &#x2F;&#x2F; 模板数据上下文</span><br><span class="line">            const context &#x3D; this.answer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            this.fs.copyTpl(tmpl, output, context); </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在新建项目中执行 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yo alongtest</span><br></pre></td></tr></table></figure>
此时命令行会询问信息，最终创建项目结构<pre style="background:#000;color: #fff">
C:\Users\admin\Desktop\alontest>yo alongtest
? your project name along
conflict index.html
? Overwrite index.html? overwrite
 force index.html
</pre>
生成的index.html 与 package.json<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">            along</span><br><span class="line">        <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">            project along</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;along&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;MIT&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;yeoman-generator&quot;</span>: <span class="string">&quot;^4.10.1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到yeomon通过模板填充的方式创建了初始项目文件</p>
<h3 id="发布generator"><a href="#发布generator" class="headerlink" title="发布generator"></a>发布generator</h3><ol>
<li><p>创建.gitignore， 提交到git</p>
</li>
<li><p>发布到npm<br><code>npm publish</code> 或者 <code>yarn publish</code><br>根据提示输入版本和用户名密码，发布成功<br>如果设置过其他npm 镜像需要切换回npm 镜像，可以借助nrm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn global add nrm</span><br><span class="line">nrm ls &#x2F;&#x2F; 查看所有可用镜像</span><br><span class="line">nrm use npm</span><br></pre></td></tr></table></figure></li>
<li><p>之后可以通过yarn global add generator-alongtest 安装 发布的生成器</p>
</li>
</ol>
<h3 id="小型脚手架工具-plop"><a href="#小型脚手架工具-plop" class="headerlink" title="小型脚手架工具 plop"></a>小型脚手架工具 plop</h3><p>用于集成到项目中生成项目中同类型的项目文件</p>
<ol>
<li>安装到项目依赖中<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add plop --dev</span><br></pre></td></tr></table></figure></li>
<li>创建入口问及那 plopfile.js</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; plop 入口问及那</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; plop &#x3D;&gt; &#123;</span><br><span class="line">    plop.setGenerator(&#39;static&#39;, &#123; &#x2F;&#x2F; 模板名称</span><br><span class="line">        description: &#39;create static component&#39;,</span><br><span class="line">        prompts: [ &#x2F;&#x2F; 询问用户输入</span><br><span class="line">            &#123;</span><br><span class="line">                type: &#39;input&#39;,</span><br><span class="line">                name: &#39;name&#39;,</span><br><span class="line">                message: &#39;static component name&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        actions: [ &#x2F;&#x2F; 完成交互后执行的动作</span><br><span class="line">            &#123;</span><br><span class="line">                type: &#39;add&#39;, &#x2F;&#x2F; 添加文件</span><br><span class="line">                path: &#39;src&#x2F;&#123;&#123;name&#125;&#125;&#x2F;index.html&#39;, &#x2F;&#x2F; 创建后文件路径</span><br><span class="line">                templateFile: &#39;plop-templates&#x2F;static-components&#x2F;index.hbs&#39; &#x2F;&#x2F; 模板文件路径</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                type: &#39;add&#39;, &#x2F;&#x2F; 添加文件</span><br><span class="line">                path: &#39;src&#x2F;&#123;&#123;name&#125;&#125;&#x2F;css&#x2F;index.css&#39;,</span><br><span class="line">                templateFile: &#39;plop-templates&#x2F;static-components&#x2F;css&#x2F;style.hbs&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                type: &#39;add&#39;, &#x2F;&#x2F; 添加文件</span><br><span class="line">                path: &#39;src&#x2F;&#123;&#123;name&#125;&#125;&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">                templateFile: &#39;plop-templates&#x2F;static-components&#x2F;js&#x2F;index.hbs&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建模板文件</li>
</ol>
<p>可以在根目录创建模板文件，模板文件目录没有严格要求，需要与入口文件中一致,模板文件后缀名未hbs</p>
<pre style="background:#000;color: #ccc">
├ plop-templates/ ···············································  模板目录
|  └ static-components/ ·········································  静态组件目录
|     ├ css/ ····················································  css 模板文件夹
|     |  └ style.hbs ············································  css 模板
|     ├ js/ ·····················································  js 模板文件夹
|     |  └ index.hbs ············································  js 模板文件
|     └ index.hbs ···············································  html 模板文件
└ package.json
</pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; css&#x2F;style.hbs</span><br><span class="line">.&#123;&#123;name&#125;&#125; &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; index.hbs</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body class&#x3D;&quot;&#123;&#123;name&#125;&#125;&quot;&gt;</span><br><span class="line">        &#123;&#123;name&#125;&#125; body</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用plop命令快速创建组件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn plop static</span><br></pre></td></tr></table></figure>
输入组件名 home  <pre style="background:#000;color: #ccc">
$ C:\Users\admin\Desktop\plop-templates\node_modules\.bin\plop static
? static component name home
√  ++ \src\home\index.html
√  ++ \src\home\css\index.css
√  ++ \src\home\js\index.js
Done in 7.45s.
</pre>

</li>
</ol>
<p>可以看到自动创建的组件文件结构<br><img src="/20200616191859687/20200617061312210.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; home&#x2F;css&#x2F;index.css</span><br><span class="line">.home &#123;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; home&#x2F;index.html</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;home&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body class&#x3D;&quot;home&quot;&gt;</span><br><span class="line">        home body</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="脚手架原理实现"><a href="#脚手架原理实现" class="headerlink" title="脚手架原理实现"></a>脚手架原理实现</h3><p>脚手架的原理很简单，无非是将与定义的文件结构通过模板处理输出到目标文件，我们可以手动实现一个脚手架工具</p>
<ol>
<li><p>初始化项目<br>创建文件夹<code>cli-source</code><br><code>cd cli-source</code><br>初始化项目<code>yarn init</code></p>
</li>
<li><p>创建模板文件<br>根目录下创建文件夹用于存放模板文件</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; templates&#x2F;index.html</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;&lt;%&#x3D;name%&gt;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&#x2F;&#x2F; template&#x2F;style.css</span><br><span class="line">body&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建入口文件cli.js<br>安装所需依赖</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add ejs</span><br></pre></td></tr></table></figure>
<p>入口文件必须有标识</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cli.js</span></span><br><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">&#x27;inquirer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">&#x27;ejs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">inquirer.prompt([</span><br><span class="line">    &#123;</span><br><span class="line">        type: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">        message: <span class="string">&#x27;Project name?&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">])</span><br><span class="line">.then(<span class="function"><span class="params">anwser</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tml = path.join(__dirname, <span class="string">&#x27;templates&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标目录</span></span><br><span class="line">    <span class="keyword">const</span> destDir = process.cwd();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制模板文件到目标路径</span></span><br><span class="line"></span><br><span class="line">    fs.readdir(tml, <span class="function">(<span class="params">err, files</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        files.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">            ejs.renderFile(path.join(tml, file), anwser, <span class="function">(<span class="params">err, result</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line"></span><br><span class="line">                fs.writeFileSync(path.join(destDir, file), result)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>修改package.json<br>添加bin指定执行文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;bin&quot;: &quot;cli.js&quot;,</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>使用和发布<br>可以通过<code>yarn link</code>link到全局使用，或者通过<code>yarn publish</code>发布到npm</li>
</ol>
]]></content>
      <tags>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>vue虚拟dom</title>
    <url>/2020/08/27/%E8%99%9A%E6%8B%9Fdom/</url>
    <content><![CDATA[<h2 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h2><ul>
<li>避免直接操作dom，提高开发效率</li>
<li>作为中间层实现跨平台</li>
<li>复杂视图提高性能</li>
</ul>
<h3 id="h函数"><a href="#h函数" class="headerlink" title="h函数"></a>h函数</h3><p>h函数，内部会调用createElement，在core/vdom/create-element.js中定义</p>
<p>createElement接收多个参数，在调用时可以传递不同类型的参数，因此createElement函数做的事情就是判断用户传递的参数类型，并处理整合参数，传递给_createElement</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  normalizationType: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  alwaysNormalize: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 如果data是数组或者字符串</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data) || isPrimitive(data)) &#123;</span><br><span class="line">    normalizationType = children</span><br><span class="line">    children = data</span><br><span class="line">    data = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果使用户传入render函数，alwaysNormalize = true</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(alwaysNormalize)) &#123;</span><br><span class="line">    normalizationType = ALWAYS_NORMALIZE</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _createElement(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_createElement中返回VNode</p>
<ol>
<li>首先判断data存在且存在__ob__属性,警告并返回空VNode</li>
<li>接下来判断data存在且有is属性，将data.is赋值给tag（is用于动态的绑定组件<component v-bind:is="Com"/>）</li>
<li>接下来判断tag如果不存在(相当于给is指令设置了false)，返回空VNode</li>
<li>如果data属性有key且key不是原始值，发出警告</li>
<li>接下来处理插槽</li>
<li>然后判断normalizationType是2，代表用户传递的render函数，此时借助normalizeChildren对children进行处理，并赋值给children<ul>
<li>判断如果children是原始值<ul>
<li>通过createTextVNode创建文本节点并作为数组第一项返回这个数组（处理数组方便后期统一childrend的类型）</li>
</ul>
</li>
<li>如果children不是原始值，判断children是否是数组<ul>
<li>是，通过normalizeArrayChildren处理数组并返回,这个函数作用是如果children项也是数组，递归调用处理成一维数组</li>
<li>否，返回undefined</li>
</ul>
</li>
</ul>
</li>
<li>判断normalizationType是1，调用simpleMormalizeChildren处理数组并赋值给children，将children处理成一维数组</li>
<li>tag如果是字符串<ul>
<li>是字符串判断tag是否是html标签，创建VNode</li>
<li>如果是自定义组件，从context.$options.components中找到组件，并通过createComponent创建组件的VNode</li>
<li>以上都不满足，说明tag是自定义标签，创建一个VNode对象</li>
</ul>
</li>
<li>tag不是字符串说明是组件，通过createComponent创建组件VNode</li>
<li>接下来判断之前穿件vnode是否是数组<ul>
<li>是，直接返回vnode</li>
<li>否则，判断vnode是不是存在，存在的话，对vnode进行简单处理</li>
<li>以上都不满足，返回空VNode</li>
</ul>
</li>
</ol>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>vm._update方法接收通过vm._render创建好的VNode对象，_update方法内部调用了vm.__patch__方法</p>
<p>_update原理，获取vm实例上的_vnode,如果_vnode存在，说明不是首次渲染，通过__patch__对比新旧vnode；如果_vnode不存在会将vm.$el作为第一个参数传入，__patch__内部会将真实dom处理成vnode。最中__patch__返回一个真实dom,保存到vm.$el上</p>
<h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a><strong>patch</strong></h3><p>__patch__函数是通过createPatchFunction函数返回，createPatchFunction接收一个对象，返回一个patch函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">createPatchFunction(&#123;</span><br><span class="line">    nodeOps, <span class="comment">// 定义dom操作的函数</span></span><br><span class="line">    modules <span class="comment">// 模块集合attrs,klass,events,domProps,style,transition     指令，ref</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>将模块的钩子函数都保存到cbs数组中</li>
<li>返回一个patch函数<ul>
<li>判断新的VNode如果不存在，判断老VNode存在，执行Destory钩子函数</li>
<li>定义新插入vnode节点的队列</li>
<li>老vnode不存在（$mount方法调用没有传递挂载位置时）,创建节点到内存中</li>
<li>老vnode存在<ul>
<li>如果oldVnode.nodeType不存在，并且oldVnode和newVnode是sameVnode，通过patchVnode更新</li>
<li>如果上一条件不成立<ul>
<li>判断是否存在oldVnode.nodeType,如果存在说明是首次渲染,通过emptyNodeAt返回值赋值给oldVnode.elm,将真实dom转换成虚拟dom</li>
</ul>
</li>
<li>获取oldelm,获取parentElm</li>
<li>通过createElm,将newvnode转换成dom，挂载到parentElm上,插入到oldElm之前，并把newVnode记录到insertedVnodeQueue</li>
<li>判断parentEle是否存在，存在的话通过removeVnodes删除oldVnode并触发钩子函数</li>
<li>如果parentEle不存在，且oldVnode存在tag属性，触发destroy钩子</li>
</ul>
</li>
<li>如果挂载到了dom上触发insertedVnodeQueue队列中的所有insert钩子</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>虚拟dom</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6</title>
    <url>/2020/08/26/ES6/</url>
    <content><![CDATA[<h2 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h2><h3 id="块级作用域let、const"><a href="#块级作用域let、const" class="headerlink" title="块级作用域let、const"></a>块级作用域let、const</h3><p>使用let和const定义的值都会产生块级作用域，这两种方式声明的变量只能在所声明的代码块中被访问。<br>const声明的变量是只读的，不可以修改内存地址</p>
<h4 id="块级作用域的应用场景"><a href="#块级作用域的应用场景" class="headerlink" title="块级作用域的应用场景"></a>块级作用域的应用场景</h4><p>循环计数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 块级作用域应用于双重循环的计数器</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0,1,2  0,1,2  0,1,2</span></span><br><span class="line"><span class="comment">// 两层循环的i不会互相影响，实际开发中这样使用不便于理解维护</span></span><br></pre></td></tr></table></figure>

<p>闭包应用场景</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环绑定事件时，使用var定义计数器，最终点击事件打印的i都是最终i的值，因为i存在于全局环境被所有点击事件共用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line">    element[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="let-var-const-三者的区别"><a href="#let-var-const-三者的区别" class="headerlink" title="let,var,const 三者的区别"></a>let,var,const 三者的区别</h4><ol>
<li>var声明的变量不存在块级作用域，并且存在<strong>变量提升</strong>，在变量声明之前使用可以取到一个undefined的值。</li>
<li>与var不同，let在声明之前使用会报错，这一特性称为<strong>暂时性死区</strong>，这也导致typeof不是绝对安全的操作，这种特性是为了让开发者养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</li>
<li>在最外层作用域生命的var变量会挂载到全局对象上，let和const声明的变量存在块级作用域，不会挂在到全局对象上。</li>
<li>let变量值可以随意赋值，const的值不允许改变，因此const在定义时必须初始化</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;vara&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;window.a: &#x27;</span>, <span class="built_in">window</span>.a); <span class="comment">// vara</span></span><br><span class="line"><span class="comment">// 在最外层声明的var变量会挂载到全局对象window上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&#x27;letb&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;window.b: &#x27;</span>, <span class="built_in">window</span>.b); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    c = <span class="string">&#x27;bar_c&#x27;</span>; <span class="comment">// 没有声明的变量直接赋值，不管是在函数内部还是全局，都会挂载到window上</span></span><br><span class="line">    <span class="keyword">var</span> d = <span class="string">&#x27;bar_d&#x27;</span>; <span class="comment">// 函数内部var定义的变量，只在函数作用域中可以被访问</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        e = <span class="string">&#x27;foo_e&#x27;</span>;</span><br><span class="line">        <span class="keyword">var</span> f = <span class="string">&#x27;foo_f&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    foo();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;e: &#x27;</span>, e); <span class="comment">// foo_e</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;window.e: &#x27;</span>, <span class="built_in">window</span>.e) <span class="comment">// foo_e</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;f: &#x27;</span>, f); <span class="comment">// test.html:24 Uncaught ReferenceError: f is not defined</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;window.c: &#x27;</span>, <span class="built_in">window</span>.c); <span class="comment">// bar_c</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;c: &#x27;</span>, c); <span class="comment">// bar_C</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;window.d: &#x27;</span>, <span class="built_in">window</span>.d); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// console.log(&#x27;d: &#x27;, d); // Uncaught ReferenceError: d is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;e: &#x27;</span>, e); <span class="comment">// foo_e</span></span><br></pre></td></tr></table></figure>

<h3 id="解构（Destructuring）"><a href="#解构（Destructuring）" class="headerlink" title="解构（Destructuring）"></a>解构（Destructuring）</h3><p>按照一定模式，从数组和对象中提取值，对变量进行赋值</p>
<h4 id="对象的解构"><a href="#对象的解构" class="headerlink" title="对象的解构"></a>对象的解构</h4><p>对象解构语法是在赋值对象的左侧使用了对象字面量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;along&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;name&#125; = obj; <span class="comment">// 同名变量解构赋值</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">name</span>: newName&#125; = obj; <span class="comment">// 不同变量解构赋值</span></span><br><span class="line"><span class="comment">// newName = along</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构同时赋默认值</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">age</span>: newAge = <span class="number">24</span>&#125; = obj;</span><br><span class="line"><span class="comment">// newAge = 24;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化代码</span></span><br><span class="line"><span class="keyword">const</span> &#123;log&#125; = <span class="built_in">console</span>;</span><br></pre></td></tr></table></figure>
<h4 id="数组的解构"><a href="#数组的解构" class="headerlink" title="数组的解构"></a>数组的解构</h4><p>数组解构时，解构作用在数组内部的位置上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> [a, b, c] = arr;</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, ...b] = arr;</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构时附默认值</span></span><br><span class="line"><span class="keyword">const</span> [a, b, c, d = <span class="number">4</span>] = arr;</span><br><span class="line"><span class="comment">// d = 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="string">&#x27;2020/12/20&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> [, month] = path.split(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="comment">// month = 12</span></span><br></pre></td></tr></table></figure>


<h3 id="模板字符串-Template-literals"><a href="#模板字符串-Template-literals" class="headerlink" title="模板字符串 (Template literals)"></a>模板字符串 (Template literals)</h3><p>模板字面量是允许嵌入表达式的字符串字面量。可以使用多行字符串和字符串插值功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">    可以支持换行</span></span><br><span class="line"><span class="string">    可以支持插值，使用表达式</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;name&#125;</span></span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;<span class="number">1</span>+<span class="number">1</span>&#125;</span></span></span><br><span class="line"><span class="string">`</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符标签函数</span></span><br><span class="line"><span class="comment">// 该用法会返回字符串数组和所有的插入值</span></span><br><span class="line"><span class="built_in">console</span>.log<span class="string">`hello <span class="subst">$&#123;<span class="string">&#x27;along&#x27;</span>&#125;</span> age <span class="subst">$&#123;<span class="number">23</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// [&#x27;hello &#x27;, &#x27; age &#x27;], &#x27;along&#x27;, 23</span></span><br><span class="line">alert<span class="string">``</span>hello $&#123;<span class="string">&#x27;along&#x27;</span>&#125; age $&#123;<span class="number">23</span>&#125;<span class="string">`</span></span><br><span class="line"><span class="string">// [&#x27;hello &#x27;, &#x27; age &#x27;] </span></span><br></pre></td></tr></table></figure>

<h3 id="字符串拓展方法"><a href="#字符串拓展方法" class="headerlink" title="字符串拓展方法"></a>字符串拓展方法</h3><h4 id="includes、startsWith、endsWith"><a href="#includes、startsWith、endsWith" class="headerlink" title="includes、startsWith、endsWith"></a>includes、startsWith、endsWith</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello along&#x27;</span></span><br><span class="line">includes(<span class="string">&#x27;alo&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">startsWith(<span class="string">&#x27;he&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">endsWith(<span class="string">&#x27;along&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="参数默认值（Default-parameters）"><a href="#参数默认值（Default-parameters）" class="headerlink" title="参数默认值（Default parameters）"></a>参数默认值（Default parameters）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">a = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a + <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add1() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="展开数组-Spread"><a href="#展开数组-Spread" class="headerlink" title="展开数组 Spread"></a>展开数组 Spread</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// console.log.apply(console, arr)</span></span><br><span class="line"><span class="built_in">console</span>.log(...arr);</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数（Arrow-functions）"><a href="#箭头函数（Arrow-functions）" class="headerlink" title="箭头函数（Arrow functions）"></a>箭头函数（Arrow functions）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简化代码</span></span><br><span class="line"><span class="keyword">const</span> add1 = <span class="function"><span class="params">num</span> =&gt;</span> num + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this指向</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;along&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> people = &#123;</span><br><span class="line">    name: <span class="string">&#x27;peoplename&#x27;</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    fn2: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">people.fn(); <span class="comment">// peoplename</span></span><br><span class="line">people.fn2(); <span class="comment">// &quot;&quot;  fn2 中的 this 指向 window 而不是 全局作用域的name</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，箭头含数arguments 指向的对象并不是当前函数所属的argments，而是上级函数的arguments</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(<span class="number">1</span>,<span class="number">2</span>)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Arguments] &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2 &#125;</span></span><br><span class="line"><span class="comment">// [Arguments] &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="对象字面量增强（Enhanced-object-literals）"><a href="#对象字面量增强（Enhanced-object-literals）" class="headerlink" title="对象字面量增强（Enhanced object literals）"></a>对象字面量增强（Enhanced object literals）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象属性值简略写法</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;along&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name,</span><br><span class="line">    <span class="comment">// 函数的简写，注意这种方式同 </span></span><br><span class="line">    <span class="comment">// fn: function() &#123;console.log(this.name)&#125;</span></span><br><span class="line">    <span class="comment">// 其中的this取决于它的调用者</span></span><br><span class="line">    fn() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 计算属性名</span></span><br><span class="line">    [<span class="number">1</span>+<span class="number">2</span>]: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象扩展方法"><a href="#对象扩展方法" class="headerlink" title="对象扩展方法"></a>对象扩展方法</h3><h4 id="object-assign"><a href="#object-assign" class="headerlink" title="object.assign"></a>object.assign</h4><p>object.assign 将源对象中的属性复制到目标对象中  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123;</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;<span class="attr">b</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">const</span> res = <span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">res === target <span class="comment">// true  </span></span><br></pre></td></tr></table></figure>
<p>将对象传给函数进行属性操作时，为了避免对原对象修改，在函数内部复制新的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;along&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">tar</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 参数是对象时tar是一个引用地址，指向参数的对象地址</span></span><br><span class="line">    <span class="comment">// 直接操作tar会改变参数的属性</span></span><br><span class="line">    <span class="comment">// tar.name = &#x27;new along&#x27;;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> newobj = <span class="built_in">Object</span>.assign(&#123;&#125;, tar);</span><br><span class="line">    newobj.name = <span class="string">&#x27;new along&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(newobj);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(obj); <span class="comment">// &#123;name: &#x27;new along&#x27;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: &#x27;along&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以通过Object.assign()为对象参数设置默认值、</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> defaultparams = &#123;</span><br><span class="line">        page: <span class="number">1</span>,</span><br><span class="line">        pagesize: <span class="number">10</span>,</span><br><span class="line">        method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> params = <span class="built_in">Object</span>.assign(&#123;&#125;, option, defaultparams);</span><br><span class="line">    <span class="built_in">console</span>.log(params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> option = &#123;</span><br><span class="line">    method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    url: <span class="string">&#x27;localhost:8080&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(option)</span><br></pre></td></tr></table></figure>

<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>判断两个值是否相等 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>); <span class="comment">// false   </span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">    get(target, property) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(target, property);</span><br><span class="line">        <span class="keyword">return</span> property <span class="keyword">in</span> target ? target[property] : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, property, value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (property === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`age must be a number but <span class="subst">$&#123;value&#125;</span> [<span class="subst">$&#123;<span class="keyword">typeof</span> value&#125;</span>]`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        target[property] = value;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(personProxy.name);</span><br><span class="line"><span class="comment">// &#123; name: &#x27;along&#x27;, age: 20 &#125; name</span></span><br><span class="line"><span class="comment">// along</span></span><br><span class="line"><span class="built_in">console</span>.log(personProxy.bb);</span><br><span class="line"><span class="comment">// &#123; name: &#x27;along&#x27;, age: 20 &#125; bb</span></span><br><span class="line"><span class="comment">// -</span></span><br><span class="line">personProxy.age = <span class="string">&#x27;20&#x27;</span></span><br><span class="line"><span class="comment">// throw new TypeError(`age must be a number but $&#123;value&#125; [$&#123;typeof value&#125;]`);</span></span><br><span class="line"><span class="comment">// ^</span></span><br><span class="line"><span class="comment">// TypeError: age must be a number but 20 [string]</span></span><br></pre></td></tr></table></figure>

<p>vue 3.0 开始使用proxy 实现内部数据的相应</p>
<h4 id="Proxy-与-Object-defineProperty-比较"><a href="#Proxy-与-Object-defineProperty-比较" class="headerlink" title="Proxy 与 Object.defineProperty 比较"></a>Proxy 与 Object.defineProperty 比较</h4><p>defineProperty  只能监视对象的读取和写入 Proxy 可以监视一些 defineProperty  监视不到的行为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">     deleteProperty(target, property) &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&#x27;delete&#x27;</span>, property);</span><br><span class="line">         <span class="keyword">delete</span> target[property];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> personProxy.name;</span><br><span class="line"><span class="built_in">console</span>.log(personProxy);</span><br><span class="line"><span class="comment">// delete name</span></span><br><span class="line"><span class="comment">// &#123; age: 20 &#125;</span></span><br></pre></td></tr></table></figure>

<p>除了删除操作之外，可操作的行为见下表</p>
<img src="/2020/08/26/ES6/clipboard.png" class="">

<h4 id="借助Proxy监视数组操作"><a href="#借助Proxy监视数组操作" class="headerlink" title="借助Proxy监视数组操作"></a>借助Proxy监视数组操作</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> listProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(list, &#123;</span><br><span class="line">    set(target, property, value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(target, property, value); </span><br><span class="line">        target[property] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 需要返回true表示操作成功</span></span><br><span class="line">    &#125;,</span><br><span class="line">    deleteProperty(target, property) &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&#x27;delete&#x27;</span>, property);</span><br><span class="line">         <span class="keyword">delete</span> target[property];</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 需要返回true表示操作成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">listProxy.push(<span class="number">1</span>); <span class="comment">// push 操作会至少触发两次set</span></span><br><span class="line"><span class="comment">// [] 0 1</span></span><br><span class="line"><span class="comment">// [ 1 ] length 1</span></span><br><span class="line">listProxy.push(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// [ 1 ] 1 2</span></span><br><span class="line"><span class="comment">// [ 1, 2 ] length 2</span></span><br><span class="line">listProxy.push(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// [ 1, 2 ] 2 3</span></span><br><span class="line"><span class="comment">// [ 1, 2, 3 ] length 3</span></span><br><span class="line">listProxy.push(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// [ 1, 2, 3 ] 3 4</span></span><br><span class="line"><span class="comment">// [ 1, 2, 3, 4 ] length 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里执行到shift时，会首先出发三次set，讲数组最后的三个元素前移，</span></span><br><span class="line"><span class="comment">// 然后触发删除操作</span></span><br><span class="line"><span class="comment">// 最后再次触发 set 的操作修改length</span></span><br><span class="line">listProxy.shift(); </span><br><span class="line"><span class="comment">// [ 1, 2, 3, 4 ] 0 2</span></span><br><span class="line"><span class="comment">// [ 2, 2, 3, 4 ] 1 3</span></span><br><span class="line"><span class="comment">// [ 2, 3, 3, 4 ] 2 4</span></span><br><span class="line"><span class="comment">// delete 3</span></span><br><span class="line"><span class="comment">// [ 2, 3, 4, &lt;1 empty item&gt; ] length 3</span></span><br></pre></td></tr></table></figure>
<h4 id="Proxy-以非侵入的方式监管对象读写"><a href="#Proxy-以非侵入的方式监管对象读写" class="headerlink" title="Proxy 以非侵入的方式监管对象读写"></a>Proxy 以非侵入的方式监管对象读写</h4><p>defineProperty 需要通过监听特定的属性，如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;along&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> person._name;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;name 被修改&#x27;</span>);</span><br><span class="line">        person._name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line">person.name = <span class="string">&#x27;along&#x27;</span>;</span><br><span class="line"><span class="comment">// name 被修改</span></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br><span class="line"><span class="comment">// &#123; name: [Getter/Setter], _name: &#x27;along&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name)</span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="comment">// along</span></span><br></pre></td></tr></table></figure>

<p>从以上代码可以看出，defineProperty方式会修改被监控的对象本身，读取写入操作需要借助辅助内存空间来保存真实值</p>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>静态类，不能用new操作符<br>Reflect 内部封装了一系列对对象的底层操作<br>Reflect 成员方法就是Proxy处理对象的默认实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">    <span class="comment">// 在不设置 get 方法时，相当于返回 Reflect.get(target, property);</span></span><br><span class="line">    get (target, property) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(personProxy.name)</span><br></pre></td></tr></table></figure>

<h4 id="统一操作对象的API"><a href="#统一操作对象的API" class="headerlink" title="统一操作对象的API"></a>统一操作对象的API</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">    age: <span class="number">24</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="built_in">Reflect</span>.has(person, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// true  相当于  &#x27;name&#x27; in person</span></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(person, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// 相当于 delete person[&#x27;name&#x27;] | delete person.name</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(person);</span><br><span class="line"><span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;]  相当于  person.keys();</span></span><br></pre></td></tr></table></figure>

<h3 id="Classes-类"><a href="#Classes-类" class="headerlink" title="Classes 类"></a>Classes 类</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    say () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> say`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;along&#x27;</span>);</span><br><span class="line">person.say();</span><br><span class="line"><span class="comment">// along say</span></span><br></pre></td></tr></table></figure>

<h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><ul>
<li>实例方法（通过实例调用）实例方法中的this指向实例</li>
<li>静态方法（通过类本身调用）静态方法中的this指向类本身</li>
</ul>
<h4 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    say () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> say`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> create (name) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = Person.create(<span class="string">&#x27;along&#x27;</span>);</span><br><span class="line"><span class="comment">// [Function: Person]</span></span><br><span class="line">person.say();</span><br><span class="line"><span class="comment">// Person &#123; name: &#x27;along&#x27; &#125;</span></span><br><span class="line"><span class="comment">// along say</span></span><br></pre></td></tr></table></figure>

<h3 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承 extends"></a>继承 extends</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    say () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> say`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> create (name) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">        <span class="comment">// return new this(name); 可以使用new this , </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, schoolname)&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.schoolname = schoolname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    welcome() &#123;</span><br><span class="line">        <span class="built_in">super</span>.say();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`from <span class="subst">$&#123;<span class="built_in">this</span>.schoolname&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> along = <span class="keyword">new</span> Student(<span class="string">&#x27;along&#x27;</span>, <span class="string">&#x27;黑科技&#x27;</span>);</span><br><span class="line">along.welcome()</span><br><span class="line"><span class="comment">// Student &#123; name: &#x27;along&#x27;, schoolname: &#x27;黑科技&#x27; &#125;</span></span><br><span class="line"><span class="comment">// along say</span></span><br><span class="line"><span class="comment">// from 黑科技</span></span><br><span class="line"><span class="built_in">console</span>.log(Student.create(<span class="string">&#x27;along&#x27;</span>));</span><br><span class="line"><span class="comment">// [Function: Student]                  Student继承的Person的静态方法，this指向Student类</span></span><br><span class="line"><span class="comment">// Person &#123; name: &#x27;along&#x27; &#125;            </span></span><br></pre></td></tr></table></figure>

<h3 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h3><p>不重复元素的集合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"><span class="comment">// Set &#123; 1, 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 不能用 for in, 不能用下标取值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者 forEach</span></span><br><span class="line">s.forEach(<span class="function"><span class="params">l</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(l);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Set 长度</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;size&#x27;</span>, s.size);</span><br><span class="line"><span class="comment">// size 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否存在某个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(s.has(<span class="number">100</span>));</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除某个元素，删除成功返回true，失败即本来不存在返回false</span></span><br><span class="line"><span class="built_in">console</span>.log(s.delete(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">s.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)); <span class="comment">// [...new Set(arr)]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<h3 id="Map-数据结构，映射两个任意类型数据之间的关系"><a href="#Map-数据结构，映射两个任意类型数据之间的关系" class="headerlink" title="Map 数据结构，映射两个任意类型数据之间的关系"></a>Map 数据结构，映射两个任意类型数据之间的关系</h3><p>可以使用任何数据作为键，普通对象只能用字符串作为键</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> along = &#123;<span class="attr">name</span>: <span class="string">&#x27;along&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(along, <span class="number">25</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map)</span><br><span class="line"><span class="comment">// Map &#123; &#123; name: &#x27;along&#x27; &#125; =&gt; 25 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(along))</span><br><span class="line"><span class="comment">// 25</span></span><br><span class="line">map.has(along); <span class="comment">// 查看是否存在键  返回true</span></span><br><span class="line">map.delete(along); <span class="comment">// 返回删除结果</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">map.clear() <span class="comment">// 清空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 forEach 获取 for of </span></span><br><span class="line">map.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, key)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Symbol-第七个数据类型，-esmascript-2017-第八个数据类型BigInt"><a href="#Symbol-第七个数据类型，-esmascript-2017-第八个数据类型BigInt" class="headerlink" title="Symbol  第七个数据类型，(esmascript 2017 第八个数据类型BigInt)"></a>Symbol  第七个数据类型，(esmascript 2017 第八个数据类型BigInt)</h3><p>可以避免属性名冲突，为对象定义独一无二的属性名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>() === <span class="built_in">Symbol</span>() <span class="comment">// false </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">// symbol</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;[<span class="built_in">Symbol</span>()]: <span class="number">123</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123; [Symbol()]: 123 &#125;</span></span><br></pre></td></tr></table></figure>

<p>用于模拟对象私有成员,在对象内部由于缓存了Symbol的索引，可以对Symbol属性进行操作，在对象外部由于拿不到Symbol的索引所以无法对属性访问</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    [name]: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">    say() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>[name]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>全局使用相同的Symbol时,可以通过Symbol.for() 传入字符串，Symbol内部维护了字符串和Symbol的对应关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// 相当于  const s1 = Symbol(); // const s2 = s1;</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> strtrue = <span class="built_in">Symbol</span>(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> booltrue = <span class="built_in">Symbol</span>(<span class="literal">true</span>);</span><br><span class="line">strtrue === booltrue <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>

<p>Symbol内置常量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toStringTag]: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.toString())</span><br><span class="line"><span class="comment">// [object along]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取Symbol属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Symbol 属性通过    for in ，Object.keys(), JSON.stringify(), 都会被忽略</span></span><br><span class="line"><span class="comment">// 可以通过  getOwnPropertySymbols 获取Symbol的keys</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&#x27;name&#x27;</span>)]: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj));</span><br><span class="line"><span class="comment">// [ Symbol(name) ]</span></span><br></pre></td></tr></table></figure>

<h3 id="for-of-循环，"><a href="#for-of-循环，" class="headerlink" title="for of 循环，"></a>for of 循环，</h3><p>可以作为遍历所有数据结构的统一方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">    <span class="keyword">if</span> (item === <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for of 循环可以通过 break 跳出循环  ， forEach  map 等方式无法跳出循环， 需要跳出循环需要通过arr.some，arr.every方法</span></span><br></pre></td></tr></table></figure>

<p>Map对象通过for of 遍历返回数组，第一个值是键，第二个值是值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(&#123;<span class="attr">name</span>: <span class="string">&#x27;along&#x27;</span>&#125;, <span class="number">25</span>);</span><br><span class="line">map.set(<span class="string">&#x27;school&#x27;</span>, <span class="string">&#x27;黑科&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; name: &#x27;along&#x27; &#125; 25</span></span><br><span class="line"><span class="comment">// school 黑科</span></span><br></pre></td></tr></table></figure>

<p>通过for of 遍历对象， 会发现报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">    age: <span class="number">24</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: person is not iterable</span></span><br></pre></td></tr></table></figure>


<p>通过浏览器控制台打印数组、Set、 Map 等对象会发现，他们的原型上都存在 [Symbol(Symbol.iterator)]属性</p>
<img src="/2020/08/26/ES6/iterator.png" class="">

<p>通过调用iterator查看结果，这里以数组为例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> iterator = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>][<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实现可迭代接口 iterable</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> iterable = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// iterator</span></span><br><span class="line">        next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// iterationResult</span></span><br><span class="line">            <span class="keyword">const</span> iterationResult = &#123;</span><br><span class="line">                value: keys[index],</span><br><span class="line">                done: index &gt;= keys.length,</span><br><span class="line">            &#125;</span><br><span class="line">            index ++;</span><br><span class="line">            <span class="keyword">return</span> iterationResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    <span class="comment">// 实现iterable 接口</span></span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: iterable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代器模式-让用户通过特定的接口访问容器的数据，不需要了解容器内部的数据结构。"><a href="#迭代器模式-让用户通过特定的接口访问容器的数据，不需要了解容器内部的数据结构。" class="headerlink" title="迭代器模式 让用户通过特定的接口访问容器的数据，不需要了解容器内部的数据结构。"></a>迭代器模式 让用户通过特定的接口访问容器的数据，不需要了解容器内部的数据结构。</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">const</span> todos = &#123;</span><br><span class="line">    life: [<span class="string">&#x27;工作&#x27;</span>, <span class="string">&#x27;坐公交&#x27;</span>],</span><br><span class="line">    learn: [<span class="string">&#x27;ES6&#x27;</span>, <span class="string">&#x27;typescript&#x27;</span>],</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> keys = [].concat(<span class="built_in">this</span>.life, <span class="built_in">this</span>.learn);</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> iterationResult = &#123;</span><br><span class="line">                    value: keys[index],</span><br><span class="line">                    done: index &gt;= keys.length,</span><br><span class="line">                &#125;</span><br><span class="line">                index ++;</span><br><span class="line">                <span class="keyword">return</span> iterationResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> todos) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 Generator"></a>生成器 Generator</h3><p>解决异步函数嵌套问题，从而提供更好的异步编程解决方案</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;along&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gen = fn();</span><br><span class="line"><span class="built_in">console</span>.log(gen);</span><br><span class="line"><span class="comment">// Object [Generator] &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next())</span><br><span class="line"><span class="comment">// along</span></span><br><span class="line"><span class="comment">// &#123; value: 100, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>生成器函数可以自动返回一个生成器对象，生成器函数内部的逻辑会惰性执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;22&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gen = fn();</span><br><span class="line"><span class="built_in">console</span>.log(gen.next())</span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// &#123; value: 100, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next())</span><br><span class="line"><span class="comment">// 22</span></span><br><span class="line"><span class="comment">// &#123; value: 200, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next())</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="生成器应用"><a href="#生成器应用" class="headerlink" title="生成器应用"></a>生成器应用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发号器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> id ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gen = fn();</span><br><span class="line"><span class="built_in">console</span>.log(gen.next())</span><br><span class="line"><span class="built_in">console</span>.log(gen.next())</span><br><span class="line"><span class="built_in">console</span>.log(gen.next())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用生成器简化迭代器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">const</span> todos = &#123;</span><br><span class="line">    life: [<span class="string">&#x27;工作&#x27;</span>, <span class="string">&#x27;坐公交&#x27;</span>],</span><br><span class="line">    learn: [<span class="string">&#x27;ES6&#x27;</span>, <span class="string">&#x27;typescript&#x27;</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [Symbol.iterator]: function () &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     const keys = [].concat(this.life, this.learn);</span></span><br><span class="line">    <span class="comment">//     let index = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return &#123;</span></span><br><span class="line">    <span class="comment">//         next: function () &#123;</span></span><br><span class="line">    <span class="comment">//             const iterationResult = &#123;</span></span><br><span class="line">    <span class="comment">//                 value: keys[index],</span></span><br><span class="line">    <span class="comment">//                 done: index &gt;= keys.length,</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             index ++;</span></span><br><span class="line">    <span class="comment">//             return iterationResult;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> keys = [].concat(<span class="built_in">this</span>.life, <span class="built_in">this</span>.learn);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> keys) &#123;</span><br><span class="line">            <span class="keyword">yield</span> item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> todos) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h2><h3 id="数组方法includs"><a href="#数组方法includs" class="headerlink" title="数组方法includs"></a>数组方法includs</h3><p>在ES2016之前需要通过indexOf 返回的下表来判断，但是这种方式也存在一些问题，比如不能查找数组中的NaN</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="number">1</span>, <span class="literal">NaN</span>, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line">arr.indexOf(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line">arr.indexOf(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line">arr.indexOf(<span class="literal">NaN</span>);</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">arr.includes(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">arr.includes(<span class="literal">NaN</span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 1024</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 1024</span></span><br></pre></td></tr></table></figure>

<h2 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h2><p>Object.values 返回对象的值数组<br>Object.entries 返回对象键值对数组<br>Object.getOwnPropertyDescriptors 获取属性描述符，可以通过拷贝属性描述符拷贝getter、setter<br>padEnd 、 padStart  使用指定字符串填充字符串使其达到目标长度<br>参数列表尾逗号， 便于代码修改时参数扩充<br>Async/Await  Promise语法糖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">    age: <span class="string">&#x27;24&#x27;</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>()]: <span class="number">123</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.values(person);</span><br><span class="line"><span class="comment">// [ &#x27;along&#x27;, &#x27;24&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.entries(person)</span><br><span class="line"><span class="comment">// [ [ &#x27;name&#x27;, &#x27;along&#x27; ], [ &#x27;age&#x27;, &#x27;24&#x27; ] ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.entries([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// [ [ &#x27;0&#x27;, 1 ], [ &#x27;1&#x27;, 2 ], [ &#x27;2&#x27;, 3 ] ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> description = <span class="built_in">Object</span>.getOwnPropertyDescriptors(person);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   name: &#123;</span></span><br><span class="line"><span class="comment">//     value: &#x27;along&#x27;,</span></span><br><span class="line"><span class="comment">//     writable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     configurable: true</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   age: &#123; value: &#x27;24&#x27;, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   [Symbol()]: &#123; value: 123, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(person)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key.padEnd(<span class="number">16</span>, <span class="string">&#x27;-&#x27;</span>)&#125;</span>|<span class="subst">$&#123;value.padStart(<span class="number">10</span>, <span class="string">&#x27;-&#x27;</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name------------|-----along</span></span><br><span class="line"><span class="comment">// age-------------|--------24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数列表尾逗号</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    name,</span></span></span><br><span class="line"><span class="function"><span class="params">    age,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>notes</tag>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>redux</title>
    <url>/2021/01/14/redux/</url>
    <content><![CDATA[<h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><h4 id="bindActionCreators更优雅地创建mapDispatchToProps-函数"><a href="#bindActionCreators更优雅地创建mapDispatchToProps-函数" class="headerlink" title="bindActionCreators更优雅地创建mapDispatchToProps 函数"></a>bindActionCreators更优雅地创建mapDispatchToProps 函数</h4><p>编写好 <code>actionCreator </code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const onAdd &#x3D; (num) &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type: ADDNUM,</span><br><span class="line">        num,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const onDelete &#x3D; (num) &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type: DELETENUM,</span><br><span class="line">        num,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入 <code>bindActionCreators</code>和 <code>actionCreator.js</code>中的所有方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;bindActionCreators&#125; from &#39;redux&#39;;</span><br><span class="line">import * as actionCreators from &#39;.&#x2F;redux&#x2F;action&#39;;</span><br></pre></td></tr></table></figure>

<p>通过<code>bindActiionCreators</code> 生成<code>mapDispatchToProps</code>的返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mapDispatchToProps &#x3D; dispatch &#x3D;&gt; bindActionCreators(actionCreators, dispatch);</span><br><span class="line"></span><br><span class="line">export default connect(null, mapDispatchToProps)(Conmponent); </span><br></pre></td></tr></table></figure>

<p>这样就可以直接在组建<code>Component</code>中使用<code>actionCreator.js</code>中定义的同名方法啦</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function (&#123;onAdd, onDelete&#125;) &#123;</span><br><span class="line">	return ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="redux-定义中间件"><a href="#redux-定义中间件" class="headerlink" title="redux 定义中间件"></a>redux 定义中间件</h4><p>1、定义一个中间件需要创建一个函数,满足下面的格式，其中最外层store可以去到<strong>getState</strong> 、<strong>dispatch</strong>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default store &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这里我定义一个打印日志的中间件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default store &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;</span><br><span class="line">	console.log(action);</span><br><span class="line">	next(action); &#x2F;&#x2F; 传递给下一个中间件或者reducer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、注册中间件,通过<code>applyMiddleware</code>注册中间件,多个中间件可以依次传入，中间件执行顺序与注册顺序相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;createStore, applyMiddleware&#125; from &#39;redux&#39;;</span><br><span class="line">import logMiddleWare from &#39;.&#x2F;middlewares&#x2F;logMiddleWare&#39;;</span><br><span class="line"></span><br><span class="line">export default createStore(reducer, applyMiddleware(</span><br><span class="line">	logMiddleWare &#x2F;&#x2F; 如果有多个中间件 middleware1, middleware2, ...</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<p>如果项目中使用了<strong>redux-devtools-extension</strong>，可以这样写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;composeWithDevTools&#125; from &#39;redux-devtools-extension&#39;; &#x2F;&#x2F; 用于开发环境浏览器插件调试</span><br><span class="line">export default createStore(reducer, composeWithDevTools(applyMiddleware(logMiddleWare)));</span><br></pre></td></tr></table></figure>

<p>3、定义一个处理异步的中间件(redux-thunk 机制)</p>
<p>上述代码中的<strong>actionCreators.js</strong>编写的<strong>action</strong>都是返回一个对象，包含了<strong>action</strong>的类型和数据，如果要编写一个异步的<strong>action</strong>怎么办呢</p>
<p>我们可以编写一个中间件，在接收<strong>actionCreator</strong>的返回值是判断返回值<strong>action</strong>得类型，如果是普通的携带<strong>type</strong>的对象，就直接放行。如果类型是一个函数，我们就认为他是一个异步动作，执行这个函数并将<strong>dispatch</strong>函数传递给它，将执行权交给这个异步函数，由他来决定派发下一个<strong>actionCreator</strong>的时机</p>
<p>我们在<strong>actionCreators.js</strong>中编写一个异步的<strong>actionCreator</strong>,它返回一个函数，并且在这个函数中异步的调用了其他的<strong>actionCreator</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const onAdd &#x3D; (num) &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type: ADDNUM,</span><br><span class="line">        num,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 异步函数返回一个函数，派发了其他的actionCreator</span><br><span class="line">export const onAdd_async &#x3D; (num) &#x3D;&gt; &#123;</span><br><span class="line">    return (dispatch) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">           dispatch(</span><br><span class="line">               onAdd(num)</span><br><span class="line">           ) </span><br><span class="line">        &#125;, 5000)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来定义一个中间件，用来处理异步的<strong>action</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default store &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;</span><br><span class="line">	if (typeof action &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        action(store.dispatch);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 正常的情况（action是一个对象）直接放行</span><br><span class="line">	next(action); &#x2F;&#x2F; 传递给下一个中间件或者reducer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后在<strong>creatStore</strong>时注册这个异步中间件就可以了</p>
<h4 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h4><p><strong>redux-saga</strong>允许我们将异步<strong>actionCreator</strong>单独抽离出来，方便我们统一维护</p>
<p>1、编写<strong>saga</strong>抽离的函数文件 ,<strong>post.saga.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;takeEvery, put&#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">async_add</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> result = <span class="keyword">yield</span> axios.get(<span class="string">&#x27;/api/add&#x27;</span>, &#123;<span class="attr">num</span>:action.num&#125;);</span><br><span class="line">   	<span class="keyword">if</span> (result.code === <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">yield</span> put(add_num_success(num:action.num)); <span class="comment">// put相当于dispatch，通过put执行普通的action给reducer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// saga要求默认导出generator函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> funciton* postSaga() &#123;</span><br><span class="line">	<span class="keyword">yield</span> takeEvery(ASYNC_ADDNUM, async_add)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、安装引入启用并注册 <strong>redux-saga</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import createSagaMiddleware from &#39;redux-saga&#39;;</span><br><span class="line">import postSaga form &#39;.&#x2F;store&#x2F;saga&#x2F;post.saga.js&#39;; &#x2F;&#x2F; 引入编写的saga文件</span><br><span class="line"></span><br><span class="line">const sagaMiddleware &#x3D; createSagaMiddleware();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">export default createStore(reducer, applyMiddleware(sagaMiddleware))</span><br><span class="line"></span><br><span class="line">sagaMiddleware.run(postSaga); &#x2F;&#x2F; 启用saga</span><br></pre></td></tr></table></figure>

<p>3、拆分saga文件</p>
<p>实际工作中我们需要把异步拆分到多个<strong>saga</strong>文件中，便于维护。因此这里再编写一个<strong>saga</strong>文件<strong>logout.saga.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;takeEvery, put, delay&#125; from &#39;redux-saga&#x2F;effects&#39;;</span><br><span class="line"></span><br><span class="line">function* async_logout () &#123;</span><br><span class="line">	yield delay(2000); </span><br><span class="line">	yield put(logout());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; saga要求默认导出generator函数</span><br><span class="line">export default funciton* logoutSaga() &#123;</span><br><span class="line">	yield takeEvery(LOGOUT, async_logout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个统一的入口<strong>saga</strong>文件<strong>root.saga.js</strong>中合并并导出<strong>saga</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;all&#125; from &#39;redux-saga&#x2F;effects&#39;;</span><br><span class="line"></span><br><span class="line">import postSaga from &#39;.&#x2F;post.saga.js&#39;;</span><br><span class="line">import logoutSaga from &#39;.&#x2F;logout.saga.js&#39;;</span><br><span class="line"></span><br><span class="line">export default function* rootSaga() &#123;</span><br><span class="line">	yield all([</span><br><span class="line">		postSaga(),</span><br><span class="line">		logoutSaga()</span><br><span class="line">	])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来再注册<strong>saga</strong>时只需要注册<strong>rootSaga</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import rootSaga form &#39;.&#x2F;store&#x2F;saga&#x2F;root.saga.js&#39;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">sagaMiddleware.run(rootSaga); &#x2F;&#x2F; 启用saga</span><br></pre></td></tr></table></figure>

<h4 id="redux-actions"><a href="#redux-actions" class="headerlink" title="redux-actions"></a>redux-actions</h4><p><strong>redux</strong> 流程存在大量样板代码，比如<strong>actionType</strong>的抽离,<strong>redux-actions</strong>可以帮助我们简化代码</p>
<p>1、创建<strong>actionCreator</strong>函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;createAction&#125; from &#39;redux-actions&#39;;</span><br><span class="line"></span><br><span class="line">export const onAdd &#x3D; createAction(&#39;add num&#39;);</span><br></pre></td></tr></table></figure>

<p>2、创建<strong>reducer</strong>函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;handleActions as createReducer&#125; from &#39;redux-actions&#39;;</span><br><span class="line">import &#123;onAdd&#125; from &#39;.&#x2F;actionCreator.js&#39;;</span><br><span class="line"></span><br><span class="line">const initState &#x3D; &#123;num: 0&#125;</span><br><span class="line"></span><br><span class="line">const handleAdd &#x3D;&gt; (state, action) &#x3D;&gt; (&#123;</span><br><span class="line">	&#x2F;&#x2F; 组件传递的参数，会添加到action.payload中</span><br><span class="line">    num: state.num + action.payload</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default createReducer(&#123;</span><br><span class="line">	[onAdd]: handleAdd</span><br><span class="line">&#125;, initState);</span><br></pre></td></tr></table></figure>



<p>3、在组件中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Add(&#123;onAdd&#125;) &#123;</span><br><span class="line">	return &lt;div&gt;</span><br><span class="line">		&lt;button onClick&#x3D;&#123;() &#x3D;&gt; onAdd(5)&#125;&gt;添加&lt;&#x2F;button&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redux-actions-结合-redux-saga使用示例"><a href="#redux-actions-结合-redux-saga使用示例" class="headerlink" title="redux-actions 结合 redux-saga使用示例"></a>redux-actions 结合 redux-saga使用示例</h4><p>为了防止你看到这里感到混乱，不如来一个案例，看看<strong>actions</strong> 和 <strong>saga</strong> 如何配合<strong>redux</strong>完成工作流</p>
<p>现在我们要实现一个获取商品列表并展示的功能，我们来定义一下文件结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src&#x2F;products&#x2F;          </span><br><span class="line">---- redux&#x2F;</span><br><span class="line">---- ---- saga&#x2F;</span><br><span class="line">---- ---- actionCreator&#x2F;</span><br><span class="line">---- ---- reducer&#x2F;</span><br><span class="line">---- index.js</span><br><span class="line">root.saga.js</span><br><span class="line">store.js</span><br><span class="line">index.js</span><br></pre></td></tr></table></figure>

<p>1、首先我们来编写<strong>actionsCreator/actionsCreator.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;createAction&#125; from &#39;redux-actions&#39;;</span><br><span class="line"></span><br><span class="line">export const loadProducts &#x3D; createAction(&#39;load products from server&#39;);</span><br><span class="line">export const setProducts &#x3D; createAction(&#39;set local Products&#39;);</span><br></pre></td></tr></table></figure>

<p>2、接下来创建<strong>reducer</strong>和<strong>saga</strong>，我们需要把普通的<strong>actionCreator</strong>和异步<strong>actionCreator</strong>分别交给<strong>reducer/index.js</strong> 和 <strong>saga/index.js</strong>下的文件来处理</p>
<p><strong>setProducts</strong> 是设置本地的<strong>store</strong>中的数据，因此在<strong>reducer/index.js</strong>中处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;handleActions as createReducer&#125; from &#39;redux-actions&#39;;</span><br><span class="line">import &#123;setProducts&#125; from &#39;..&#x2F;actionCreator&#x2F;actionsCreator.js&#39;;</span><br><span class="line"></span><br><span class="line">const initState &#x3D; []</span><br><span class="line"></span><br><span class="line">const handleSetProducts &#x3D;&gt; (state, action) &#x3D;&gt; action.payload; &#x2F;&#x2F; payload中存储了actionCreator被调用时的传参</span><br><span class="line"></span><br><span class="line">export default createReducer(&#123;</span><br><span class="line">	[setProducts]: handleSetProducts</span><br><span class="line">&#125;, initState);</span><br></pre></td></tr></table></figure>

<p><strong>saga</strong>中处理异步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;takeEvery, put&#125; from &#39;redux-saga&#x2F;effects&#39;;</span><br><span class="line">import &#123;setProducts, loadProducts&#125; from &#39;..&#x2F;actionCreator&#x2F;actionsCreator.js&#39;;</span><br><span class="line"></span><br><span class="line">function* async_loadProduct () &#123;</span><br><span class="line">	const result &#x3D; yield axios.get(&#39;&#x2F;getProduct&#39;); &#x2F;&#x2F; 返回 商品数组 </span><br><span class="line">	yield put(setProducts(result.data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; saga要求默认导出generator函数</span><br><span class="line">export default funciton* productSaga() &#123;</span><br><span class="line">	yield takeEvery(loadProducts, async_loadProduct)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、在<strong>root.saga.js</strong>中集中引入<strong>saga</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;all&#125; from &#39;redux-saga&#x2F;effects&#39;;</span><br><span class="line">import productSaga from &#39;.&#x2F;products&#x2F;redux&#x2F;saga&#39;; &#x2F;&#x2F; 引入商品的异步action saga</span><br><span class="line"></span><br><span class="line">export default function* rootSaga() &#123;</span><br><span class="line">	yield all([</span><br><span class="line">		productSaga(),</span><br><span class="line">	])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、<strong>store.js</strong>中注册<strong>store</strong>,启用<strong>saga</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;createStore, combineReducers, applyMiddleware&#125; from &#39;redux&#39;;</span><br><span class="line">import createSagaMiddleware from &#39;redux-saga&#39;;</span><br><span class="line">import rootSaga form &#39;.&#x2F;root.saga.js&#39;;</span><br><span class="line">import productReducer from &#39;.&#x2F;src&#x2F;products&#x2F;redux&#x2F;reducer&#39;;</span><br><span class="line"></span><br><span class="line">const sagaMiddleware &#x3D; createSagaMiddleware();</span><br><span class="line"></span><br><span class="line">const reducer &#x3D; combineReducers(&#123;</span><br><span class="line">	products: productReducer</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default createStore(reducer, applyMiddleware(sagaMiddleware))</span><br><span class="line"></span><br><span class="line">sagaMiddleware.run(rootSaga); &#x2F;&#x2F; 启用saga</span><br></pre></td></tr></table></figure>

<p>5、<strong>react</strong>入口文件中<strong>index.js</strong>引入<strong>store</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDom from &#39;react-dom&#39;;</span><br><span class="line">import &#123;Provider&#125; from &#39;react-redux&#39;;</span><br><span class="line">import store from &#39;.&#x2F;store.js&#39;;</span><br><span class="line">import App from &#39;.&#x2F;&#39;; &#x2F;&#x2F; 这里引入你的的app入口</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">    &lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">    	&lt;App&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Provider&gt;,</span><br><span class="line">    document.getElementById(&#39;root&#39;),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>6、商品模块的组件<strong>products/index.js</strong>中触发<strong>actionCreator</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;useEffect&#125; from &#39;react&#39;;</span><br><span class="line">import &#123;bindActionCreators&#125; from &#39;redux&#39;;</span><br><span class="line">import * as actionCreators from &#39;.&#x2F;redux&#x2F;actionCreator&#x2F;actionCreator&#39;;</span><br><span class="line"></span><br><span class="line">const Product &#x3D; (&#123;loadProducts, products&#125;) &#x3D;&gt; &#123;</span><br><span class="line">	useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">		loadProducts(); &#x2F;&#x2F; 组件加载时获取商品列表</span><br><span class="line">	&#125;, [])</span><br><span class="line"></span><br><span class="line">	return products.map(l &#x3D;&gt; ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapStateToProps &#x3D; state &#x3D;&gt; (&#123;</span><br><span class="line">	products: state.product</span><br><span class="line">&#125;)</span><br><span class="line">const mapDispatchToProps &#x3D; dispatch &#x3D;&gt; bindActionCreators(actionCreators, dispatch);</span><br><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(Product); </span><br></pre></td></tr></table></figure>

<p>ok！！ 这样这个商品组件就能成功的运行了</p>
<h4 id="redux-原理"><a href="#redux-原理" class="headerlink" title="redux 原理"></a>redux 原理</h4><h5 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h5><p><strong>redux</strong>的原理其实就是一个观察者模式，创建好<strong>store</strong>之后通过<strong>subscribe</strong>注册观察者，我们先来实现一下<strong>createStroe</strong>的主要逻辑</p>
<p><strong>createStore</strong>可以接收三个参数，分别是<strong>reducer</strong>，<strong>preloadState</strong>，<strong>enhancer</strong>，<strong>preloadState</strong>代表默认的<strong>store</strong>数据，通常我们不使用他，<strong>enhancer</strong>代表功能拓展。第二个参数可以省略直接传第三个参数</p>
<p><strong>createStore</strong>的返回值需要有三个函数，<strong>getState</strong>， <strong>dispatch</strong>， 以及<strong>subscribe</strong></p>
<p>先不考虑<strong>enhancer</strong>这个参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createStore(reducer, preloadState) &#123;</span><br><span class="line">    &#x2F;&#x2F; 检查参数类型</span><br><span class="line">    if (typeof reducer !&#x3D;&#x3D; &#39;function&#39;) throw new Error(&#39;reducer must be function&#39;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 内部维护一个state</span><br><span class="line">    let currentState &#x3D; preloadState;</span><br><span class="line">    </span><br><span class="line">    function getState() &#123;</span><br><span class="line">        return currentState;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 保存所有的观察者，当state变化执行所有的观察者</span><br><span class="line">    let listeners &#x3D; [];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 修改数据并通知所有观察者</span><br><span class="line">    function dispatch(action) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断action是否是&#123;&#125;对象，排除数组，null等</span><br><span class="line">        if(!isPlainObject(action)) &#123;</span><br><span class="line">            throw new Error(&#39;action.__proto__ mast be Object.proptoType&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 判断是否有type</span><br><span class="line">        if (typeof action.type &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) throw new Error(&#39;action对象中必须要有type属性&#39;)</span><br><span class="line">        currentState &#x3D; reducer(currentState, action);</span><br><span class="line">        listeners.forEach(l &#x3D;&gt; &#123;</span><br><span class="line">            l();</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 添加观察者</span><br><span class="line">    function discribe(listener) &#123;</span><br><span class="line">        listeners.push(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">        getState,</span><br><span class="line">        dispatch,</span><br><span class="line">        subscribe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 辅助方法，由于判断入参是否是一个 &#123;&#125;类型的对象，用于排除基本数据类型，以及数组、Fuction以及其他对象类型。</span><br><span class="line">function isPlainObject (obj) &#123;</span><br><span class="line">    if (typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) return false;</span><br><span class="line">    var proto &#x3D; obj;</span><br><span class="line">    &#x2F;&#x2F; 就是判断入参的原型链是不是直接指向Object的原型</span><br><span class="line">    while(Object.getPrototypeOf(proto) !&#x3D;&#x3D; null) &#123;</span><br><span class="line">        proto &#x3D; Object.getPrototypeOf(proto);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return Object.getPrototypeOf(obj) &#x3D;&#x3D;&#x3D; proto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="enhancer"><a href="#enhancer" class="headerlink" title="enhancer"></a>enhancer</h5><p>接下来我们来实现下<strong>enhancer</strong>参数，<strong>enhancer</strong>在英文中是增强的意思，<strong>redux</strong>允许用户传入这个参数来创建增强的<strong>store</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createStore(reducer, preloadState, enhancer) &#123;</span><br><span class="line">    &#x2F;&#x2F; 检查reducer类型</span><br><span class="line">    ...</span><br><span class="line">    let currentState &#x3D; preloadState;</span><br><span class="line">    let listeners &#x3D; [];</span><br><span class="line">    &#x2F;* ***enhancer 部分实现*** *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 检查enhancer的参数类型</span><br><span class="line">	if (typeof enhancer !&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">        if (typeof enhancer !&#x3D;&#x3D; &#39;function&#39;) throw new Error(&#39;enhancer munst be function&#39;);</span><br><span class="line">        &#x2F;&#x2F; 执行enhancer并传递给createStore, enhancer执行后需要返回一个函数，接收reducer，preloadState</span><br><span class="line">        return enhancer(createStore)(reducer, preloadState)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* *** *&#x2F;</span><br><span class="line">    function getState() &#123;...&#125;</span><br><span class="line">    function dispatch(action) &#123;...&#125;</span><br><span class="line">    function discribe(listener) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">     return &#123;</span><br><span class="line">        getState,</span><br><span class="line">        dispatch,</span><br><span class="line">        subscribe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们传入了合法的<strong>enhancer</strong>时，<strong>createStore</strong>方法会将控制权完全交给<strong>enhancer</strong>，由<strong>enhancer</strong>来调用自己创建增强的<strong>store</strong></p>
<p><strong>enhancer</strong>接收<strong>createStore</strong>,并返回一个新的函数，接收<strong>reducer</strong>，<strong>preloadState</strong>，最终返回一个增强的<strong>store</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 我们来定义一个enhancer函数，实现类似redux-thunk的处理异步的功能</span><br><span class="line">function enhancer(createStore) &#123;</span><br><span class="line">    return function (reducer, preloadState) &#123;</span><br><span class="line">        &#x2F;&#x2F; enhancer 来调用createStore创建一个常规的store</span><br><span class="line">        var store &#x3D; createStore(reducer, preloadState);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 增强原有的dispatch</span><br><span class="line">        var dispatch &#x3D; store.dispatch;</span><br><span class="line">        function _dispatch (action) &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里就可以实现具体的增强功能了，我们在这里模拟一个类似redux-thunk的功能</span><br><span class="line">            if(typeof aciton &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">                return action(dispatch);</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch(dispatch);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return &#123;</span><br><span class="line">            ...store,</span><br><span class="line">            dispatch: _dispatch</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们在调用<strong>createStore</strong>时传入定义的<strong>enhancer</strong>函数就可以实现类型<strong>redux-thunk</strong>的功能了</p>
<h5 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h5><p>了解了<strong>enhancer</strong>的原理，我们来看下<strong>applyMiddleware</strong>这个增强器是怎么实现中间件的注册的</p>
<p>通过刚刚我们自定义<strong>enhancer</strong>函数我们了解到，<strong>enhancer</strong>需要接收一个参数<strong>createStroe</strong>，并返回一个接收<strong>reducer</strong>和<strong>preloadState</strong>的函数，最终返回一个增强的<strong>store</strong></p>
<p>先来看下我们在使用<strong>redux</strong>的<strong>applyMiddleware</strong>时是怎么作为参数传递给<strong>createStroe</strong>的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default createStore(Reducer, applyMiddleware(logMiddleWare));</span><br></pre></td></tr></table></figure>

<p><strong>applyMiddleware</strong>函数在作为<strong>createStore</strong>的参数时，传入的是<strong>applyMiddleware</strong>的调用，并在他调用时传入了若干中间件，因此，<strong>applyMiddleware</strong>需要在执行后返回一个真正的<strong>enhancer</strong>函数</p>
<p>知道了这一点，再看下之前我们写的自定义中间件的格式，<strong>applyMiddleware</strong>函数的参数需要满足三层函数的格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function logger(store) &#123;</span><br><span class="line">	return function(next) &#123;</span><br><span class="line">		return function(action) &#123;</span><br><span class="line">			</span><br><span class="line">			...中间件的内容</span><br><span class="line">			next(action); &#x2F;&#x2F; 执行下一个中间件</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，<strong>applyMiddleware</strong>在增强<strong>dispatch</strong>函数时，需要依次执行中间件，并依次传递<strong>store</strong>、<strong>next</strong>、<strong>action</strong>这几个参数，<strong>store</strong>是<strong>createStroe</strong>创建的store，<strong>action</strong>是<strong>actionCreator</strong>的返回值，那么<strong>next</strong>是什么呢。</p>
<p>当还存在下一个中间件时，<strong>next</strong>就是下一个中间件。当不存在下一个中间件时，<strong>next</strong>就是<strong>store</strong>的<strong>dispatch</strong>函数</p>
<p>ok,来实现下<strong>applyMiddleware</strong>的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function applyMiddleware(...middlewares) &#123;</span><br><span class="line">	return function(createStore) &#123;</span><br><span class="line">        return function (reducer, preloadState) &#123;</span><br><span class="line">            var store &#x3D; createStore(reducer, preloadState);</span><br><span class="line">			const middlewareApi &#x3D; &#123;</span><br><span class="line">                getState: store.getState,</span><br><span class="line">                dispatch: store.dispatch</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">           	&#x2F;&#x2F; 先将中间件执行一遍，依次拿到第二层函数</span><br><span class="line">            const chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(store))</span><br><span class="line">            </span><br><span class="line">            var dispatch &#x3D; store.dispatch;</span><br><span class="line">            &#x2F;&#x2F; 将chain中的函数的返回值（第三层函数）依次作为上一个函数（第二层函数）的参数执行,最后一个中间件传递dispatch函数</span><br><span class="line">            vr next &#x3D; compose(...chain)(dispatch);</span><br><span class="line"></span><br><span class="line">            return &#123;</span><br><span class="line">                ...store,</span><br><span class="line">                dispatch: next</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function compose() &#123;</span><br><span class="line">    var funcs &#x3D; [...arguments];</span><br><span class="line">    return function (dispatch) &#123;</span><br><span class="line">        let next &#x3D; dispatch;</span><br><span class="line">        for (let i &#x3D; funcs.length - 1; i &gt;&#x3D; 0 ; i --) &#123;</span><br><span class="line">            next &#x3D; funcs[i](next);</span><br><span class="line">        &#125;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>applyMiddleware</strong>的实现中，首先依次执行了所有中间件，并将所有的第二层函数保存到数组中。接下来，我们需要逆序执行第二层函数，将第二层函数返回的第三层函数作为上一个函数的参数<strong>next</strong>。</p>
<p>最终会返回第一个中间件的第三层参数。当这个函数被执行时，会依次执行后续中间件的第三层函数，并在最后一个中间件的第三层函数中执行<strong>dispatch</strong>函数。当然，你可以在任意一个中间件中阻止中间件向后执行，并<strong>dispatch</strong>新的<strong>action</strong>（我们上边自定中间件模拟的<strong>redux-thunk</strong>就是这么做的）</p>
<h5 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators"></a>bindActionCreators</h5><p><strong>bindActionCreators</strong> 函数可以帮我们方便地结合<strong>connect</strong>给组件添加 用于派发<strong>action</strong>的函数</p>
<p>先来再看一下这个函数的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;bindActionCreators&#125; from &#39;redux&#39;;</span><br><span class="line">import * as actionCreators from &#39;.&#x2F;redux&#x2F;action&#39;;</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps &#x3D; dispatch &#x3D;&gt; bindActionCreators(actionCreators, dispatch);</span><br><span class="line"></span><br><span class="line">export default connect(null, mapDispatchToProps)(Conmponent); </span><br></pre></td></tr></table></figure>

<p><strong>bindActionCreators</strong> 通过接收一个包含所有<strong>actionCreator</strong>的对象和<strong>dispatch</strong>函数，返回一个函数接收<strong>dispatch</strong>，并返回包含派发<strong>action</strong>函数的对象,这样说有点难理解，来看下边的转换关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">actionCreators &#x3D; &#123;</span><br><span class="line">	onAdd: (arg) &#x3D;&gt; &#123;&#125;,</span><br><span class="line">	onDelete: (arg) &#x3D;&gt; &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------- 最终返回 &#x3D;&#x3D;&#x3D;&gt; ---------------------</span><br><span class="line"></span><br><span class="line">(dispatch) &#x3D;&gt; (&#123;</span><br><span class="line">	onAdd: (arg) &#x3D;&gt; &#123;</span><br><span class="line">		dispatch( actionCreators.onAdd(arg) )</span><br><span class="line">	&#125;,</span><br><span class="line">	onDelete: (arg) &#x3D;&gt; &#123;</span><br><span class="line">		dispatch( actionCreators.onDelete(arg) )</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>看到这里基本就知道原理了，我们来实现以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bindActionCreators (actionCreators, dispatch) &#123;</span><br><span class="line">	var mapDispatchToProps &#x3D; &#123;&#125;;</span><br><span class="line">    for (let key in actionCreators) &#123;</span><br><span class="line">        mapDispatchToProps[key] &#x3D; (...args) &#x3D;&gt; &#123;</span><br><span class="line">            dispatch(actionCreators[key](...args));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return mapDispatchToProps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h5><p><strong>combineReducers</strong>允许我们将一个个小的<strong>reduer</strong>组合成一个<strong>reducer</strong>，下面我们看下这个函数的调用以及我们所期待的返回结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const reducer &#x3D; combinReducers(&#123;</span><br><span class="line">	product: (state, action) &#x3D;&gt; &#123; ... &#125;,</span><br><span class="line">	...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">----------------- 最终返回一个reducer函数 &#x3D;&#x3D;&#x3D;&#x3D;&gt; ---------------------</span><br><span class="line"></span><br><span class="line">(state, action) &#x3D;&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出， <strong>combineReducers</strong> 最终需要返回一个新的 <strong>reducer</strong>函数，这个函数需要接收<strong>action</strong>并返回一个新的合并的<strong>store</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const combineReducers &#x3D; (reducers) &#x3D;&gt; &#123;</span><br><span class="line">	&#x2F;&#x2F; 检查reducers下每个字段值得类型，必须都是函数</span><br><span class="line">	const reducerKeys &#x3D; Object.keys(reducers);</span><br><span class="line">	for (let key of reducerKeys) &#123;</span><br><span class="line">		if (typeof reducers[key] !&#x3D;&#x3D; &#39;function&#39;) throw new Error(&#39;reducer must be a function&#39;);</span><br><span class="line"> 	&#125;</span><br><span class="line">	&#x2F;&#x2F; 依次调用reducer，并将每个reducer的返回值返回到新的state中对应的部分</span><br><span class="line">	return function (state, action) &#123;</span><br><span class="line">		const nextState &#x3D; &#123;&#125;;</span><br><span class="line">		</span><br><span class="line">		for (let key of reducerKeys) &#123;</span><br><span class="line">			const reducer &#x3D; reducers[key];</span><br><span class="line">            const oldState &#x3D; state[key];</span><br><span class="line">            nextState[key] &#x3D; reducer(oldState, action);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return nextState;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>combineReducers</strong>的原理就是当执行一个<strong>action</strong>时，依次执行每个小的<strong>reducer</strong>，并将所有结果合并到一个大的<strong>state</strong>对象中</p>
]]></content>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3语法</title>
    <url>/2021/06/12/vue3-0%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><h4 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h4><p>我们可能希望这个 插槽 内绝大多数情况下都渲染文本“Submit”。为了将“Submit”作为后备内容，我们可以将它放在 slot 标签内：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;button type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">  &lt;slot&gt;Submit&lt;/slot&gt;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>有时我们需要多个插槽。例如对于一个带有如下模板的 <code>&lt;base-layout&gt;</code> 组件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;!-- 我们希望把页头放这里 --&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;!-- 我们希望把主要内容放这里 --&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;!-- 我们希望把页脚放这里 --&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>对于这样的情况，<code>&lt;slot&gt;</code> 元素有一个特殊的 <code>attribute：name</code>。这个 <code>attribute</code> 可以用来定义额外的插槽：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name=<span class="string">&quot;header&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;slot name=<span class="string">&quot;footer&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>一个不带 name 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字<code>“default”</code>。</p>
<p>在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:<span class="keyword">default</span>&gt;</span><br><span class="line">    &lt;p&gt;A paragraph <span class="keyword">for</span> the main content.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:footer&gt;</span><br><span class="line">    &lt;p&gt;Here<span class="string">&#x27;s some contact info&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;/template&gt;</span></span><br><span class="line"><span class="string">&lt;/base-layout&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>有时让插槽内容能够访问子组件中才有的数据是很有用的。当一个组件被用来渲染一个项目数组时，这是一个常见的情况，我们希望能够自定义每个项目的渲染方式。</p>
<p>例如，我们有一个组件，包含 <code>todo-items</code> 的列表。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;todo-list&#x27;</span>, &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      items: [<span class="string">&#x27;Feed a cat&#x27;</span>, <span class="string">&#x27;Buy milk&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">      &lt;li v-for=&quot;(item, index) in items&quot;&gt;</span></span><br><span class="line"><span class="string">        &#123;&#123; item &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>要使 item 可用于父级提供的 slot 内容，我们可以添加一个 <code>&lt;slot&gt;</code> 元素并将其绑定为属性：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;( item, index ) in items&quot;</span>&gt;</span><br><span class="line">    &lt;slot :item=<span class="string">&quot;item&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>绑定在 <code>&lt;slot &gt;</code> 元素上的 <code>attribute</code> 被称为插槽 <code>prop</code>。现在在父级作用域中，我们可以使用带值的 <code>v-slot</code> 来定义我们提供的插槽 <code>prop</code> 的名字：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;todo-list&gt;</span><br><span class="line">  &lt;template v-slot:<span class="keyword">default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span><br><span class="line">    &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fas fa-check&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;green&quot;</span>&gt;&#123;&#123; slotProps.item &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/todo-list&gt;</span><br></pre></td></tr></table></figure>

<h4 id="结构插槽prop"><a href="#结构插槽prop" class="headerlink" title="结构插槽prop"></a>结构插槽prop</h4><p>作用域插槽的内部工作原理是将你的插槽内容包括在一个传入单个参数的函数里,<br>这意味着 v-slot 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。你也可以使用 ES2015 解构来传入具体的插槽 prop，如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;todo-list v-slot=<span class="string">&quot;&#123; item &#125;&quot;</span>&gt;</span><br><span class="line">  &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fas fa-check&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;green&quot;</span>&gt;&#123;&#123; item &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/todo-list&gt;</span><br></pre></td></tr></table></figure>

<p>这样可以使模板更简洁，尤其是在该插槽提供了多个 prop 的时候。它同样开启了 prop 重命名等其它可能，例如将 item 重命名为 todo：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;todo-list v-slot=<span class="string">&quot;&#123; item: todo &#125;&quot;</span>&gt;</span><br><span class="line">  &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fas fa-check&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;green&quot;</span>&gt;&#123;&#123; todo &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/todo-list&gt;</span><br></pre></td></tr></table></figure>

<p>你甚至可以定义后备内容，用于插槽 prop 是 undefined 的情形</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;todo-list v-slot=<span class="string">&quot;&#123; item = &#x27;Placeholder&#x27; &#125;&quot;</span>&gt;</span><br><span class="line">  &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fas fa-check&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;green&quot;</span>&gt;&#123;&#123; item &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/todo-list&gt;</span><br></pre></td></tr></table></figure>

<h4 id="具名插槽的缩写"><a href="#具名插槽的缩写" class="headerlink" title="具名插槽的缩写"></a>具名插槽的缩写</h4><p>跟 <code>v-on</code> 和 <code>v-bind</code> 一样，<code>v-slot</code> 也有缩写，即把参数之前的所有内容 <code>(v-slot:)</code> 替换为字符 <code>#</code>。例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="提供-注入"><a href="#提供-注入" class="headerlink" title="提供/注入"></a>提供/注入</h3><p>如果我们有这样的层次结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Root</span><br><span class="line">└─ TodoList</span><br><span class="line">   ├─ TodoItem</span><br><span class="line">   └─ TodoListFooter</span><br><span class="line">      ├─ ClearTodosButton</span><br><span class="line">      └─ TodoListStatistics</span><br></pre></td></tr></table></figure>

<p>如果要将 todo-items 的长度直接传递给 TodoListStatistics，我们将把这个属性向下传递到层次结构：<code>TodoList -&gt; TodoListFooter -&gt; TodoListStatistics</code>。通过 <code>provide/inject</code> 方法，我们可以直接执行以下操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.component(<span class="string">&#x27;todo-list&#x27;</span>, &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      todos: [<span class="string">&#x27;Feed a cat&#x27;</span>, <span class="string">&#x27;Buy tickets&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  provide: &#123;</span><br><span class="line">    user: <span class="string">&#x27;John Doe&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; todos.length &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;!-- 模板的其余部分 --&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.component(<span class="string">&#x27;todo-list-statistics&#x27;</span>, &#123;</span><br><span class="line">  inject: [<span class="string">&#x27;user&#x27;</span>],</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Injected property: <span class="subst">$&#123;<span class="built_in">this</span>.user&#125;</span>`</span>) <span class="comment">// &gt; 注入 property: John Doe</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是，如果我们尝试在此处提供一些组件实例 property，则这将不起作用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;todo-list&#x27;</span>, &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      todos: [<span class="string">&#x27;Feed a cat&#x27;</span>, <span class="string">&#x27;Buy tickets&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  provide: &#123;</span><br><span class="line">    todoLength: <span class="built_in">this</span>.todos.length <span class="comment">// 将会导致错误 &#x27;Cannot read property &#x27;length&#x27; of undefined`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>要访问组件实例 property，我们需要将 provide 转换为返回对象的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;todo-list&#x27;</span>, &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      todos: [<span class="string">&#x27;Feed a cat&#x27;</span>, <span class="string">&#x27;Buy tickets&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  provide() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      todoLength: <span class="built_in">this</span>.todos.length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="处理响应式"><a href="#处理响应式" class="headerlink" title="处理响应式"></a>处理响应式</h4><p>在上面的例子中，如果我们更改了 todos 的列表，这个更改将不会反映在注入的 todoLength property 中。这是因为默认情况下，provide/inject 绑定不是被动绑定。我们可以通过将 ref property 或 reactive 对象传递给 provide 来更改此行为。在我们的例子中，如果我们想对祖先组件中的更改做出反应，我们需要为我们提供的 todoLength 分配一个组合式 API computed property：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;todo-list&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  provide() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      todoLength: Vue.computed(<span class="function">() =&gt;</span> <span class="built_in">this</span>.todos.length)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;component :is=<span class="string">&quot;currentTabComponent&quot;</span>&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure>

<h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;!-- 失活的组件将会被缓存！--&gt;</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component :is=<span class="string">&quot;currentTabComponent&quot;</span>&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>

<h3 id="强制更新"><a href="#强制更新" class="headerlink" title="强制更新"></a>强制更新</h3><p>如果你发现自己需要在 Vue 中强制更新，在 99.99%的情况下，你在某个地方犯了错误。例如，你可能依赖于 Vue 响应性系统未跟踪的状态，例如，在组件创建之后添加了 data 属性。</p>
<p>但是，如果你已经排除了上述情况，并且发现自己处于这种非常罕见的情况下，必须手动强制更新，那么你可以使用 $forceUpdate。</p>
<p>#低级静态组件与 v-once</p>
<h3 id="静态组件-v-once"><a href="#静态组件-v-once" class="headerlink" title="静态组件 v-once"></a>静态组件 v-once</h3><p>在 Vue 中渲染纯 HTML 元素的速度非常快，但有时你可能有一个包含很多静态内容的组件。在这些情况下，可以通过向根元素添加 v-once 指令来确保只对其求值一次，然后进行缓存，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.component(<span class="string">&#x27;terms-of-service&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div v-once&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Terms of Service&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      ... a lot of static content ...</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>再次提醒，不要过度使用这种模式。虽然在极少数情况下需要渲染大量静态内容时很方便，但除非你注意到渲染速度——慢，否则就没有必要这样做—另外，这可能会在以后引起很多混乱。例如，假设另一个开发人员不熟悉 v-once 或者只是在模板中遗漏了它。他们可能会花上几个小时来弄清楚为什么模板没有正确更新。</p>
<h3 id="Mixin-混入"><a href="#Mixin-混入" class="headerlink" title="Mixin 混入"></a>Mixin 混入</h3><p>EX:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myMixin = &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">this</span>.hello()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    hello() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;hello from mixin!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define an app that uses this mixin</span></span><br><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">  mixins: [myMixin]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">&#x27;#mixins-basic&#x27;</span>) <span class="comment">// =&gt; &quot;hello from mixin!&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="全局混入"><a href="#全局混入" class="headerlink" title="全局混入"></a>全局混入</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">  myOption: <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为自定义的选项 &#x27;myOption&#x27; 注入一个处理器。</span></span><br><span class="line">app.mixin(&#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">const</span> myOption = <span class="built_in">this</span>.$options.myOption</span><br><span class="line">    <span class="keyword">if</span> (myOption) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(myOption)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">&#x27;#mixins-global&#x27;</span>) <span class="comment">// =&gt; &quot;hello!&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><h4 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;)</span><br><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">app.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  mounted(el) &#123;</span><br><span class="line">    <span class="comment">// Focus the element</span></span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    mounted(el) &#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="teleport"><a href="#teleport" class="headerlink" title="teleport"></a>teleport</h3><p>使用 <code>&lt;teleport&gt;</code>，并告诉 Vue “Teleport 这个 HTML 到该‘body’标签”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;teleport to=<span class="string">&quot;body&quot;</span>&gt;</span><br><span class="line">    这将插入到body上</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure>

<p>使用 <code>&lt;teleport&gt;</code>，并告诉 Vue “Teleport 这个 HTML 到‘#wrapper’标签”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;teleport to=<span class="string">&quot;#wrapper&quot;</span>&gt;</span><br><span class="line">    这将插入到id wrapper 元素上上</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure>

<h3 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            blogTitle: <span class="string">&#x27;title&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> Vue.h(<span class="string">&#x27;h1&#x27;</span>, &#123;&#125;, <span class="built_in">this</span>.blogTitle)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="h-函数"><a href="#h-函数" class="headerlink" title="h 函数"></a>h 函数</h4><p>h() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @returns &#123;VNode&#125;</span></span><br><span class="line">h(</span><br><span class="line">  <span class="comment">// &#123;String | Object | Function | null&#125; tag</span></span><br><span class="line">  <span class="comment">// 一个 HTML 标签名、一个组件、一个异步组件，或者 null。</span></span><br><span class="line">  <span class="comment">// 使用 null 将会渲染一个注释。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 必需的。</span></span><br><span class="line">  <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;Object&#125; props</span></span><br><span class="line">  <span class="comment">// 与 attribute、prop 和事件相对应的对象。</span></span><br><span class="line">  <span class="comment">// 我们会在模板中使用。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 可选的。</span></span><br><span class="line">  &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;String | Array | Object&#125; children</span></span><br><span class="line">  <span class="comment">// 子 VNodes, 使用 `h()` 构建,</span></span><br><span class="line">  <span class="comment">// 或使用字符串获取 &quot;文本 Vnode&quot; 或者</span></span><br><span class="line">  <span class="comment">// 有 slot 的对象。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 可选的。</span></span><br><span class="line">  [</span><br><span class="line">    <span class="string">&#x27;Some text comes first.&#x27;</span>,</span><br><span class="line">    h(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;A headline&#x27;</span>),</span><br><span class="line">    h(MyComponent, &#123;</span><br><span class="line">      someProp: <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p><a href="https://github.com/vuejs/jsx-next#installation">https://github.com/vuejs/jsx-next#installation</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> AnchoredHeading <span class="keyword">from</span> <span class="string">&#x27;./AnchoredHeading.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;AnchoredHeading level=&#123;<span class="number">1</span>&#125;&gt;</span><br><span class="line">        &lt;span&gt;Hello&lt;/span&gt; world!</span><br><span class="line">      &lt;/AnchoredHeading&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="install"><a href="#install" class="headerlink" title="install"></a>install</h4><p>Install the plugin with:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @vue&#x2F;babel-plugin-jsx -D</span><br></pre></td></tr></table></figure>
<p>Then add the plugin to .babelrc:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [&quot;@vue&#x2F;babel-plugin-jsx&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="function"><a href="#function" class="headerlink" title="function"></a>function</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Vue 3.0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="render"><a href="#render" class="headerlink" title="render"></a>render</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Vue 3.0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withModifiers, defineComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> inc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      count.value++;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> (</span><br><span class="line">      &lt;div onClick=&#123;withModifiers(inc, [<span class="string">&quot;self&quot;</span>])&#125;&gt;&#123;count.value&#125;&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="fragment"><a href="#fragment" class="headerlink" title="fragment"></a>fragment</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;span&gt;I<span class="string">&#x27;m&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;Fragment&lt;/span&gt;</span></span><br><span class="line"><span class="string">  &lt;/&gt;</span></span><br><span class="line"><span class="string">);</span></span><br></pre></td></tr></table></figure>

<h4 id="Attributes-props"><a href="#Attributes-props" class="headerlink" title="Attributes/props"></a>Attributes/props</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> placeholderText = <span class="string">&quot;email&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&#123;placeholderText&#125;</span> /&gt;</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">visible</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-show</span>=<span class="string">&#123;this.visible&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=&#123;val&#125; /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="v-models"><a href="#v-models" class="headerlink" title="v-models"></a>v-models</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;A v-models=&#123;[[foo], [bar, <span class="string">&quot;bar&quot;</span>]]&#125; /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="function">(<span class="params">props, &#123; slots &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;h1&gt;&#123; slots.default ? slots.default() : <span class="string">&#x27;foo&#x27;</span> &#125;&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;&#123; slots.bar?.() &#125;&lt;/h2&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> slots = &#123;</span><br><span class="line">      bar: <span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>B<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> (</span><br><span class="line">      &lt;A v-slots=&#123;slots&#125;&gt;</span><br><span class="line">        &lt;div&gt;A&lt;/div&gt;</span><br><span class="line">      &lt;/A&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> slots = &#123;</span><br><span class="line">      <span class="keyword">default</span>: <span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">      bar: <span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>B<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">A</span> <span class="attr">v-slots</span>=<span class="string">&#123;slots&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or you can use object slots when `enableObjectSlots` is not false.</span></span><br><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;A&gt;</span><br><span class="line">          &#123;&#123;</span><br><span class="line">            <span class="keyword">default</span>: <span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">            bar: <span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>B<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>,</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &lt;/A&gt;</span><br><span class="line">        &lt;B&gt;&#123;<span class="function">() =&gt;</span> <span class="string">&quot;foo&quot;</span>&#125;&lt;/B&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="composition-Api"><a href="#composition-Api" class="headerlink" title="composition Api"></a>composition Api</h3><h4 id="ref-reactive"><a href="#ref-reactive" class="headerlink" title="ref/reactive"></a>ref/reactive</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beforeMount	onBeforeMount</span><br><span class="line">mounted	onMounted</span><br><span class="line">beforeUpdate	onBeforeUpdate</span><br><span class="line">updated	onUpdated</span><br><span class="line">beforeUnmount	onBeforeUnmount</span><br><span class="line">unmounted	onUnmounted</span><br><span class="line">errorCaptured	onErrorCaptured</span><br><span class="line">renderTracked	onRenderTracked</span><br><span class="line">renderTriggered	onRenderTriggered</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue `setup` function</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchUserRepositories &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/repositories&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in our component</span></span><br><span class="line">setup (props) &#123;</span><br><span class="line">  <span class="keyword">const</span> repositories = ref([])</span><br><span class="line">  <span class="keyword">const</span> getUserRepositories = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    repositories.value = <span class="keyword">await</span> fetchUserRepositories(props.user)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onMounted(getUserRepositories) <span class="comment">// on `mounted` call `getUserRepositories`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    repositories,</span><br><span class="line">    getUserRepositories</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="监听watch"><a href="#监听watch" class="headerlink" title="监听watch"></a>监听watch</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span><br><span class="line">watch(counter, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;The new counter value is: &#x27;</span> + counter.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fetchUserRepositories &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/repositories&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted, watch, toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在我们组件中</span></span><br><span class="line">setup (props) &#123;</span><br><span class="line">  <span class="comment">// 使用 `toRefs` 创建对prop的 `user` property 的响应式引用</span></span><br><span class="line">  <span class="keyword">const</span> &#123; user &#125; = toRefs(props)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> repositories = ref([])</span><br><span class="line">  <span class="keyword">const</span> getUserRepositories = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 更新 `prop.user` 到 `user.value` 访问引用值</span></span><br><span class="line">    repositories.value = <span class="keyword">await</span> fetchUserRepositories(user.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onMounted(getUserRepositories)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在用户 prop 的响应式引用上设置一个侦听器</span></span><br><span class="line">  watch(user, getUserRepositories)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    repositories,</span><br><span class="line">    getUserRepositories</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> twiceTheCounter = computed(<span class="function">() =&gt;</span> counter.value * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">counter.value++</span><br><span class="line"><span class="built_in">console</span>.log(counter.value) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(twiceTheCounter.value) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="提供-注入-1"><a href="#提供-注入-1" class="headerlink" title="提供/注入"></a>提供/注入</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// provider</span></span><br><span class="line"><span class="keyword">import</span> &#123; provide &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> MyMarker <span class="keyword">from</span> <span class="string">&#x27;./MyMarker.vue</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  components: &#123;</span></span><br><span class="line"><span class="string">    MyMarker</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  setup() &#123;</span></span><br><span class="line"><span class="string">    provide(&#x27;</span>location<span class="string">&#x27;, &#x27;</span>North Pole<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    provide(&#x27;</span>geolocation<span class="string">&#x27;, &#123;</span></span><br><span class="line"><span class="string">      longitude: 90,</span></span><br><span class="line"><span class="string">      latitude: 135</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// inject</span></span><br><span class="line"><span class="string">import &#123; inject &#125; from &#x27;</span>vue<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  setup() &#123;</span></span><br><span class="line"><span class="string">    const userLocation = inject(&#x27;</span>location<span class="string">&#x27;, &#x27;</span>The Universe<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    const userGeolocation = inject(&#x27;</span>geolocation<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      userLocation,</span></span><br><span class="line"><span class="string">      userGeolocation</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h5 id="添加响应式"><a href="#添加响应式" class="headerlink" title="添加响应式"></a>添加响应式</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; provide, reactive, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> MyMarker <span class="keyword">from</span> <span class="string">&#x27;./MyMarker.vue</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  components: &#123;</span></span><br><span class="line"><span class="string">    MyMarker</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  setup() &#123;</span></span><br><span class="line"><span class="string">    const location = ref(&#x27;</span>North Pole<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    const geolocation = reactive(&#123;</span></span><br><span class="line"><span class="string">      longitude: 90,</span></span><br><span class="line"><span class="string">      latitude: 135</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    provide(&#x27;</span>location<span class="string">&#x27;, location)</span></span><br><span class="line"><span class="string">    provide(&#x27;</span>geolocation<span class="string">&#x27;, geolocation)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改响应式-property"><a href="#修改响应式-property" class="headerlink" title="修改响应式 property"></a>修改响应式 property</h5><p>有时我们需要在注入数据的组件内部更新注入的数据。在这种情况下，我们建议提供一个方法来负责改变响应式 property。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Provider</span></span><br><span class="line"><span class="keyword">import</span> &#123; provide, reactive, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> MyMarker <span class="keyword">from</span> <span class="string">&#x27;./MyMarker.vue</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  components: &#123;</span></span><br><span class="line"><span class="string">    MyMarker</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  setup() &#123;</span></span><br><span class="line"><span class="string">    const location = ref(&#x27;</span>North Pole<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    const geolocation = reactive(&#123;</span></span><br><span class="line"><span class="string">      longitude: 90,</span></span><br><span class="line"><span class="string">      latitude: 135</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    const updateLocation = () =&gt; &#123;</span></span><br><span class="line"><span class="string">      location.value = &#x27;</span>South Pole<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    provide(&#x27;</span>location<span class="string">&#x27;, location)</span></span><br><span class="line"><span class="string">    provide(&#x27;</span>geolocation<span class="string">&#x27;, geolocation)</span></span><br><span class="line"><span class="string">    provide(&#x27;</span>updateLocation<span class="string">&#x27;, updateLocation)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// inject</span></span><br><span class="line"><span class="string">import &#123; inject &#125; from &#x27;</span>vue<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  setup() &#123;</span></span><br><span class="line"><span class="string">    const userLocation = inject(&#x27;</span>location<span class="string">&#x27;, &#x27;</span>The Universe<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    const userGeolocation = inject(&#x27;</span>geolocation<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    const updateUserLocation = inject(&#x27;</span>updateLocation<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      userLocation,</span></span><br><span class="line"><span class="string">      userGeolocation,</span></span><br><span class="line"><span class="string">      updateUserLocation</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="只读-readonly"><a href="#只读-readonly" class="headerlink" title="只读 readonly"></a>只读 readonly</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; provide, reactive, readonly, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> MyMarker <span class="keyword">from</span> <span class="string">&#x27;./MyMarker.vue</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  components: &#123;</span></span><br><span class="line"><span class="string">    MyMarker</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  setup() &#123;</span></span><br><span class="line"><span class="string">    const location = ref(&#x27;</span>North Pole<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    const geolocation = reactive(&#123;</span></span><br><span class="line"><span class="string">      longitude: 90,</span></span><br><span class="line"><span class="string">      latitude: 135</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    const updateLocation = () =&gt; &#123;</span></span><br><span class="line"><span class="string">      location.value = &#x27;</span>South Pole<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    provide(&#x27;</span>location<span class="string">&#x27;, readonly(location))</span></span><br><span class="line"><span class="string">    provide(&#x27;</span>geolocation<span class="string">&#x27;, readonly(geolocation))</span></span><br><span class="line"><span class="string">    provide(&#x27;</span>updateLocation<span class="string">&#x27;, updateLocation)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用JSX"><a href="#使用JSX" class="headerlink" title="使用JSX"></a>使用JSX</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> root = ref(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with JSX</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;root&#125;</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>vue3.0</tag>
        <tag>composition Api</tag>
        <tag>JSX</tag>
      </tags>
  </entry>
  <entry>
    <title>vue响应式源码</title>
    <url>/2020/08/27/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h2 id="vue响应式源码"><a href="#vue响应式源码" class="headerlink" title="vue响应式源码"></a>vue响应式源码</h2><p>vue 源码文件结构</p>
<pre style="background: #000; color: #ccc">
└ src/ ·····································  生成器目录
   ├ compiler/ ·········································  把模板转换成render函数
   ├ core/ ···································  核心代码，与平台无关
   |  ├ componetnts/
   |  |  └ keep-alive.js ······································· vue keep-alive组件
   |  ├ global-api/ ······································· vue静态方法，componet,filter,extend,mixin,use 等方法
   |  ├ instance/ ······································· 创建vue实例，包括vue构造函数，初始化，生命周期等 
   |  ├ observer/ ······································· 响应式机制实现
   |  ├ util/ ······································· 公共成员
   |  └ vdom/  ······································· 虚拟dom
   ├ platforms/ ······································· 平台相关代码
   |  ├ web/
   |  └ weex/
   ├ server/ ······································· 服务端渲染相关文章
   ├ sfc/  ······································· single file component 单文件组件转换成js对象
   └ shared/ ······································· 公共部分代码
</pre>

<h3 id="Vue初始化过程"><a href="#Vue初始化过程" class="headerlink" title="Vue初始化过程"></a>Vue初始化过程</h3><p>先通过<code>Vue</code>初始划过成，了解<code>Vue</code>源码中，静态方法实例方法等相关逻辑定义的位置</p>
<p>首先要从构造函数开始，找到构造函数的位置可以通过打包入口文件<code>platforms/web/entry-runtime-with-compiler.js</code>中引入<code>Vue</code>的位置，顺藤摸瓜找到<code>Vue</code>构造函数位置</p>
<h4 id="Vue实例上的属性和方法"><a href="#Vue实例上的属性和方法" class="headerlink" title="Vue实例上的属性和方法"></a>Vue实例上的属性和方法</h4><p>找到<code>vue</code>构造函数定义的地方 <code>/instance/index.js</code><br>构造函数中判断是否是开发环境且通过<code>new</code>调用构造方法<br>调用 <code>_init()</code>,该方法是通过下方<code>initMixin()</code>注册的<br>初始化<code>vue</code>实例的原型和属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">   ) &#123;</span><br><span class="line">      warn(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 调用 _init() 方法</span></span><br><span class="line">   <span class="built_in">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)</span><br><span class="line"><span class="comment">// 注册 vm 的 $data/$props/$set/$delete/$watch</span></span><br><span class="line">stateMixin(Vue)</span><br><span class="line"><span class="comment">// 初始化事件相关方法</span></span><br><span class="line"><span class="comment">// $on/$once/$off/$emit</span></span><br><span class="line">eventsMixin(Vue)</span><br><span class="line"><span class="comment">// 初始化生命周期相关的混入方法</span></span><br><span class="line"><span class="comment">// _update/$forceUpdate/$destroy</span></span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line"><span class="comment">// 混入 render</span></span><br><span class="line"><span class="comment">// $nextTick/_render</span></span><br><span class="line">renderMixin(Vue)</span><br></pre></td></tr></table></figure>

<h4 id="Vue类的静态成员"><a href="#Vue类的静态成员" class="headerlink" title="Vue类的静态成员"></a>Vue类的静态成员</h4><p><code>core/index</code>中引入了<code>/instance/index.js</code><br>为<code>vue</code>构造函数增加静态方法后导出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;./instance/index&#x27;</span></span><br><span class="line">initGlobalAPI(Vue)</span><br><span class="line"></span><br><span class="line">Vue.version = <span class="string">&#x27;__VERSION__&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>initGlobalAPI</code> 在 <code>global-api</code>/<code>index.js</code> 中<br>初始化<code>vue.config</code>,开发环境不能更改<br><code>vue.util</code>中定义了一些框架内部使用的方法<br>定义静态方法 <code>set</code>/<code>delete</code>/<code>nextTick</code><br>定义<code>observable</code> 可响应方法<br>初始化<code>options</code>,增加<code>components</code>/<code>directives</code>/<code>filters</code><br>增加全局<code>keep-alive</code>组件<br>注册<code>use</code>,<code>mixin</code>,<code>extend</code>和<code>directive</code>,<code>component</code>,<code>filter</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initGlobalAPI</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">Object</span>.defineProperty(Vue, <span class="string">&#x27;config&#x27;</span>, configDef)</span><br><span class="line"></span><br><span class="line">   Vue.util = &#123;warn,extend,mergeOptions,defineReactive&#125;</span><br><span class="line"></span><br><span class="line">   Vue.set = set</span><br><span class="line">   Vue.delete = del</span><br><span class="line">   Vue.nextTick = nextTick</span><br><span class="line"></span><br><span class="line">   Vue.observable = <span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>(obj: T): T =&gt; &#123;</span></span><br><span class="line"><span class="xml">      observe(obj)</span></span><br><span class="line"><span class="xml">      return obj</span></span><br><span class="line"><span class="xml">   &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">   Vue.options = Object.create(null)</span></span><br><span class="line"><span class="xml">   ASSET_TYPES.forEach(type =&gt; &#123;</span></span><br><span class="line"><span class="xml">      Vue.options[type + &#x27;s&#x27;] = Object.create(null)</span></span><br><span class="line"><span class="xml">   &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">   extend(Vue.options.components, builtInComponents)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  initUse(Vue)</span></span><br><span class="line"><span class="xml">  initMixin(Vue)</span></span><br><span class="line"><span class="xml">  initExtend(Vue)</span></span><br><span class="line"><span class="xml">  initAssetRegisters(Vue)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="平台相关的指令组件和-patch-、-mount"><a href="#平台相关的指令组件和-patch-、-mount" class="headerlink" title="平台相关的指令组件和__patch__、$mount"></a>平台相关的指令组件和__patch__、$mount</h4><p><code>platforms/web/runtime/index.js  </code>中引入了<code>core/index</code><br>这个文件首先添加了一些方法，用于判断是否是保留标签，保留属性等<br>然后通过<code>extend</code>为平台注册全局指令（<code>v-model</code>,<code>v-show</code>）和组件(<code>transition</code>, <code>transitionGroup</code>)<br>为<code>vue</code>注册全局的<code>__patch__</code>函数，用于将虚拟<code>dom</code>转换成真实<code>dom  </code><br>为<code>vue</code>添加全局的<code>$mount</code>方法，用于渲染<code>dom</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;core/index&#x27;</span></span><br><span class="line">Vue.config.mustUseProp = mustUseProp</span><br><span class="line">Vue.config.isReservedTag = isReservedTag</span><br><span class="line">Vue.config.isReservedAttr = isReservedAttr</span><br><span class="line">Vue.config.getTagNamespace = getTagNamespace</span><br><span class="line">Vue.config.isUnknownElement = isUnknownElement</span><br><span class="line"></span><br><span class="line">extend(Vue.options.directives, platformDirectives)</span><br><span class="line">extend(Vue.options.components, platformComponents)</span><br><span class="line"></span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</span><br><span class="line"></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="平台完整版增强-mount增加模板编译"><a href="#平台完整版增强-mount增加模板编译" class="headerlink" title="平台完整版增强$mount增加模板编译"></a>平台完整版增强$mount增加模板编译</h4><p><code>platforms/web/entry-runtime-with-compiler.js</code>引入<code>platforms/web/runtime/index.js </code></p>
<p>这个文件时<code>vue</code>完整版打包入口，这个文件中，增强了<code>Vue.$mount</code>方法<br>判断组件是否有<code>render</code>方法，如果没有，取<code>template</code>变异成渲染函数<code>render</code><br>最后增加一个<code>compile</code>方法，将<code>template</code>变异成<code>render</code>函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;./runtime/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line"></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> template = options.template</span><br><span class="line">   <span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">      <span class="keyword">if</span> (template) &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.compile = compileToFunctions</span><br></pre></td></tr></table></figure>

<h3 id="初始化实例成员"><a href="#初始化实例成员" class="headerlink" title="初始化实例成员"></a>初始化实例成员</h3><h4 id="initMixin-增加-init方法"><a href="#initMixin-增加-init方法" class="headerlink" title="initMixin 增加_init方法"></a>initMixin 增加_init方法</h4><h4 id="stateMixin-data、-props、"><a href="#stateMixin-data、-props、" class="headerlink" title="stateMixin $data、$props、"></a>stateMixin $data、$props、</h4><p>通过<code>defineproperty</code>为<code>Vue.prototype</code>定义<code>$data</code>和<code>$props</code>,避免开发环境用户重新定义这两个值<br>给原型增加<code>$set</code>、<code>$delete</code>方法<br>增加原型<code>$watch</code>方法，用于监视数据变化的<code>api</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">stateMixin</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dataDef = &#123;&#125;</span><br><span class="line">  dataDef.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>._data &#125;</span><br><span class="line">  <span class="keyword">const</span> propsDef = &#123;&#125;</span><br><span class="line">  propsDef.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>._props &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    dataDef.set = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">&#x27;Avoid replacing instance root $data. &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;Use nested data properties instead.&#x27;</span>,</span><br><span class="line">        <span class="built_in">this</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    propsDef.set = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      warn(<span class="string">`$props is readonly.`</span>, <span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">&#x27;$data&#x27;</span>, dataDef)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">&#x27;$props&#x27;</span>, propsDef)</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$set = set</span><br><span class="line">  Vue.prototype.$delete = del</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">    cb: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 Vue 实例 this</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">      <span class="comment">// 判断如果 cb 是对象执行 createWatcher</span></span><br><span class="line">      <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">    &#125;</span><br><span class="line">    options = options || &#123;&#125;</span><br><span class="line">    <span class="comment">// 标记为用户 watcher</span></span><br><span class="line">    options.user = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 创建用户 watcher 对象</span></span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</span><br><span class="line">    <span class="comment">// 判断 immediate 如果为 true</span></span><br><span class="line">    <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">      <span class="comment">// 立即执行一次 cb 回调，并且把当前值传入</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(vm, watcher.value)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        handleError(error, vm, <span class="string">`callback for immediate watcher &quot;<span class="subst">$&#123;watcher.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回取消监听的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      watcher.teardown()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="eventsMixin-on、-once、-off、-emit"><a href="#eventsMixin-on、-once、-off、-emit" class="headerlink" title="eventsMixin $on、$once、$off、$emit"></a>eventsMixin $on、$once、$off、$emit</h4><p>为原型添加与事件相关的方法<code>$on</code>、<code>$once</code>、<code>$off</code>、<code>$emit</code><br>内部就是通过发布订阅模式<br>为<code>vm</code>实例添加<code>_events</code>属性，用于记录不事件及对应的订阅者方法</p>
<h4 id="lifecycleMixin-update、-forceUpdate、-destory"><a href="#lifecycleMixin-update、-forceUpdate、-destory" class="headerlink" title="lifecycleMixin _update、$forceUpdate、$destory"></a>lifecycleMixin _update、$forceUpdate、$destory</h4><p>为原型添加生命周期相关方法<br><code>_update</code>方法内部调用<code>vm.__patch__</code>方法，将返回的真实<code>dom</code>保存到<code>vm.$el </code></p>
<h4 id="renderMixin"><a href="#renderMixin" class="headerlink" title="renderMixin"></a>renderMixin</h4><p>这个方法在原型上增加了很多下划线方法（<code>_o</code>、<code>_n</code>、<code>_s</code>等）,这些方法用于将模板变异成render函数<br>在原型上增加<code>$nextTick</code>方法<br>在原型上增加<code>_render</code>函数，内部调用用户传入的<code>render</code>属性，并传入h函数</p>
<h3 id="initGlobalAPI-初始化静态成员"><a href="#initGlobalAPI-初始化静态成员" class="headerlink" title="initGlobalAPI 初始化静态成员"></a>initGlobalAPI 初始化静态成员</h3><h4 id="initUse-注册Vue-use插件注册方法"><a href="#initUse-注册Vue-use插件注册方法" class="headerlink" title="initUse 注册Vue.use插件注册方法"></a>initUse 注册Vue.use插件注册方法</h4><p><code>initUse</code>方法为<code>Vue</code>类注册了use静态方法，在函数内部，会子啊首次注册插件时为<code>Vue</code>类定义<code>_installedPlugins</code>数组用于存储注册的插件，注册插件时先检查是否注册过插件<br>如果没有注册过该插件判断参数是否为对象，是对象调用对象的<code>install</code>方法，如果是函数直接执行这个函数<br>最后将刚注册的插件保存到数组中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  Vue.use = <span class="function"><span class="keyword">function</span> (<span class="params">plugin: Function | Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> installedPlugins = (<span class="built_in">this</span>._installedPlugins || (<span class="built_in">this</span>._installedPlugins = []))</span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.indexOf(plugin) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// additional parameters</span></span><br><span class="line">    <span class="comment">// 把数组中的第一个元素(plugin)去除</span></span><br><span class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 把this(Vue)插入第一个元素的位置</span></span><br><span class="line">    args.unshift(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      plugin.apply(<span class="literal">null</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="initMixin-定义Vue-mixin混入方法"><a href="#initMixin-定义Vue-mixin混入方法" class="headerlink" title="initMixin 定义Vue.mixin混入方法"></a>initMixin 定义Vue.mixin混入方法</h4><p><code>initMixin</code>做的事情就是把参数拷贝到<code>Vue.options</code>上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mergeOptions &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  Vue.mixin = <span class="function"><span class="keyword">function</span> (<span class="params">mixin: Object</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.options = mergeOptions(<span class="built_in">this</span>.options, mixin)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="initExtend-定义Vue-extend-方法"><a href="#initExtend-定义Vue-extend-方法" class="headerlink" title="initExtend 定义Vue.extend 方法"></a>initExtend 定义Vue.extend 方法</h4><p><code>Vue.extend()</code>在自定义组件时会用到，该方法会返回一个集成Vue的类，核心功能代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initExtend</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 调用 _init() 初始化</span></span><br><span class="line">      <span class="built_in">this</span>._init(options)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原型继承自 Vue</span></span><br><span class="line">    Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</span><br><span class="line">    Sub.prototype.constructor = Sub</span><br><span class="line">    <span class="comment">// 合并 options</span></span><br><span class="line">    Sub.options = mergeOptions(</span><br><span class="line">      Super.options,</span><br><span class="line">      extendOptions</span><br><span class="line">    )</span><br><span class="line">    Sub[<span class="string">&#x27;super&#x27;</span>] = Super</span><br><span class="line"></span><br><span class="line">    Sub.extend = Super.extend</span><br><span class="line">    Sub.mixin = Super.mixin</span><br><span class="line">    Sub.use = Super.use</span><br><span class="line"></span><br><span class="line">    ASSET_TYPES.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">      Sub[type] = Super[type]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Sub</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="initAssetRegisters-注册Vue-directive、component、filter方法"><a href="#initAssetRegisters-注册Vue-directive、component、filter方法" class="headerlink" title="initAssetRegisters 注册Vue.directive、component、filter方法"></a>initAssetRegisters 注册Vue.directive、component、filter方法</h4><p>这三个方法用于注册全局指令，组件和过滤器<br>所有注册的指令组件和过滤器存储在<code>Vue.options</code>中<br>三个方法内,都会判断第二个参数是否有值，没有的话返回之前注册的对应的方法<br>如果是通过<code>Vue.componet</code>注册组件并且第二个参数是一个原始对象<code>object</code>（即<code>json</code>对象），把第二个参数重定义为一个构造函数（<code>Vue.extend(definition)</code>）<br>如果通过<code>Vue.direction</code>并且第二个参数是一个函数，重定义第二个参数为<code>&#123; bind: definition, update: definition &#125;</code><br>最后将definition添加到<code>Vue.options</code>中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initAssetRegisters</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历 ASSET_TYPES 数组，为 Vue 定义相应方法</span></span><br><span class="line">  <span class="comment">// ASSET_TYPES 包括了directive、 component、filter</span></span><br><span class="line">  ASSET_TYPES.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">    Vue[type] = <span class="function"><span class="keyword">function</span> (<span class="params">id,definition</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!definition) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.options[type + <span class="string">&#x27;s&#x27;</span>][id]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// Vue.component(&#x27;comp&#x27;, &#123; template: &#x27;&#x27; &#125;)</span></span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">&#x27;component&#x27;</span> &amp;&amp; isPlainObject(definition)) &#123;</span><br><span class="line">          definition.name = definition.name || id</span><br><span class="line">          <span class="comment">// 把组件配置转换为组件的构造函数</span></span><br><span class="line">          definition = <span class="built_in">this</span>.options._base.extend(definition)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">&#x27;directive&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> definition === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">          definition = &#123; <span class="attr">bind</span>: definition, <span class="attr">update</span>: definition &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全局注册，存储资源并赋值</span></span><br><span class="line">        <span class="comment">// this.options[&#x27;components&#x27;][&#x27;comp&#x27;] = definition</span></span><br><span class="line">        <span class="built_in">this</span>.options[type + <span class="string">&#x27;s&#x27;</span>][id] = definition</span><br><span class="line">        <span class="keyword">return</span> definition</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建Vue实例"><a href="#创建Vue实例" class="headerlink" title="创建Vue实例"></a>创建Vue实例</h3><p>当通过<code>new Vue(options)</code>创建<code>Vue</code>实例之后，首先会在构造函数中调用<code>_init</code>函数，可以通过<code>vue</code>实例创建，依次来看执行了哪些操作</p>
<h4 id="init"><a href="#init" class="headerlink" title="_init()"></a>_init()</h4><p>之前已经看到 <code>Vue.prototype._init</code> 注册的位置，在<code>initMixin</code>方法中，看下_init做了哪些事情</p>
<ol>
<li><code>_init</code>中，首先定义常亮<code>vm</code>，保存当前<code>Vue</code>实例  </li>
<li>标记<code>vm._isVue = true</code>, 目的是在之后执行<code>observe</code>响应式时，不对<code>vm</code>实例做处理</li>
<li>合并用户传入的<code>options</code>和<code>Vue</code>构造函数的<code>options</code></li>
<li>渲染时的代理对象 <code>vm._renderProxy = vm</code></li>
<li>初始化<code>vm</code>生命周期相关属性 <code>initLifecycle</code><ul>
<li>将自身添加到父组件的<code>$children</code>中</li>
<li><code>$parent</code></li>
<li><code>$root</code></li>
<li><code>_watcher</code></li>
<li><code>_inactive</code></li>
<li><code>_directInactive</code></li>
<li><code>_isDestroyed</code></li>
<li><code>_isBeingDestroyed</code></li>
</ul>
</li>
<li>初始化当前组件的事件 <code>initEvents</code> <code>vm.events</code> 用于存储事件和事件处理函数，并获取父元素附加的事件注册到当前组件</li>
<li><code>initRender</code> <ul>
<li>初始化 <code>vm</code>插槽相关属性 <code>$slots</code>, <code>$scopedSlots</code></li>
<li>初始化<code>vm._c</code> 和 <code>vm.$createElement</code> 方法，<code>_c</code> 会在当通过模板编译生成<code>render</code>函数时被使用，<code>$createElement</code> 即h函数，用于将虚拟<code>dom</code>转换成真实<code>dom</code></li>
<li>通过<code>defineProperty</code> 定义不允许重新赋值的 <code>$attrs</code>属性和<code>$listeners</code>属性</li>
</ul>
</li>
<li><code>callHook</code> 触发生命周期函数 <code>beforeCreate</code></li>
<li><code>initInjections</code> 实现依赖注入 <code>inject</code><ul>
<li>提取 <code>reject</code>数组中存在且vm._provided中存在的属性<code>keys</code>保存到常量result中</li>
<li>将<code>key</code>设置成<code>vm</code>上的响应式数据，生产环境不可更改</li>
<li></li>
</ul>
</li>
<li><code>initState</code> 初始化<code>props</code>、<code>methods</code>、<code>data、</code>computed<code>、</code>watch`<ul>
<li><code>initProps</code> <ul>
<li>初始化<code>vm._props</code>对象</li>
<li>遍历参数<code>props</code>中所有属性，注入到<code>_props</code>,并在<code>vm</code>上代理<code>_props</code>中的属性，可以通过<code>vm</code> 直接访问</li>
</ul>
</li>
<li><code>initMethods</code><ul>
<li><code>判断methods</code>中的属性是否与<code>props</code>重复</li>
<li>生产模式方法名禁止用<code>_</code>或<code>$</code>开头</li>
</ul>
</li>
<li><code>initData</code> 初始化数据<ul>
<li>判断<code>data</code>中的属性是否与<code>methods</code>和<code>props</code>中的重复</li>
<li>将不是以<code>_</code>和<code>$</code>开头的属性注入到<code>vue</code>实例，并把<code>data</code>转换成响应式对象</li>
</ul>
</li>
<li><code>initComputed</code> 初始化计算属性<ul>
<li>注入到<code>vue</code>实例中</li>
<li>…</li>
</ul>
</li>
<li><code>initWatch</code> 初始化侦听器<ul>
<li>注入到<code>vue</code>实例中</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li><code>initProvide</code> 实现依赖注入 <code>provide</code><ul>
<li><code>vm.$options.privide</code> 存储到 <code>vm._provide</code>d中</li>
<li></li>
</ul>
</li>
<li><code>callHook</code> 触发生命周期函数 <code>created</code></li>
<li><code>$mount</code> 如果存在<code>$options.el</code> , 使用 <code>$mouont</code>挂载页面</li>
</ol>
<h4 id="vue-首次渲染过程"><a href="#vue-首次渲染过程" class="headerlink" title="vue 首次渲染过程"></a>vue 首次渲染过程</h4><p>初始化一个<code>vue</code>实例，看下<code>vue</code>首次渲染过程</p>
<ol>
<li>初始化实例成员和静态成员</li>
<li>调用<code>new vue</code>，进入<code>_init</code>方法</li>
<li>调用带编译器的<code>$mount</code>（主要作用是在用户没有传入<code>render</code>函数时，编译用户传入的<code>template</code>），判断<code>options</code>中是否有<code>render</code>函数<ul>
<li>如果没有<code>render</code>，获取<code>template</code>，判断<code>template</code>是否存在<ul>
<li><code>template</code>存在<ul>
<li>判断<code>template</code>是否是字符串,如果是判断是否以<code>#</code>开头,如果是通过<code>id</code>获取<code>dom</code>元素，并把元素的<code>innerHTML</code>赋值给<code>template</code></li>
<li>判断<code>template</code>是否有<code>nodeType</code>属性，如果有把<code>template</code>的<code>innerHTML</code>赋值给<code>template</code></li>
<li><code>template</code>即不是字符串也没有<code>nodeType</code>,返回<code>vue</code>实例</li>
</ul>
</li>
<li><code>template</code>不存在<ul>
<li>判断是否有<code>el</code>，有的话将<code>el</code>的<code>outerHTML</code>赋值给<code>template</code>(这里会判断<code>el</code>是否有<code>outerHTML</code>，如果没有创建一个<code>div</code>并把<code>el</code>克隆到<code>div</code>里)</li>
</ul>
</li>
<li>将最终的<code>template</code>处理成<code>render</code>函数，存储到<code>options</code>中</li>
</ul>
</li>
</ul>
</li>
<li>调用<code>$mount</code><ul>
<li>开发环境会判断是否有<code>render</code>函数，没有的话运行时版本不包含编译器的警告(运行时版本未传入<code>render</code>函数，<code>vue</code>不会把<code>template</code>编译成<code>render</code>函数)</li>
<li>触发<code>beforeMount</code>生命周期函数</li>
<li>定义<code>updateComponent</code>方法<ul>
<li>调用<code>vm._render()</code>方法,把用户传入或编译器编译的<code>render</code>转换成虚拟<code>dom</code>,并作为参数传递给<code>vm._update</code>方法，<code>vm._update</code>内部调用<code>vm.__patch__</code>方法，把虚拟<code>dom</code>转换成真实<code>dom</code>，更新到界面上，并记录到<code>vm.$el</code>中</li>
</ul>
</li>
<li>创建一个渲染<code>Watcher</code>实例,数据改变时调用<code>get()</code>,<code>get</code>内部调用<code>updateComponent</code></li>
<li>触发<code>mounted</code>生命周期函数</li>
</ul>
</li>
</ol>
<h3 id="Vue响应式原理"><a href="#Vue响应式原理" class="headerlink" title="Vue响应式原理"></a>Vue响应式原理</h3><p>在<code>vue</code>构造函数中，调用了<code>_init</code>方法，这个方法中调用<code>initState</code>初始化<code>_data</code>,<code>_props</code>,<code>methods</code>等,<code>initState</code>调用了<code>initData</code>,这个函数对用户传入的数据进行响应式处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initDate(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>initState</code>方法中,首先判断用户是否传入<code>data</code></p>
<ul>
<li>如果传入<code>data</code>调用<code>initData</code><ul>
<li>检查<code>data</code>中的属性是否与<code>props</code>,<code>methods</code>重名，不重名设置代理，将<code>data</code>成员注入到<code>vue</code>实例</li>
<li>调用<code>observe(data, true)</code>函数，内部视图创建<code>Observe</code>对象，如果创建成功返回，或者返回已存在的<code>Observe</code>对象<ul>
<li>首先判断，如果不是对象或者是<code>VNode</code>，直接<code>return</code></li>
<li>如果<code>data</code>中有<code>__ob__</code>属性并且改属性是<code>Observer</code>实例<ul>
<li>直接返回该属性值</li>
<li>否则，判断<code>data</code>是数组或者<code>Object</code>,并且不是<code>vue</code>实例，成立时返回一个<code>Observer(data)</code>对象,该对象会把data中所有属性转换为<code>getter</code>，<code>setter</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果没传入直接给vm注册<code>_data</code>为一个响应式对象</li>
</ul>
<p><code>Observer</code>类构造函数中</p>
<ul>
<li>将<code>data</code>设置属性<code>__ob__</code>,赋值为<code>Observer</code>实例，并设置<code>__ob__</code>为不可枚举</li>
<li>判断<code>data</code>是否是数组<ul>
<li>是，对数组进行特殊响应式处理<ul>
<li>判断浏览器是否支持<code>__proto__</code><ul>
<li>支持，调用<code>protoAugment</code><ul>
<li>修改当前数组的原型指向一个新的对象，将原型上涉及修改数组的方法增强，如果数组增加了元素，将新加元素设置成响应式。最后调用<code>dep.notify</code>派发通知，返回原始方法的执行结果</li>
</ul>
</li>
<li>不支持，调用<code>copyAugment</code><ul>
<li>类似<code>protoAugment</code>,维数组增强方法</li>
</ul>
</li>
</ul>
</li>
<li>调用<code>observeArray</code>,遍历数组中的成员，如果是对象的换转换成响应式对象 </li>
</ul>
</li>
<li>不是，调用<code>observer.walk</code>方法，对<code>data</code>中的每一个属性，都转换成<code>getter</code>和<code>setter</code><ul>
<li>获取<code>data</code>中的所有属性，分别调用<code>defineReactive</code>方法，将属性转换成<code>getter</code>和<code>setter</code>，同时进行收集依赖，发送通知等处理<ul>
<li>函数内部创建<code>Dep</code>对象用于收集依赖</li>
<li>获取当前属性的属性描述符，考虑到处理用户传入对象时设置了<code>configurable</code>、<code>set</code>和<code>get</code>的情况，如果用户设置了当前属性不可配置<code>configurable:false</code>，直接<code>return</code></li>
<li>如果属性值是对象，会递归调用<code>observe</code>函数,实现深度监听，并将调用<code>observe</code>返回的<code>Observer</code>队形缓存到<code>childOb</code>中</li>
<li>通过<code>defineproperty</code>设置属性的<code>getter</code>和<code>setter</code>，<ul>
<li><code>get</code>, 如果用户设置了<code>get</code>,首先调用用户传入的<code>getter</code>，接下来判断<code>Dep.target</code>属性，存在把该属性值（<code>watcher</code>）通过<code>dep.depend()</code>添加到<code>dep</code>中,如果值是对象，则通过<code>childOb.dep.depend()</code>把<code>target</code>上的<code>watcher</code>也添加到子对象的<code>dep</code>中</li>
<li><code>set</code>, <ul>
<li>判断新旧值是否相等，（考虑<code>NaN !== NaN</code>的情况）,如果新旧址相等或者都为<code>NaN</code>，直接返回</li>
<li>如果属性是只读属性直接返回</li>
<li>接下来如果用户设置了<code>setter</code>，调用<code>setter</code>，否则直接赋值<code>val = newValue</code></li>
<li>如果新值是对象，递归调用<code>observe</code>方法，把新对象设置为响应式属性</li>
<li>最后通过<code>dep.notify</code>派发更新</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>通过 <code>defineReactive</code>,为属性设置<code>getter</code>和<code>setter</code>时，会进行依赖收集，收集<code>Dep</code>上的<code>target</code>到<code>Dep</code>的<code>subs</code>数组中,而<code>Dep</code>上<code>target</code>是什么时候被赋值的呢</p>
<ul>
<li><code>_init</code> =&gt; <code>Vue.$mount</code> =&gt; <code>mountComponent</code></li>
<li><code>mountComponent</code>方法中，创建了<code>Watcher</code>对象，<code>Watcher</code>对象中，为<code>Dep.target</code>赋值为当前<code>Watcher</code>对象</li>
<li>当数据改变时，<code>watcher</code>对象的<code>get</code>方法被调用，内部会触发<code>updateComponente</code>（<code>vm._update(vm._render(), hydrating)</code>）函数，在<code>vm._render</code>函数中，会调用用户传入的<code>render</code>或者模板编译的<code>render</code>,而<code>render</code>函数内部，会访问挂载到<code>vue</code>实例上的<code>data</code>中的属性，访问属性时会触发<code>getter</code>，因为<code>vue</code>实例上代理了<code>_data</code>中的属性，因此又会再次触发<code>_data</code>属性的<code>getter</code>方法，也就是<code>defineReactive</code>中设置的<code>getter</code></li>
<li>在<code>defineReactive</code>中的<code>getter</code>被触发时，会执行<code>dep.depend</code>放法，该方法内部，调用了<code>target</code>上<code>watcher</code>实例的<code>addDep</code>方法<ul>
<li><code>addDep</code>方法缓存了已添加的<code>dep</code>对象的<code>id</code>，如果该<code>id</code>不存在，添加到<code>watcher</code>的<code>newDeps</code>数组中，并把<code>watcher</code>添加到<code>dep</code>对象的<code>subs</code>数组中</li>
</ul>
</li>
</ul>
<p><code>watcher</code>类</p>
<p><code>watcher</code> 类分为三种，计算属性<code>watcher</code>,用户侦听器<code>watcher</code>,渲染<code>watcher</code></p>
<p>watcher中构造函数执行内容</p>
<ul>
<li><code>constructor</code>参数<ul>
<li><code>vm</code>, <code>vue</code>实例</li>
<li><code>expOrFn</code>, 字符串或者函数</li>
<li><code>cb</code>, 回调函数</li>
<li><code>options</code>? 配置对象</li>
<li><code>isRenderWatcher</code>? 是否是渲染<code>watcher</code>  </li>
</ul>
</li>
<li>记录<code>vue</code>实例到<code>this.vm</code></li>
<li>判断用户传入的<code>isRenderWatcher</code>,如果<code>true</code> 代表 渲染<code>watcher</code>,将当前<code>watcher</code>添加到<code>vue</code>实例的<code>_watcher</code>属性上</li>
<li>将<code>watcherpush</code> 到<code>vm._watchers</code>数组中，<code>_watchers</code>保存了<code>vm</code>实例的所有类型的<code>watcher</code></li>
<li>根据<code>options</code>初始化配置项，默认都是<code>false</code>，</li>
<li>声明 <code>deps</code> <code>newDeps</code> <code>depIds</code> <code>newDepIds</code> 用于记录与<code>watcher</code>相关的<code>Dep</code>对象 </li>
<li>判断<code>expOrFn</code> 是否是函数，如果是函数，赋值给<code>wather</code>对象的<code>getter</code>属性 ,如果是字符串,说明是侦听器，通过<code>parsePath(expOrFn)</code>赋值给<code>getter</code>一个获取<code>expOrFn</code>值的内容<code>// 例如 watch: &#123;&#39;person.name&#39;: fn&#125;,parsePath返回一个获取person.name的函数</code></li>
<li>判断options中的lazy属性，如果不存在或者为false,执行watcher实例的get方法，渲染watcher会立即执行get方法</li>
<li>get方法内容<ul>
<li>首先调用pushTarget，将watcher入栈，并赋值给Dep.target</li>
<li>调用watcher实例的getter方法，（如果是渲染watcher,getter中保存的是updateComponent,该方法执行后，会将VNode渲染成真实dom并更新页面上）</li>
<li>调用popTarget,清理watcher队列，将栈顶watcher出栈 </li>
</ul>
</li>
</ul>
<h2 id="24-25-26"><a href="#24-25-26" class="headerlink" title="24 25 26"></a>24 25 26</h2><h3 id="动态添加属性"><a href="#动态添加属性" class="headerlink" title="动态添加属性"></a>动态添加属性</h3><p>如果要动态添加或删除属性，需要用到set,delete两个方法,不能直接修改对象</p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>涉及<code>set</code>函数的有<code>Vue.set</code>静态方法,和<code>vm.$set</code>实例方法，分别在<code>initGlobalApi</code>函数和<code>stateMixin</code>函数中被赋值，这两个方法都指向<code>instance</code>/<code>observer</code>/<code>index.js</code>里的<code>set</code>方法</p>
<ul>
<li><code>set</code>方法接收3个参数，目标对象<code>target</code>, 新增的属性<code>key</code>和值<code>val</code></li>
<li>在方法内部，首先会判断<code>target</code>是否是<code>undefined</code>或者原始值，如果是会发出警告</li>
<li>接下来判断<code>target</code>如果是数组，会判断<code>key</code>是否是合法的索引，将<code>Max(target.length, key)</code>赋值给<code>target.length</code>,然后借助数组的<code>splice(key, 1, val)</code>,对目标索引值进行替换，注意此时的<code>splice</code>方法是经过<code>defineProperty</code>处理过的，被调用后会下发通知</li>
<li>如果<code>target</code>是对象，判断属性<code>key</code>如果是<code>target</code>已经存在的属性并且不是原型上的属性，直接赋值，<code>target.key=val</code></li>
<li>如果以上条件都不满足，获取<code>target</code>上的<code>observer</code>对象</li>
<li>如果<code>target</code>是<code>vue</code>实例或者<code>$data</code>，发出警告并返回</li>
<li>判断<code>target</code>上不存在<code>observer</code>实例，直接赋值并返回，不必做响应式处理</li>
<li>如果<code>observer</code>实例存在，通过<code>defineReactive</code>将<code>target</code>增加响应式属性<code>key</code>,值为<code>value</code></li>
<li>发送通知</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target: Array&lt;any&gt; | Object, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    (isUndef(target) || isPrimitive(target))</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">`Cannot set reactive property on undefined, null, or primitive value: <span class="subst">$&#123;(target: any)&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断 target 是否是对象，key 是否是合法的索引</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    <span class="comment">// 通过 splice 对key位置的元素进行替换</span></span><br><span class="line">    <span class="comment">// splice 在 array.js 进行了响应化的处理</span></span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果 key 在对象中已经存在直接赋值</span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取 target 中的 observer 对象</span></span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line">  <span class="comment">// 如果 target 是 vue 实例或者 $data 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">&#x27;Avoid adding reactive properties to a Vue instance or its root $data &#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;at runtime - declare it upfront in the data option.&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果 ob 不存在，target 不是响应式对象直接赋值</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把 key 设置为响应式属性</span></span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  <span class="comment">// 发送通知</span></span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>delete方法与set方法类似都有两种方式静态方法Vue.delete()或者实例方法vm.$delete()<br>这两个方法都来自于/core/observer/index.js的del函数</p>
<ul>
<li>判断目标target是否是undefined或者原始值，如果是警告</li>
<li>判断是否是数组，并判断key是否是有效的下标值，如果是通过splice方法删除数组中的元素，返回</li>
<li>缓存target上的observer实例</li>
<li>判断target如果是vue实例或者是否是$data对象，发出警告并返回</li>
<li>接下来如果target上ownproperty不存在key属性，直接返回</li>
<li>通过delete删除属性 delete target[key]</li>
<li>如果target上不存在observer实例，直接返回，如果存在发送通知</li>
</ul>
<h3 id="watch"><a href="#watch" class="headerlink" title="$watch"></a>$watch</h3><p>$watch没有静态方法<br>watch执行顺序，计算属性watch，用户watch,渲染watch</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm = <span class="keyword">new</span> Vaue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">      firstname: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">      lastname: <span class="string">&#x27;long&#x27;</span>,</span><br><span class="line">      fullname: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$watch(<span class="string">&#x27;user&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newvalue, oldvalue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.user.fullname = newvalue.firstname + newvalue.lastname</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  immediate: <span class="literal">true</span>, <span class="comment">//首次渲染时立即执行监听函数，默认只在目标改变时才监听</span></span><br><span class="line">  deep: <span class="literal">true</span>, <span class="comment">// 深度监听，当user和user的属性有变化都会触发监听函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>/core/instance/state.js/initWatch</p>
<p>通过initWatch,获取用户传入的watch对象，遍历属性，并处理属性对应的处理函数，如果处理函数是多个，为同一属性绑定多个处理函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span> (<span class="params">vm: Component, watch: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = watch[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">        createWatcher(vm, key, handler[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createWatcher(vm, key, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createWatcher中会判断handler是否是对象，是的话,赋值handler为handler.handler<br>接下来判断，如果handler是字符串，将handle赋值为vue实例上的方法，vm[handler]<br>最后返回vm.$watch(…)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  handler: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(handler)) &#123;</span><br><span class="line">    options = handler</span><br><span class="line">    handler = handler.handler</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    handler = vm[handler]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm.$watch(expOrFn, handler, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$watch方法定义，（expOrFn,cb,options）<br>首先获取vue实例<br>判断cb如果是原始对象，通过createWatcher重新解析<br>增加options属性user为true,标记为用户watcher，Watcher类中会对用户传入的回调函数try,catch<br>创建Watcher对象<br>如果options.immediate为true,立即执行一次回调函数<br>返回取消监听的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">    cb: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 Vue 实例 this</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">      <span class="comment">// 判断如果 cb 是对象执行 createWatcher</span></span><br><span class="line">      <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">    &#125;</span><br><span class="line">    options = options || &#123;&#125;</span><br><span class="line">    <span class="comment">// 标记为用户 watcher</span></span><br><span class="line">    options.user = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 创建用户 watcher 对象</span></span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</span><br><span class="line">    <span class="comment">// 判断 immediate 如果为 true</span></span><br><span class="line">    <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">      <span class="comment">// 立即执行一次 cb 回调，并且把当前值传入</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(vm, watcher.value)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        handleError(error, vm, <span class="string">`callback for immediate watcher &quot;<span class="subst">$&#123;watcher.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回取消监听的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      watcher.teardown()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p>当响应式数据发生变化时，如果需要获取变化后的dom内容，需要借助nextTick方法</p>
<p>nextTick有两种使用方式Vue.nextTick和vm.$nextTick<br>两种方式最终都来自于core/util/next-tick.js的nextTick函数  </p>
<p>nextTick接收两个参数</p>
<ul>
<li>回调函数</li>
<li>执行上下文，一般是vm</li>
</ul>
<ul>
<li>函数内部首先在全局数组中添加回调函数</li>
<li>然后通过timerFunc调用数组中的函数<ul>
<li>timerFunc 内部优先通过微任务的方式执行回调函数的内容</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  <span class="comment">// 把 cb 加上异常处理存入 callbacks 数组中</span></span><br><span class="line">  callbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 cb()</span></span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">    timerFunc()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 返回 promise 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vue源码</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Vue SSR</title>
    <url>/2020/09/27/%E6%90%AD%E5%BB%BAVue-SSR/</url>
    <content><![CDATA[<h2 id="搭建VUE-SSR"><a href="#搭建VUE-SSR" class="headerlink" title="搭建VUE SSR"></a>搭建VUE SSR</h2><h3 id="环境依赖安装"><a href="#环境依赖安装" class="headerlink" title="环境依赖安装"></a>环境依赖安装</h3><p>初始化项目<code>npm init</code></p>
<p>安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue vue-server-renderer</span><br></pre></td></tr></table></figure>

<h3 id="服务端生成html文本"><a href="#服务端生成html文本" class="headerlink" title="服务端生成html文本"></a>服务端生成html文本</h3><p>创建文件server.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Vue &#x3D; require(&#39;vue&#39;);</span><br><span class="line"></span><br><span class="line">const renderer &#x3D; require(&#39;vue-server-renderer&#39;).createRenderer();</span><br><span class="line"></span><br><span class="line">const app &#x3D; new Vue(&#123;</span><br><span class="line">    template: &#96;&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;&#96;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &#39;vue ssr&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">renderer.renderToString(app, (err, html) &#x3D;&gt; &#123;</span><br><span class="line">    if (err) throw err</span><br><span class="line">    console.log(html);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>node执行文件<code>server.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot; data-server-rendered&#x3D;&quot;true&quot;&gt;&lt;h1&gt;vue ssr&lt;&#x2F;h1&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="html文本发送到浏览器，搭建web服务"><a href="#html文本发送到浏览器，搭建web服务" class="headerlink" title="html文本发送到浏览器，搭建web服务"></a>html文本发送到浏览器，搭建web服务</h3><p>安装express</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure>
<p>express 并配置路由</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> server = express();</span><br><span class="line">server.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    renderer.renderToString(app, <span class="function">(<span class="params">err, html</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) res.status(<span class="number">500</span>).end(<span class="string">&#x27;Internal Server Error&#x27;</span>)</span><br><span class="line">        <span class="comment">// 设置响应头避免乱码</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf8&#x27;</span>)</span><br><span class="line">        res.end(html);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server running at 3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>启动项目，打开浏览器<code>localhost:3000</code></p>
<img src="/2020/09/27/%E6%90%AD%E5%BB%BAVue-SSR/1.png" class="">


<h3 id="使用模板渲染html"><a href="#使用模板渲染html" class="headerlink" title="使用模板渲染html"></a>使用模板渲染html</h3><p>创建<code>index-template.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--vue-ssr-outlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意这里的<code>&lt;!--vue-ssr-outlet--&gt;</code>是模板替换的标识, 不能有额外的空格，如果格式错误或者没有匹配到这个标识，会报<code>Content placeholder not found in template.</code>的错误</p>
<p>server.js中使用模板,<code>createRenderer</code>添加配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> renderer = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer&#x27;</span>).createRenderer(&#123;</span><br><span class="line">    template: fs.readFileSync(<span class="string">&#x27;./index-template.html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此后调用<code>renderer.renderToString</code>方法时会自动将参数vue实例渲染的内容添加到模板的指定位置中</p>
<p>模板中如果要传入数据可以通过给<code>renderer.renderToString(app, &#123;title: &#39;vue ssr&#39;&#125;, fn)</code>添加第二个参数，传入数据，可以直接在模板中使用<code>&#123;&#123;key&#125;&#125;</code>来渲染字符串，使用<code>&#123;&#123;&#123;key&#125;&#125;&#125;</code>三层花括号的方式渲染为html标签</p>
<img src="/2020/09/27/%E6%90%AD%E5%BB%BAVue-SSR/2.png" class="">

<h3 id="同构"><a href="#同构" class="headerlink" title="同构"></a>同构</h3><p>之前的代码服务端只能发送静态的html数据，对于双向绑定，点击事件等都无法生效，因为这些只能通过客户端处理才能生效。</p>
<p>创建目录<code>src</code></p>
<h4 id="创建源代码文件"><a href="#创建源代码文件" class="headerlink" title="创建源代码文件"></a>创建源代码文件</h4><p>src/App.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id&#x3D;&#39;app&#39;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;input v-model&#x3D;&quot;message&quot;&#x2F;&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;button @click&#x3D;&quot;click&quot;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;App&#39;,</span><br><span class="line">    components: &#123;&#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message: &#39;vue ssr&#39;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        click: () &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#39;点击&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>src/app.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用应用入口</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;app&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>src/entry-client.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端入口</span></span><br><span class="line"><span class="keyword">import</span> &#123;createApp&#125; <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;app&#125; = createApp();</span><br><span class="line"></span><br><span class="line">app.$mount(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>src/entry-server.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端入口</span></span><br><span class="line"><span class="keyword">import</span> &#123;createApp&#125; <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> content =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;app&#125; = createApp();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务端路由，数据预取</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>通过源代码文件不能直接在服务端和客户端执行，比如.vue文件，需要借助webpack打包</p>
<p>生产依赖</p>
<ul>
<li><code>vue</code></li>
<li><code>vue-server-renderer</code>vue 服务端渲染工具</li>
<li><code>express</code></li>
<li><code>cross-env</code>npm区分环境变量</li>
</ul>
<p>开发依赖</p>
<ul>
<li><code>webpack</code> webpack核心包</li>
<li><code>webpack-cli</code>webpack命令行工具</li>
<li><code>webpack-merge</code> webpack配置合并</li>
<li><code>webpack-node-externals</code>排除webpack中的Node模块，在打包时排除掉例如fs等node模块</li>
<li><code>rimraf</code>基于node封装的跨平台rm -rf工具，可以借助命令行执行删除操作。这里用于打包前删除dist目录文件</li>
<li><code>friendly-errors-webpack-plugin</code>友好webpack错误提示</li>
<li><code>@babel/core @babel/plugin-transform-runtime @babel/preset-env babel-loader</code></li>
<li><code>vue-loader vue-template-compiler</code></li>
<li><code>file-loader</code> 处理字体资源</li>
<li><code>less less-loader</code></li>
<li><code>css-loader</code></li>
<li><code>url-loader</code> 处理图片资源</li>
</ul>
<h4 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h4><p>创建webpack配置文件</p>
<p>build/webpack.base.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader/lib/plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FriendlyErrorsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;friendly-errors-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">file</span> =&gt;</span> path.resolve(__dirname, file);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isProd = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: isProd ? <span class="string">&#x27;production&#x27;</span> : <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: resolve(<span class="string">&#x27;../dist/&#x27;</span>),</span><br><span class="line">        publicPath: <span class="string">&#x27;/dist/&#x27;</span>,</span><br><span class="line">        filename: <span class="string">&#x27;[name].[chunkhash].js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        <span class="comment">// 路径别名</span></span><br><span class="line">        alias: &#123;</span><br><span class="line">            <span class="comment">// @ 指向 src</span></span><br><span class="line">            <span class="string">&#x27;@&#x27;</span>: resolve(<span class="string">&#x27;../src/&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 可以省略的扩展名</span></span><br><span class="line">        <span class="comment">// 当省略扩展名时。从前往后依次解析</span></span><br><span class="line">        extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: isProd ? <span class="string">&#x27;source-map&#x27;</span> : <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        roles: [</span><br><span class="line">            <span class="comment">// 处理图片资源</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|jpg|gif)$/i</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            limit: <span class="number">8129</span>,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 处理字体资源</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理.vue 资源</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">                loader: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理css</span></span><br><span class="line">            <span class="comment">// .css 文件，以及.vue中的&lt;style&gt;</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">&#x27;vue-style-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理less</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">&#x27;vue-style-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;less-loader&#x27;</span>,</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> VueLoaderPlugin(),</span><br><span class="line">        <span class="keyword">new</span> FriendlyErrorsWebpackPlugin(),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>build/webpack.client.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;merge&#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.base.config.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> VueSSRClientPlugin = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer/client-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseConfig, &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        <span class="comment">// 相对路径取决于执行打包命令的路径</span></span><br><span class="line">        app: <span class="string">&#x27;./src/entry-client.js&#x27;</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// ES6 转 ES5，客户端单独处理，node端支持es6</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [<span class="string">&#x27;@babel/preset-env&#x27;</span>],</span><br><span class="line">                        cacheDirectory: <span class="literal">true</span>,</span><br><span class="line">                        plugins: [<span class="string">&#x27;@babel/plugin-transform-runtime&#x27;</span>]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将webpack运行时分离到一个引导chunk中</span></span><br><span class="line">    <span class="comment">// 以便可以在之后正确注入异步chunk</span></span><br><span class="line">    optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            name: <span class="string">&quot;manifest&quot;</span>,</span><br><span class="line">            minChunks: <span class="literal">Infinity</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 在输出目录中生成 vue-ssr-client-manifest.json</span></span><br><span class="line">        <span class="keyword">new</span> VueSSRClientPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>build/webpack.server.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;merge&#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">&#x27;webpack-node-externals&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.base.config&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VueSSRServerPlugin = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer/server-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseConfig, &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/entry-server.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 允许webpack 以Node适用方式处理模块加载</span></span><br><span class="line">    <span class="comment">// 并且还会在编译Vue组件时，</span></span><br><span class="line">    <span class="comment">// 告知vue-loader ,输出面向服务器的代码（server-oriented code）</span></span><br><span class="line">    target: <span class="string">&#x27;node&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;server-bundle.js&#x27;</span>,</span><br><span class="line">        <span class="comment">// 配置server bundle 用Node风格(module.exports)导出模块（Node-style exports）</span></span><br><span class="line">        libraryTarget: <span class="string">&#x27;commonjs2&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 不打包node_modules第三方包，保留require方式加载</span></span><br><span class="line">    <span class="comment">// 因为nodejs中一些node第三方包本身就是适用commonjs规范导入导出，在node环境不需要打包</span></span><br><span class="line">    externals: [nodeExternals(&#123;</span><br><span class="line">        <span class="comment">// 白名单中资源蒸尝大包，第三方包中的css资源依然需要打包</span></span><br><span class="line">        allowlist: [<span class="regexp">/\.css$/</span>]</span><br><span class="line">    &#125;)],</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 生成默认名称为vue-ssr-server-bundle.json的文件</span></span><br><span class="line">        <span class="keyword">new</span> VueSSRServerPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="配置打包命令"><a href="#配置打包命令" class="headerlink" title="配置打包命令"></a>配置打包命令</h4><p>package.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;build:client&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=production webpack --config build/webpack.client.config.js&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;build:server&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=production webpack --config build/webpack.server.config.js&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=production node server.js&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;node server.js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="脚本测试"><a href="#脚本测试" class="headerlink" title="脚本测试"></a>脚本测试</h5><ul>
<li>客户端打包<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build:client</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>项目中多出了<code>dist</code>目录</p>
<ul>
<li>服务端打包</li>
</ul>
<p>先删除dist目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build:server</span><br></pre></td></tr></table></figure>

<p>服务端打包只生成了一个文件<code>vue-ssr-server-bundle.json</code></p>
<ul>
<li>双端打包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<h4 id="启动同构服务"><a href="#启动同构服务" class="headerlink" title="启动同构服务"></a>启动同构服务</h4><p>修改server.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端打包生成的文件</span></span><br><span class="line"><span class="keyword">const</span> serverBundle = <span class="built_in">require</span>(<span class="string">&#x27;./dist/vue-ssr-server-bundle.json&#x27;</span>);</span><br><span class="line"><span class="comment">// 客户端打包生成的文件</span></span><br><span class="line"><span class="keyword">const</span> clientManifest = <span class="built_in">require</span>(<span class="string">&#x27;./dist/vue-ssr-client-manifest.json&#x27;</span>);</span><br><span class="line"><span class="comment">// render时vue实例实例的嵌套模板</span></span><br><span class="line"><span class="keyword">const</span> template = fs.readFileSync(<span class="string">&#x27;./index-template.html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> renderer = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer&#x27;</span>).createBundleRenderer(serverBundle ,&#123;</span><br><span class="line">    template,</span><br><span class="line">    clientManifest</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>客户端请求js资源，处理dist下文件可访问</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端请求js资源，处理dist下文件可访问</span></span><br><span class="line">server.use(<span class="string">&#x27;/dist&#x27;</span>, express.static(<span class="string">&#x27;./dist&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>删除server.js中创建的vue实例，并修改路由<code>/</code>的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// renderer.renderToString(app, &#123;title: &#x27;vue ssr&#x27;&#125;, (err, html) =&gt; &#123;</span></span><br><span class="line">    renderer.renderToString(&#123;<span class="attr">title</span>: <span class="string">&#x27;vue ssr&#x27;</span>&#125;, <span class="function">(<span class="params">err, html</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) res.status(<span class="number">500</span>).end(<span class="string">&#x27;Internal Server Error&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置响应头避免乱码</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf8&#x27;</span>)</span><br><span class="line">        res.end(html);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>renderer.renderToString 不用再传入vue实例，他会自动从<code>vue-ssr-server-bundle.json</code>找到渲染内容</p>
<p>启动服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure>

<p>浏览器访问<code>localhost:3000</code>,可以看到输出了页面，并且v-model和click时间也生效了</p>
<img src="/2020/09/27/%E6%90%AD%E5%BB%BAVue-SSR/3.png" class="">

<p>在同构应用中，服务端生成了静态html，客户端不会再次重新渲染，而是激活页面的交互效果，这是一种混合模式</p>
<blockquote>
<p>在开发模式下，Vue 将推断客户端生成的虚拟 DOM 树 (virtual DOM tree)，是否与从服务器渲染的 DOM 结构 (DOM structure) 匹配。如果无法匹配，它将退出混合模式，丢弃现有的 DOM 并从头开始渲染。在生产模式下，此检测会被跳过，以避免性能损耗</p>
</blockquote>
<p><a href="https://ssr.vuejs.org/zh/guide/hydration.html">参考Vue SSR客户端激活</a></p>
<h3 id="配置生产环境"><a href="#配置生产环境" class="headerlink" title="配置生产环境"></a>配置生产环境</h3><p>安装chokidar,这个包封装了node中的fs.watch fs.watchFile,处理了其中的一些问题，用于监视文件的变化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install chokidar</span><br></pre></td></tr></table></figure>

<p>安装webpack-dev-middleware, 用于在开发环境将打包结果保存在内存中，避免频繁的文件读写操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack-dev-middleware</span><br></pre></td></tr></table></figure>

<p>安装<a href="https://github.com/webpack-contrib/webpack-hot-middleware">webpack-hot-middleware</a>帮助我们自动在打包后刷新页面，热更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-hot-middleware</span><br></pre></td></tr></table></figure>

<p>修改 server.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Vue = <span class="built_in">require</span>(<span class="string">&#x27;vue&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;createBundleRenderer&#125; = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> setupDevServer = <span class="built_in">require</span>(<span class="string">&#x27;./build/setup-dev-server&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isProd = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const renderer = require(&#x27;vue-server-renderer&#x27;).createRenderer(&#123;</span></span><br><span class="line"><span class="comment">//     template: fs.readFileSync(&#x27;./index-template.html&#x27;, &#x27;utf-8&#x27;)</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端请求js资源，处理dist下文件可访问</span></span><br><span class="line">server.use(<span class="string">&#x27;/dist&#x27;</span>, express.static(<span class="string">&#x27;./dist&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> renderer;</span><br><span class="line"><span class="keyword">let</span> onReady; <span class="comment">// 用于保存开发模式renderer渲染器赋值状态</span></span><br><span class="line"><span class="keyword">if</span> (isProd) &#123;</span><br><span class="line">    <span class="comment">// 服务端打包生成的文件</span></span><br><span class="line">    <span class="keyword">const</span> serverBundle = <span class="built_in">require</span>(<span class="string">&#x27;./dist/vue-ssr-server-bundle.json&#x27;</span>);</span><br><span class="line">    <span class="comment">// 客户端打包生成的文件</span></span><br><span class="line">    <span class="keyword">const</span> clientManifest = <span class="built_in">require</span>(<span class="string">&#x27;./dist/vue-ssr-client-manifest.json&#x27;</span>);</span><br><span class="line">    <span class="comment">// render时vue实例实例的嵌套模板</span></span><br><span class="line">    <span class="keyword">const</span> template = fs.readFileSync(<span class="string">&#x27;./index-template.html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    renderer = createBundleRenderer(serverBundle, &#123;</span><br><span class="line">        template,</span><br><span class="line">        clientManifest</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 开发模式 =》 监视打包构建 =》 重新生成renderer渲染器</span></span><br><span class="line">    onReady = setupDevServer(server, <span class="function">(<span class="params">serverBundle, template, clientManifest</span>) =&gt;</span> &#123;</span><br><span class="line">        renderer = createBundleRenderer(serverBundle, &#123;</span><br><span class="line">            template,</span><br><span class="line">            clientManifest</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const app = new Vue(&#123;</span></span><br><span class="line"><span class="comment">//     template: `&lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="comment">//         &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/div&gt;`,</span></span><br><span class="line"><span class="comment">//     data: &#123;</span></span><br><span class="line"><span class="comment">//         message: &#x27;vue ssr&#x27;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// renderer.renderToString(app, &#123;title: &#x27;vue ssr&#x27;&#125;, (err, html) =&gt; &#123;</span></span><br><span class="line">    renderer.renderToString(&#123; <span class="attr">title</span>: <span class="string">&#x27;vue ssr&#x27;</span> &#125;, <span class="function">(<span class="params">err, html</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) res.status(<span class="number">500</span>).end(<span class="string">&#x27;Internal Server Error&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置响应头避免乱码</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf8&#x27;</span>)</span><br><span class="line">        res.end(html);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.get(<span class="string">&#x27;/&#x27;</span>, </span><br><span class="line">    isProd ? render : <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 开发模式要在有了打包结果并且渲染器赋值完成才执行render</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;等待 打包&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> onReady;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;打包 done&#x27;</span>)</span><br><span class="line">        render(req, res);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server running at 3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>setup-dev-server.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> chokidar = <span class="built_in">require</span>(<span class="string">&#x27;chokidar&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> devMiddleware = <span class="built_in">require</span>(<span class="string">&#x27;webpack-dev-middleware&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> hotMiddleware = <span class="built_in">require</span>(<span class="string">&#x27;webpack-hot-middleware&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">file</span> =&gt;</span> path.resolve(__dirname, file);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">server, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ready; <span class="comment">// 用于保存promise中的resolve函数</span></span><br><span class="line">    <span class="keyword">const</span> onReady = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> ready = r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监视构建过程 -&gt; 更新 Renderer</span></span><br><span class="line">    <span class="keyword">let</span> template;</span><br><span class="line">    <span class="keyword">let</span> serverBundle;</span><br><span class="line">    <span class="keyword">let</span> clientManifest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> update = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (template &amp;&amp; serverBundle &amp;&amp; clientManifest) &#123;</span><br><span class="line">            ready();</span><br><span class="line">            callback(serverBundle, template, clientManifest)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监视构建 template -&gt; 调用update -&gt; 更新renderer渲染器</span></span><br><span class="line">    <span class="keyword">const</span> tempaltePath = path.resolve(__dirname, <span class="string">&#x27;../index-template.html&#x27;</span>);</span><br><span class="line">    template = fs.readFileSync(tempaltePath, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    chokidar.watch(tempaltePath).on(<span class="string">&#x27;change&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 当文件变化时</span></span><br><span class="line">        template = fs.readFileSync(tempaltePath, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;模板加载读取完成&#x27;</span>)</span><br><span class="line">        update();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监视构建 serverBundle -&gt; 调用update -&gt; 更新renderer渲染器</span></span><br><span class="line">    <span class="keyword">const</span> serverConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.server.config&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> serverCompiler = webpack(serverConfig);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// webapck的编译器自带文件监视api,但是在开发环境使用会导致频繁的文件打包，文件读写，所以需要借助webpack-dev-middleware实现文件打包内容缓存在内存中</span></span><br><span class="line">    <span class="comment">// serverCompiler.watch(&#123;&#125;, (err, status) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     if (err) throw err;</span></span><br><span class="line">    <span class="comment">//     if (status.hasErrors()) return;</span></span><br><span class="line">    <span class="comment">//     serverBundle = JSON.parse(</span></span><br><span class="line">    <span class="comment">//         fs.readFileSync(resolve(&#x27;../dist/vue-ssr-server-bundle.json&#x27;), &#x27;utf-8&#x27;)</span></span><br><span class="line">    <span class="comment">//     );</span></span><br><span class="line">    <span class="comment">//     console.log(serverBundle);</span></span><br><span class="line">    <span class="comment">//     update();</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="keyword">const</span> serverDevMiddleware = devMiddleware(serverCompiler, &#123;</span><br><span class="line">        logLevel: <span class="string">&#x27;silent&#x27;</span> <span class="comment">// 关闭日志输出，有friendlyErrorsWebpackPlugin 处理</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// serverCompiler.hooks.done.tap添加打包后的回调函数，从而调用update函数，第一个参数&#x27;server&#x27;是我们定义的事件名字，没有固定意义</span></span><br><span class="line">    serverCompiler.hooks.done.tap(<span class="string">&#x27;server&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        serverBundle = <span class="built_in">JSON</span>.parse(</span><br><span class="line">            <span class="comment">// serverDevMiddleware.fileSystem 与 fs 类似，只不过是操作内存中的文件</span></span><br><span class="line">            serverDevMiddleware.fileSystem.readFileSync(resolve(<span class="string">&#x27;../dist/vue-ssr-server-bundle.json&#x27;</span>), <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// console.log(serverBundle);</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;服务端打包完成&#x27;</span>)</span><br><span class="line">        update();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监视构建 clientManifest -&gt; 调用update -&gt; 更新renderer渲染器</span></span><br><span class="line">    <span class="keyword">const</span> clientConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.client.config&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置热更新</span></span><br><span class="line">    clientConfig.plugins.push(<span class="keyword">new</span> webpack.HotModuleReplacementPlugin());</span><br><span class="line">    clientConfig.entry.app = [</span><br><span class="line">        <span class="string">&#x27;webpack-hot-middleware/client?quiet=true&amp;reload=true&#x27;</span>, <span class="comment">// 和服务端交互处理热更新的客户端脚本， 不会刷新页面</span></span><br><span class="line">        <span class="comment">// ? 之后可附带参数，quiet 指热更新时控制台禁止输出热更新日志，（[HMR] bundle rebuilding[HMR] bundle rebuilt in 33ms这种）</span></span><br><span class="line">        <span class="comment">// reload 代表在热更新卡住时刷新界面</span></span><br><span class="line">        <span class="comment">// 更多使用参照 https://github.com/webpack-contrib/webpack-hot-middleware</span></span><br><span class="line">        clientConfig.entry.app, <span class="comment">// webpack中配置的原本的打包入口</span></span><br><span class="line">    ];</span><br><span class="line">    clientConfig.output.filename = <span class="string">&#x27;[name].js&#x27;</span>; <span class="comment">// 热更新模式下，确保文件名一致，如果在配置文件中配置了[chunkhash]等导致输出的文件名不一致，热更新编译时会报错Cannot use [chunkhash] or [contenthash] for chunk in &#x27;[name].[chunkhash].js&#x27; (use [hash] instead)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> clientCompiler = webpack(clientConfig);</span><br><span class="line">    <span class="keyword">const</span> clientDevMiddleware = devMiddleware(clientCompiler, &#123;</span><br><span class="line">        publicPath: clientConfig.output.publicPath,</span><br><span class="line">        logLevel: <span class="string">&#x27;silent&#x27;</span> <span class="comment">// 关闭日志输出，有friendlyErrorsWebpackPlugin 处理</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// clientCompiler.hooks.done.tap添加打包后的回调函数，从而调用update函数，第一个参数&#x27;client&#x27;是我们定义的事件名字，没有固定意义</span></span><br><span class="line">    clientCompiler.hooks.done.tap(<span class="string">&#x27;client&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        clientManifest = <span class="built_in">JSON</span>.parse(</span><br><span class="line">            <span class="comment">// clientDevMiddleware.fileSystem 与 fs 类似，只不过是操作内存中的文件</span></span><br><span class="line">            clientDevMiddleware.fileSystem.readFileSync(resolve(<span class="string">&#x27;../dist/vue-ssr-client-manifest.json&#x27;</span>), <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// console.log(clientManifest);</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;客户端打包完成&#x27;</span>)</span><br><span class="line">        update();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置热更新</span></span><br><span class="line">    server.use(hotMiddleware(clientCompiler, &#123;</span><br><span class="line">        log: <span class="literal">false</span>, <span class="comment">// 关闭本身的日志输出</span></span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在server.js我们使用user static 处理dist下的文件为静态资源,但是开发环境中打包文件在内存中，没有实际的静态资源，所以回到值客户端不能激活</span></span><br><span class="line">    <span class="comment">// clientDevMiddleware 中间件提供了对内存中数据的访问，当客户端访问 /dist/下某个js文件时，会尝试返回内存中的文件数据</span></span><br><span class="line">    server.use(clientDevMiddleware)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> onReady;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，执行<code>npm run dev</code>,会帮我们启动一个开发服务，包含了客户端服务端同构、热更新的功能</p>
<h3 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h3><p>安装<code>vue-router</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i vue-router --save</span><br></pre></td></tr></table></figure>

<p>创建三个路由相关的页面文件</p>
<p>src/pages/404.vue、src/pages/About.vue、src/pages/Home.vue</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/pages/404.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;page404&#x27;</span>&gt;<span class="number">404</span> Not Page&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;page404&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="comment">// src/pages/About.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;about&#x27;</span>&gt;关于&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="comment">// src/pages/Home.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;home&#x27;</span>&gt;首页&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<p>server.js 稍作修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// render函数renderToString 中第一个参数填加请求路由req.url</span></span><br><span class="line"><span class="keyword">const</span> render = <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// renderer.renderToString(app, &#123;title: &#x27;vue ssr&#x27;&#125;, (err, html) =&gt; &#123;</span></span><br><span class="line">        <span class="comment">// renderToString 中第一个参数的url会在entry-server中通过context.url使用</span></span><br><span class="line">        <span class="keyword">const</span> html = <span class="keyword">await</span> renderer.renderToString(&#123; <span class="attr">title</span>: <span class="string">&#x27;vue ssr&#x27;</span>, <span class="attr">url</span>: req.url &#125;)</span><br><span class="line">        <span class="comment">// 设置响应头避免乱码</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf8&#x27;</span>)</span><br><span class="line">        res.end(html);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        res.status(<span class="number">500</span>).end(<span class="string">&#x27;Internal Server Error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端渲染不用对每一个路径都匹配路由，只需要通过*匹配所有路由，vuerouter中会对未匹配的路由返回404页面</span></span><br><span class="line">server.get(<span class="string">&#x27;*&#x27;</span>, </span><br><span class="line">    isProd ? render : <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 开发模式要在有了打包结果并且渲染器赋值完成才执行render</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;等待 打包&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> onReady;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;打包 done&#x27;</span>)</span><br><span class="line">        render(req, res);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>创建router/index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;@/pages/Home&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Page404 <span class="keyword">from</span> <span class="string">&#x27;@/pages/404&#x27;</span>; </span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于 createApp，我们也需要给每个请求一个新的 router 实例，所以文件导出一个 createRouter 函数</span></span><br><span class="line"><span class="comment">// 防止数据污染</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createRouter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">        mode: <span class="string">&#x27;history&#x27;</span>, <span class="comment">// 服务端不支持hash模式</span></span><br><span class="line">        routes: [</span><br><span class="line">            &#123;</span><br><span class="line">                path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">                name: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">                component: Home</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">                name: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">                component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/page/About&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path: <span class="string">&#x27;*&#x27;</span>, <span class="comment">// 上面的路由未匹配到时，可以通过*匹配到404页面</span></span><br><span class="line">                name: <span class="string">&#x27;page404&#x27;</span>,</span><br><span class="line">                component: Page404</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> router;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写src/entry-server.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createApp&#125; <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> context =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;app, router&#125; = createApp();</span><br><span class="line"></span><br><span class="line">    router.push(context.url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(router.onReady.bind(router));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写src/entry-client.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createApp&#125; <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;app, router&#125; = createApp();</span><br><span class="line"></span><br><span class="line">router.onReady(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    app.$mount(<span class="string">&#x27;#app&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>修改src/app.js,添加vue实例的路由</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;createRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> router = createRouter();</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        router,</span><br><span class="line">        render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;app, router&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改src/App.vue,添加路由导航和出口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&#x27;app&#x27;</span>&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>about<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;!-- 路由出口 --&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>至此，<code>npm run dev</code>启动服务已经可以看到页面上的路由生效了，并且，首次加载之后，页面的跳转是通过客户端懒加载来实现的，这样我们的应用既可以实现更好的seo,又能给用户提供单页面应用极致的用户体验</p>
<img src="/2020/09/27/%E6%90%AD%E5%BB%BAVue-SSR/router.png" class="">

<p>更多参照<a href="https://ssr.vuejs.org/zh/guide/routing.html#%E4%BD%BF%E7%94%A8-vue-router-%E7%9A%84%E8%B7%AF%E7%94%B1">Vue SSR 路由和代码分割</a></p>
<h3 id="配置不同界面的Head标签"><a href="#配置不同界面的Head标签" class="headerlink" title="配置不同界面的Head标签"></a>配置不同界面的Head标签</h3><p>之前我们通过index-template模板给所有页面配置了统一的模板，如果我们需要针对摸个路由配置不同的页面title，或者meta标签等，可以借助vue-meta</p>
<p>安装vue-meta</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-meta</span><br></pre></td></tr></table></figure>

<p>在同一入口src/app.js中混入vue-meta</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VueMeta <span class="keyword">from</span> <span class="string">&#x27;vue-meta&#x27;</span>;</span><br><span class="line">Vue.use(VueMeta);</span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">    metaInfo: &#123;</span><br><span class="line">        titleTemplate: <span class="string">&#x27;%s - Vue SSR&#x27;</span>, <span class="comment">// title 的模板，%s 会替换为标题</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改src/entry-server.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> context =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;app, router&#125; = createApp();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到混入的meta内容</span></span><br><span class="line">    <span class="keyword">const</span> meta = app.$meta();</span><br><span class="line"></span><br><span class="line">    router.push(context.url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入到context上下文中，这样在页面模板中就可以取到meta的内容了</span></span><br><span class="line">    context.meta = meta;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(router.onReady.bind(router));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为Home.vue、About.vue添加metaInfo属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/pages/Home.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    metaInfo: &#123;</span><br><span class="line"></span><br><span class="line">        title: <span class="string">&#x27;首页&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/pages/About.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">    metaInfo: &#123;</span><br><span class="line">        title: <span class="string">&#x27;关于&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在模板中使用页面的metaInfo</p>
<p>index-template.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;&#123; meta.inject().title.text() &#125;&#125;&#125;</span><br><span class="line">    &#123;&#123;&#123; meta.inject().meta.text() &#125;&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>开启开发服务,访问<code>localhost:3000</code></p>
<img src="/2020/09/27/%E6%90%AD%E5%BB%BAVue-SSR/meta.png" class="">

<p>更多<code>vue-meta</code>使用参照<a href="https://vue-meta.nuxtjs.org/api/">vue-meta使用</a></p>
<h3 id="数据预取和状态管理"><a href="#数据预取和状态管理" class="headerlink" title="数据预取和状态管理"></a>数据预取和状态管理</h3><blockquote>
<p>在服务器端渲染(SSR)期间，我们本质上是在渲染我们应用程序的”快照”，所以如果应用程序依赖于一些异步数据，那么在开始渲染过程之前，需要先预取和解析好这些数据。</p>
</blockquote>
<blockquote>
<p>另一个需要关注的问题是在客户端，在挂载 (mount) 到客户端应用程序之前，需要获取到与服务器端应用程序完全相同的数据 - 否则，客户端应用程序会因为使用与服务器端应用程序不同的状态，然后导致混合失败。</p>
</blockquote>
<blockquote>
<p>为了解决这个问题，获取的数据需要位于视图组件之外，即放置在专门的数据预取存储容器(data store)或”状态容器(state container)）”中。首先，在服务器端，我们可以在渲染之前预取数据，并将数据填充到 store 中。此外，我们将在 HTML 中序列化(serialize)和内联预置(inline)状态。这样，在挂载(mount)到客户端应用程序之前，可以直接从 store 获取到内联预置(inline)状态。</p>
</blockquote>
<p>这里实现一个文章列表的服务端预取与状态管理</p>
<p>安装 vuex, axios</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vuex axios --save</span><br></pre></td></tr></table></figure>

<p>创建store<br>src/store/index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createStore = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">        state: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">            posts: []</span><br><span class="line">        &#125;),</span><br><span class="line"></span><br><span class="line">        mutations: &#123;</span><br><span class="line">            setPosts (state, data) &#123;</span><br><span class="line">                state.posts = data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        actions: &#123;</span><br><span class="line">            <span class="comment">// 在服务端渲染期间务必让action返回一个Promise，服务端渲染时会等待数据返回</span></span><br><span class="line">            <span class="keyword">async</span> getPosts(context) &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123;commit&#125; = context;</span><br><span class="line">                <span class="keyword">const</span> &#123;data&#125; = <span class="keyword">await</span> axios.get(<span class="string">&#x27;https://cnodejs.org/api/v1/topics&#x27;</span>);</span><br><span class="line">                commit(<span class="string">&#x27;setPosts&#x27;</span>, data.data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给vue实例注册store<br>scr/app.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> router = createRouter();</span><br><span class="line">    <span class="keyword">const</span> store = createStore(); <span class="comment">// 创建store</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        router,</span><br><span class="line">        store, <span class="comment">// 注册store</span></span><br><span class="line">        render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;app, router, store&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建文章页面 并注册路由</p>
<p>src/pages/Posts.vue</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;posts&#x27;</span>&gt;</span><br><span class="line">        &lt;h1&gt;posts list&lt;/h1&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;post in posts&quot;</span> :key=<span class="string">&quot;post.id&quot;</span>&gt;&#123;&#123; post.title &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;mapState, mapActions&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;Posts&#x27;</span>,</span><br><span class="line">    metaInfo: &#123;</span><br><span class="line">        title: <span class="string">&#x27;文章&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        ...mapState([<span class="string">&#x27;posts&#x27;</span>]),</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        ...mapActions([<span class="string">&#x27;getPosts&#x27;</span>]),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// vue ssr 为服务端提供的特殊的生命周期函数</span></span><br><span class="line">    serverPrefetch() &#123;</span><br><span class="line">        <span class="comment">// 发起action 返回Promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getPosts();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这个时候，当我们访问posts路由的页面时，会看到页面渲染出了文章标题列表但是一闪而过，这是因为我们的store中的数据没有同步，服务端和客户端store同步的思路就是，服务端在模板context中保存数据，并将数据通过脚本的方式注入到客户端页面的<code>window.__INITIAL_STATE__</code>中，客户端会拿到这个数据并填充到客户端的store中</p>
<p>修改entry-server.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> context =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;app, router, store&#125; = createApp();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> meta = app.$meta();</span><br><span class="line"></span><br><span class="line">    router.push(context.url);</span><br><span class="line"></span><br><span class="line">    context.meta = meta;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(router.onReady.bind(router));</span><br><span class="line"></span><br><span class="line">    context.rendered = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// renderer 会把 content.state中的数据内联到页面模板中</span></span><br><span class="line">        <span class="comment">// 最终发送给客户端的页面中会包含一段脚本：window.__INITIAL_STATE__ = context.state;</span></span><br><span class="line">        <span class="comment">// 客户端就要把页面中的window.__INITIAL_STATE__ 取出来填充到客户端store中去</span></span><br><span class="line">        context.state = store.state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时打开浏览器<code>/posts</code>页面，控制台打印查看插入的script数据标签</p>
<img src="/2020/09/27/%E6%90%AD%E5%BB%BAVue-SSR/initialstate.png" class="">

<p>接下来让客户端接管服务端的store</p>
<p>src/entry-client.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;app, router, store&#125; = createApp();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__INITIAL_STATE__) &#123;</span><br><span class="line">    store.replaceState(<span class="built_in">window</span>.__INITIAL_STATE__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样客户端页面就会接管服务端的数据了</p>
<img src="/2020/09/27/%E6%90%AD%E5%BB%BAVue-SSR/store.png" class="">

]]></content>
      <tags>
        <tag>Vue ssr</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化构建</title>
    <url>/2020/08/27/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="前端自动化"><a href="#前端自动化" class="headerlink" title="前端自动化"></a>前端自动化</h2><p>前端自动化构建工具</p>
<ul>
<li>grunt 基于临时文件，构建速度较慢</li>
<li>gulp 基于内存，同时处理多个任务</li>
<li>FIS 百度，大而全，适合初学者</li>
</ul>
<h3 id="grunt"><a href="#grunt" class="headerlink" title="grunt"></a>grunt</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add grunt</span><br></pre></td></tr></table></figure>

<p>根目录创建<code>gruntfile.js</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; grunt &#x3D;&gt; &#123;</span><br><span class="line">    grunt.registerTask(&#39;hello&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;hello world&#39;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命令行执行 <code>yarn grunt hello</code><br>可以看到命令行打印hello world</p>
<p>可以通过注册函数 第二个参数为字符串，来为任务添加描述，这个描述会通过<code>yarn grun --help</code>时显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grunt.registerTask(&#39;des&#39;, &#39;任务描述&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;des task&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<pre style="background: #000; color: #ccc;">
PS C:\Users\admin\Desktop\grunt-test> yarn grunt --help 

...

Available tasks
         hello  Custom task.
           des  任务描述
</pre>


<p>异步任务,异步任务需要借助 grunt 的 async 函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> grunt.registerTask(&#39;async-task&#39;, function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 异步任务必须在执行之前调用this.async 并拿到返回结果</span><br><span class="line">    const done &#x3D; this.async();</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(&#39;异步任务执行了&#39;)</span><br><span class="line">        done()</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>默认任务，在命令行直接执行 <code>yarn grunt</code>时，会查看是否注册名为<code>default</code>的任务，有的话会执行<code>default</code>任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grunt.registerTask(&#39;default&#39;, &#39;默认任务&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;模拟默认任务&#39;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>串行任务，可以为注册任务指定一个任务数组，再执行该任务时会一次执行任务数组中的任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grunt.registerTask(&#39;default&#39;, &#39;默认任务&#39;, [&#39;hello&#39;, &#39;des&#39;, &#39;async-task&#39;])</span><br></pre></td></tr></table></figure>

<p>任务标记失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 任务中返回false 代表任务失败，在串行任务中，失败的任务之后的任务不再执行</span><br><span class="line">&#x2F;&#x2F; 如果想要穿行任务失败之后的任务强制执行，可以指定 --force 的参数 </span><br><span class="line">grunt.registerTask(&#39;error-task&#39;, &#39;模拟执行失败的任务&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;模拟执行失败的任务&#39;);</span><br><span class="line">    return false;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>异步任务标记失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 异步任务标记失败</span><br><span class="line">   grunt.registerTask(&#39;async-error-task&#39;, &#39;模拟执行失败的异步任务&#39;, function() &#123;</span><br><span class="line">       const done &#x3D; this.async();</span><br><span class="line">       setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">           console.log(&#39;模拟执行失败的异步任务&#39;);</span><br><span class="line">           done(false);</span><br><span class="line">       &#125;, 1000)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<p>配置方法initConfig</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">    name: <span class="string">&#x27;along&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">grunt.registerTask(<span class="string">&#x27;getName&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(grunt.config(<span class="string">&#x27;name&#x27;</span>));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="多目标任务"><a href="#多目标任务" class="headerlink" title="多目标任务"></a>多目标任务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 多目标任务</span><br><span class="line">grunt.initConfig(&#123;</span><br><span class="line">    &#x2F;&#x2F; 任务名与注册的任务名相同</span><br><span class="line">    build: &#123;</span><br><span class="line">        &#x2F;&#x2F; options 会作为任务选项出现</span><br><span class="line">        options: &#123;</span><br><span class="line">            global: &#39;dev&#39;,</span><br><span class="line">            path: &#39;&#x2F;src&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 除了options 其他的属性都会称为任务的一个目标任务</span><br><span class="line">        css: &#39;css任务&#39;,</span><br><span class="line">        js: &#39;js任务&#39;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 为某个目标任务指定 options时，会替换掉全局的options中相同的属性</span><br><span class="line">        static: &#123;</span><br><span class="line">            options: &#123;</span><br><span class="line">                path: &#39;&#x2F;public&#39;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">grunt.registerMultiTask(&#39;build&#39;, &#39;多目标任务&#39;, function() &#123;</span><br><span class="line">    console.log(this.options())</span><br><span class="line">    console.log(&#96;build task - target: $&#123;this.target&#125; data: $&#123;this.data&#125;&#96;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>执行这个任务</p>
<pre style="background: #000; color: #fff;">
PS C:\Users\admin\Desktop\grunt-test> yarn grunt build
yarn run v1.22.4
$ C:\Users\admin\Desktop\grunt-test\node_modules\.bin\grunt build
Running "build:css" (build) task
{ global: 'dev', path: '/src' }
build task - target: css data: css任务

Running "build:js" (build) task
{ global: 'dev', path: '/src' }
build task - target: js data: js任务

Running "build:static" (build) task
{ global: 'dev', path: '/public' }
build task - target: static data: [object Object]
</pre>


<h3 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h3><p>安装清除文件插件<br><code>yarn add grunt-contrib-clean</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">    &#x2F;&#x2F; 需要对应的配置</span><br><span class="line">    clean: &#123;</span><br><span class="line">        &#x2F;&#x2F; dist: &#39;dist&#x2F;index.html&#39;,</span><br><span class="line">        &#x2F;&#x2F; dist: &#39;dist&#x2F;*.txt&#39;,</span><br><span class="line">        dist: &#39;dist&#x2F;**&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 加载插件</span><br><span class="line">grunt.loadNpmTasks(&#39;grunt-contrib-clean&#39;);</span><br></pre></td></tr></table></figure>

<p>sass插件</p>
<p><code>yarn add grunt-sass sass</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const sass &#x3D; require(&#39;sass&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; grunt &#x3D;&gt; &#123;</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        sass: &#123;</span><br><span class="line">            options: &#123;</span><br><span class="line">                implementation: sass,</span><br><span class="line">            &#125;,</span><br><span class="line">            main: &#123;</span><br><span class="line">                files: &#123;</span><br><span class="line">                    &#39;dist&#x2F;css&#x2F;main.css&#39;: &#39;src&#x2F;scss&#x2F;main.scss&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    grunt.loadNpmTasks(&#39;grunt-sass&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>babel</p>
<p><code>yarn add grunt-babel @babel/core @babel/preset-env</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">    babel: &#123;</span><br><span class="line">        options: &#123;</span><br><span class="line">            presets: [&#39;@babel&#x2F;preset-env&#39;]</span><br><span class="line">        &#125;,</span><br><span class="line">        main: &#123;</span><br><span class="line">            files: &#123;</span><br><span class="line">                &#39;dist&#x2F;js&#x2F;app.js&#39;: &#39;src&#x2F;js&#x2F;app.js&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    grunt.loadNpmTasks(&#39;grunt-babel&#39;);</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>自动加载模块</p>
<p><code>yarn add load-grunt-tasks --dev</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const loadGruntTasks &#x3D; require(&#39;load-grunt-tasks&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; grunt &#x3D;&gt; &#123;</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        babel: &#123;</span><br><span class="line">            options: &#123;</span><br><span class="line">                sourceMap: true,</span><br><span class="line">                presets: [&#39;@babel&#x2F;preset-env&#39;]</span><br><span class="line">            &#125;,</span><br><span class="line">            main: &#123;</span><br><span class="line">                files: &#123;</span><br><span class="line">                    &#39;dist&#x2F;js&#x2F;app.js&#39;: &#39;src&#x2F;js&#x2F;app.js&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    loadGruntTasks(grunt); &#x2F;&#x2F; 自动加载插件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监听文件自动编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add grunt-contrib-watch --dev</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const sass &#x3D; require(&#39;sass&#39;);</span><br><span class="line">const loadGruntTasks &#x3D; require(&#39;load-grunt-tasks&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; grunt &#x3D;&gt; &#123;</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        watch: &#123;</span><br><span class="line">            js: &#123;</span><br><span class="line">                files: [&#39;src&#x2F;js&#x2F;*.js&#39;], &#x2F;&#x2F; 坚挺的文件数组</span><br><span class="line">                tasks: [&#39;babel&#39;], &#x2F;&#x2F; 当文件变化时要执行的任务</span><br><span class="line">            &#125;,</span><br><span class="line">            css: &#123;</span><br><span class="line">                files: [&#39;src&#x2F;scss&#x2F;*.scss&#39;],</span><br><span class="line">                tasks: [&#39;sass&#39;],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        babel: &#123;</span><br><span class="line">            options: &#123;</span><br><span class="line">                sourceMap: true,</span><br><span class="line">                presets: [&#39;@babel&#x2F;preset-env&#39;]</span><br><span class="line">            &#125;,</span><br><span class="line">            main: &#123;</span><br><span class="line">                files: &#123;</span><br><span class="line">                    &#39;dist&#x2F;js&#x2F;app.js&#39;: &#39;src&#x2F;js&#x2F;app.js&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        sass: &#123;</span><br><span class="line">            options: &#123;</span><br><span class="line">                sourceMap: true,</span><br><span class="line">                implementation: sass,</span><br><span class="line">            &#125;,</span><br><span class="line">            main: &#123;</span><br><span class="line">                files: &#123;</span><br><span class="line">                    &#39;dist&#x2F;css&#x2F;main.css&#39;: &#39;src&#x2F;scss&#x2F;main.scss&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    loadGruntTasks(grunt); &#x2F;&#x2F; 自动加载插件</span><br><span class="line">    </span><br><span class="line">    grunt.registerTask(&#39;default&#39;, [&#39;sass&#39;, &#39;babel&#39;, &#39;watch&#39;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后被监听文件修改会自动编译</p>
<h3 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h3><p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add gulp --dev</span><br></pre></td></tr></table></figure>

<p>创建入口文件<code>gulpfile.js</code></p>
<p>注册任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports.foo &#x3D;  done &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;foo&#39;)</span><br><span class="line">    done();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>yarn gulp foo</code></p>
<p>注册默认任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports.default &#x3D;  done &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;defalt&#39;)</span><br><span class="line">    done();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组合任务<br>组合任务可以注册串行任务和并行任务</p>
<ul>
<li>串行任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123;series, parallel&#125; &#x3D; require(&#39;gulp&#39;);</span><br><span class="line"></span><br><span class="line">const task1 &#x3D; done &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;task1 running~&#39;);</span><br><span class="line">        done();</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const task2 &#x3D; done &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;task2 running~&#39;);</span><br><span class="line">        done();</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const task3 &#x3D; done &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;task3 running~&#39;);</span><br><span class="line">        done();</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; gulp 组合任务</span><br><span class="line">exports.default &#x3D; series(task1, task2, task3);</span><br></pre></td></tr></table></figure>

<pre style="background: #000;color: #ccc">
PS C:\Users\admin\Desktop\gulp-demo> yarn gulp
$ C:\Users\admin\Desktop\gulp-demo\node_modules\.bin\gulp
[00:53:37] Using gulpfile ~\Desktop\gulp-demo\gulpfile.js
[00:53:37] Starting 'default'...
[00:53:37] Starting 'task1'...
task1 running~
[00:53:39] Finished 'task1' after 2.03 s
[00:53:39] Starting 'task2'...
task2 running~
[00:53:41] Finished 'task2' after 2.01 s
[00:53:41] Starting 'task3'...
task3 running~
[00:53:43] Finished 'task3' after 2.01 s
[00:53:43] Finished 'default' after 6.08 s
Done in 7.36s.
</pre>

<ul>
<li>并行任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册上面代码三个任务的并行任务</span><br><span class="line">exports.default &#x3D; parallel(task1, task2, task3);</span><br></pre></td></tr></table></figure>

<pre style="background: #000; color: #ccc">
PS C:\Users\admin\Desktop\gulp-demo> yarn gulp
yarn run v1.22.4
$ C:\Users\admin\Desktop\gulp-demo\node_modules\.bin\gulp
[00:57:27] Using gulpfile ~\Desktop\gulp-demo\gulpfile.js
[00:57:27] Starting 'default'...
[00:57:27] Starting 'task1'...
[00:57:27] Starting 'task2'...
[00:57:27] Starting 'task3'...
task1 running~
[00:57:29] Finished 'task1' after 2.01 s
task2 running~
[00:57:29] Finished 'task2' after 2.04 s
task3 running~
[00:57:29] Finished 'task3' after 2.05 s
[00:57:29] Finished 'default' after 2.1 s
Done in 3.64s.
</pre>

<p>gulp异步任务</p>
<ul>
<li>promise异步任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; gulp 异步任务</span><br><span class="line">&#x2F;&#x2F; promise 返回成功时会忽略 promise 的返回值</span><br><span class="line">exports.promise &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;promise task~&#39;);</span><br><span class="line">    return Promise.resolve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.promise_error &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;promise error task~&#39;);</span><br><span class="line">    return Promise.reject(new Error(&#39;task failed~&#39;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>async 异步任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; async 异步任务</span><br><span class="line">const timeout &#x3D; time &#x3D;&gt; &#123;</span><br><span class="line">    return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(resolve, time);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.async &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">    await timeout(1000);</span><br><span class="line">    console.log(&#39;async task &#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>stream 文件流</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports.stream &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const readStream &#x3D; fs.createReadStream(&#39;package.json&#39;);</span><br><span class="line">    const writeStream &#x3D; fs.createWriteStream(&#39;temp.txt&#39;);</span><br><span class="line">    readStream.pipe(writeStream);</span><br><span class="line">    return readStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gulp-构建过程核心原理"><a href="#gulp-构建过程核心原理" class="headerlink" title="gulp 构建过程核心原理"></a>gulp 构建过程核心原理</h4><p>gulp是基于流的构建</p>
<p>读取流 =&gt; 转换流 =&gt; 写入流</p>
<p>创建文件<code>css/style.css</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 样式文件 *&#x2F;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">    color: #333;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 样式结束 *&#x2F;</span><br></pre></td></tr></table></figure>

<p>先手动创建一个输出文件夹<code>dist/css/style.css</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">&#x2F;&#x2F; 借助stream的转换流读取做css的转换</span><br><span class="line">const &#123;Transform&#125; &#x3D; require(&#39;stream&#39;);</span><br><span class="line">exports.css &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 读取文件</span><br><span class="line">    const read &#x3D; fs.createReadStream(&#39;css&#x2F;style.css&#39;);</span><br><span class="line">    &#x2F;&#x2F; 文件写入流</span><br><span class="line">    const write &#x3D; fs.createWriteStream(&#39;dist&#x2F;css&#x2F;style.min.css&#39;);</span><br><span class="line">    &#x2F;&#x2F; 文件转换流</span><br><span class="line">    const transform &#x3D; new Transform(&#123;</span><br><span class="line">        transform: (chunk, encoding, callback) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; check &#x3D;&gt; 读取流的文件内容（Buffer）</span><br><span class="line">            const input &#x3D; chunk.toString();</span><br><span class="line">            &#x2F;&#x2F; 替换掉 空格和注释</span><br><span class="line">            const output &#x3D; input.replace(&#x2F;\s+&#x2F;g, &#39;&#39;).replace(&#x2F;\&#x2F;\*.+?\*\&#x2F;&#x2F;g, &#39;&#39;);</span><br><span class="line">            </span><br><span class="line">            callback(null, output);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    read</span><br><span class="line">        .pipe(transform)</span><br><span class="line">        .pipe(write);</span><br><span class="line"></span><br><span class="line">    return read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下执行<code>yarn gulp css</code>,可以看到<code>dist/css</code>下输出的文件<code>style.min.css</code>, 其中内容是处理压缩之后的<br>body{color:#333;}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="gulp-提供了自己的文件API"><a href="#gulp-提供了自己的文件API" class="headerlink" title="gulp 提供了自己的文件API"></a>gulp 提供了自己的文件API</h4><p>通过gulp自己的api实现文件写入读取流</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123;src, dest&#125; &#x3D; require(&#39;gulp&#39;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports.fs &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return src(&#39;css&#x2F;style.css&#39;) &#x2F;&#x2F; &#39;*.css&#39;</span><br><span class="line">        .pipe(dest(&#39;dist&#39;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fs-与-css-压缩"><a href="#fs-与-css-压缩" class="headerlink" title="fs 与 css 压缩"></a>fs 与 css 压缩</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add gulp-clean-css --dev</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 引入css压缩插件</span><br><span class="line">const cleanCss &#x3D; require(&#39;gulp-clean-css&#39;);</span><br><span class="line"></span><br><span class="line">exports.fscss &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return src(&#39;css&#x2F;*.css&#39;)</span><br><span class="line">        .pipe(cleanCss())</span><br><span class="line">        .pipe(dest(&#39;dest&#39;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到输出的css压缩文件在dest目录下</p>
<h4 id="重命名插件"><a href="#重命名插件" class="headerlink" title="重命名插件"></a>重命名插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add gulp-rename --dev</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改拓展名</span><br><span class="line">const cleanCss &#x3D; require(&#39;gulp-clean-css&#39;);</span><br><span class="line"></span><br><span class="line">const rename &#x3D; require(&#39;gulp-rename&#39;);</span><br><span class="line"></span><br><span class="line">exports.fscss &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return src(&#39;css&#x2F;*.css&#39;)</span><br><span class="line">        .pipe(cleanCss())</span><br><span class="line">        .pipe(rename(&#123; extname: &#39;.min.css&#39; &#125;))</span><br><span class="line">        .pipe(dest(&#39;dest&#39;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sass-文件编译"><a href="#sass-文件编译" class="headerlink" title="sass 文件编译"></a>sass 文件编译</h4><p>安装 <code>grunt-sass</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123;src, dest&#125; &#x3D; require(&#39;gulp&#39;);</span><br><span class="line">const sass &#x3D; require(&#39;gulp-sass&#39;);</span><br><span class="line"></span><br><span class="line">const style &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return src(&#39;src&#x2F;assets&#x2F;styles&#x2F;*.scss&#39;, &#123;base: &#39;src&#39;&#125;) &#x2F;&#x2F; base src 保留转换前的基础路径</span><br><span class="line">        .pipe(sass(&#123;</span><br><span class="line">            outputStyle: &#39;expanded&#39;, &#x2F;&#x2F; 代表编译后大括号完全展开</span><br><span class="line">        &#125;)) &#x2F;&#x2F; 下户线开头的css 文件默认不会被转换</span><br><span class="line">        .pipe(dest(&#39;dist&#39;));</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    style</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="脚本文件编译"><a href="#脚本文件编译" class="headerlink" title="脚本文件编译"></a>脚本文件编译</h4><p>安装<code>gulp-babel @babel/core @babel/preset-env</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123;src, dest&#125; &#x3D; require(&#39;gulp&#39;);</span><br><span class="line"></span><br><span class="line">const babel &#x3D; require(&#39;gulp-babel&#39;);</span><br><span class="line">const script &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return src(&#39;src&#x2F;assets&#x2F;scripts&#x2F;*.js&#39;, &#123;</span><br><span class="line">        base: &#39;src&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">        .pipe(babel(&#123;</span><br><span class="line">            presets: [&#39;@babel&#x2F;preset-env&#39;]</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(dest(&#39;dist&#39;));</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    script,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模板文件编译"><a href="#模板文件编译" class="headerlink" title="模板文件编译"></a>模板文件编译</h4><p>可以借助<code>gulp-swig</code></p>
<p>swig 语法这里不过多描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const page &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return src(&#39;src&#x2F;**&#x2F;*.html&#39;, &#123;base: &#39;src&#39;&#125;) &#x2F;&#x2F; src 下任意子目录下的任意html文件</span><br><span class="line">        .pipe(swig(&#123;data: &#123;title: &#39;along&#39;&#125;&#125;))</span><br><span class="line">        .pipe(dest(&#39;dist&#39;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="图片字体文件"><a href="#图片字体文件" class="headerlink" title="图片字体文件"></a>图片字体文件</h4><p>安装<code>gulp-imagemin</code>,图片可以无损压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const iamgemin &#x3D; require(&#39;gulp-imagemin&#39;);</span><br><span class="line">const image &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return src(&#39;src&#x2F;assets&#x2F;images&#x2F;**&#39;, &#123;base: &#39;sec&#39;&#125;)</span><br><span class="line">        .pipe(imagemin())</span><br><span class="line">        .pipe(dest(&#39;dist&#39;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 字体文件不需要特殊处理，只是里边的svg同样可以借助imagemin 来压缩</span><br><span class="line">const font &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return src(&#39;src&#x2F;assets&#x2F;fonts&#x2F;**&#39;, &#123;base: &#39;sec&#39;&#125;)</span><br><span class="line">        .pipe(imagemin())</span><br><span class="line">        .pipe(dest(&#39;dist&#39;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="清除文件"><a href="#清除文件" class="headerlink" title="清除文件"></a>清除文件</h4><p>安装<code>del</code> del 模块不是gulp模块不过可以在gulp中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add del --dev</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const del &#x3D; require(&#39;del&#39;);</span><br><span class="line">&#x2F;&#x2F; 清除文件</span><br><span class="line">const clean &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return del([&#39;dist&#39;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自动加载插件"><a href="#自动加载插件" class="headerlink" title="自动加载插件"></a>自动加载插件</h4><p>安装<code> gulp-load-plugins</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const loadPlugins &#x3D; require(&#39;gulp-load-plugins&#39;);</span><br><span class="line">const plugins &#x3D; loadPlugins();</span><br><span class="line">&#x2F;&#x2F; 之后可以通过plguns[plugin name] 来使用自动加载的插件</span><br><span class="line">const image &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return src(&#39;src&#x2F;assets&#x2F;images&#x2F;**&#39;, &#123;base: &#39;src&#39;&#125;)</span><br><span class="line">        .pipe(plugins.imagemin())</span><br><span class="line">        .pipe(dest(&#39;dist&#39;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果插件名称gulp后有多个横线，会自动你转为驼峰的方式</p>
<h4 id="gulp-开发服务器"><a href="#gulp-开发服务器" class="headerlink" title="gulp 开发服务器"></a>gulp 开发服务器</h4><p>安装 <code>browser-sync</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123;src, dest, series, parallel, watch&#125; &#x3D; require(&#39;gulp&#39;);</span><br><span class="line"></span><br><span class="line">const browserSync &#x3D; require(&#39;browser-sync&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个开发服务器</span><br><span class="line">const bs &#x3D; browserSync.create();</span><br><span class="line"></span><br><span class="line">const serve &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 监听源代码自动编译</span><br><span class="line">    watch(&#39;src&#x2F;assets&#x2F;styles&#x2F;*.scss&#39;, style);</span><br><span class="line">    watch(&#39;src&#x2F;assets&#x2F;scripts&#x2F;*.js&#39;, script);</span><br><span class="line">    watch(&#39;src&#x2F;*.html&#39;, page);</span><br><span class="line">    watch([</span><br><span class="line">        &#39;src&#x2F;assets&#x2F;images&#x2F;**&#39;,</span><br><span class="line">        &#39;src&#x2F;assets&#x2F;fonts&#x2F;**&#39;,</span><br><span class="line">        &#39;public&#x2F;**&#39;</span><br><span class="line">    ], bs.reload);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    bs.init(&#123;</span><br><span class="line">        notify: false, &#x2F;&#x2F; 打开浏览器后，右上角不再显示连接成功的提示</span><br><span class="line">        port: 2080,</span><br><span class="line">        open: true,</span><br><span class="line">        files: &#39;dist&#x2F;**&#39;, &#x2F;&#x2F; 监听dist下的文件变化</span><br><span class="line">        server: &#123;</span><br><span class="line">            &#x2F;&#x2F; baseDir: &#39;dist&#39;,</span><br><span class="line">            baseDir: [&#39;dist&#39;, &#39;src&#39;, &#39;public&#39;], &#x2F;&#x2F; 指定为数组 时开发环境会一次从数组中的目录寻找文件，这种方式可以避免在开发环境打包静态资源，从而提升开发构建速度</span><br><span class="line">            routes: &#123;</span><br><span class="line">                &#39;&#x2F;node_modules&#39;: &#39;node_modules&#39; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bs.init 也可以不通过files字段监听dist目录，可以通过流的方式进行编译文件向浏览器的推送 通过<code>.pipe(bs.reload(&#123;stream: true&#125;)) </code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const page &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return src(&#39;src&#x2F;**&#x2F;*.html&#39;, &#123;base: &#39;src&#39;&#125;) &#x2F;&#x2F; src 下任意子目录下的任意html文件</span><br><span class="line">        .pipe(swig(&#123;data: pagedata&#125;))</span><br><span class="line">        .pipe(dest(&#39;dist&#39;))</span><br><span class="line">        .pipe(bs.reload(&#123;stream: true&#125;)) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const style &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return src(&#39;src&#x2F;assets&#x2F;styles&#x2F;*.scss&#39;, &#123;base: &#39;src&#39;&#125;) &#x2F;&#x2F; base src 保留转换前的基础路径</span><br><span class="line">        .pipe(sass(&#123;</span><br><span class="line">            outputStyle: &#39;expanded&#39;, &#x2F;&#x2F; 代表编译后大括号完全展开</span><br><span class="line">        &#125;)) &#x2F;&#x2F; 下户线开头的css 文件默认不会被转换</span><br><span class="line">        .pipe(dest(&#39;dist&#39;))</span><br><span class="line">        .pipe(bs.reload(&#123;stream: true&#125;)) &#x2F;&#x2F; 以流的方式像浏览器推送变化</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const script &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return src(&#39;src&#x2F;assets&#x2F;scripts&#x2F;*.js&#39;, &#123;</span><br><span class="line">        base: &#39;src&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">        .pipe(babel(&#123;</span><br><span class="line">            presets: [&#39;@babel&#x2F;preset-env&#39;]</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(dest(&#39;dist&#39;))</span><br><span class="line">        .pipe(bs.reload(&#123;stream: true&#125;)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add gulp-htmlmin gulp-uglify gulp-clean-css --dev</span><br></pre></td></tr></table></figure>

<p>额外安装一个判断文件类型的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add gulp-if --dev</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const useref &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return src(&#39;temp&#x2F;**&#x2F;*.html&#39;, &#123;base: &#39;temp&#39;&#125;)</span><br><span class="line">        .pipe(plugins.useref(&#123;searchPath: [&#39;temp&#39;, &#39;.&#39;]&#125;))</span><br><span class="line">        .pipe(plugins.if(&#x2F;\.js$&#x2F;, plugins.uglify()))</span><br><span class="line">        .pipe(plugins.if(&#x2F;\.css$&#x2F;, plugins.cleanCss()))</span><br><span class="line">        .pipe(plugins.if(&#x2F;\.html$&#x2F;, plugins.htmlmin(&#123;</span><br><span class="line">            collapseWhitespace: true, &#x2F;&#x2F; 压缩html</span><br><span class="line">            minifyCSS: true, &#x2F;&#x2F; 压缩行内css</span><br><span class="line">            minifyJS: true, &#x2F;&#x2F; 压缩行内js</span><br><span class="line">        &#125;)))</span><br><span class="line">        .pipe(dest(&#39;dist&#39;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>React 源码解读</title>
    <url>/2020/08/26/React%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="1-配置-React-源码本地调试环境"><a href="#1-配置-React-源码本地调试环境" class="headerlink" title="1. 配置 React 源码本地调试环境"></a>1. 配置 React 源码本地调试环境</h2><ol>
<li><p>使用 create-react-app 脚手架创建项目</p>
<p><code>npx create-react-app react-test</code></p>
</li>
<li><p>弹射 create-react-app 脚手架内部配置</p>
<p><code>npm run eject</code></p>
</li>
<li><p>克隆 react 官方源码 (在项目的根目录下进行克隆)</p>
<p><code>git clone --branch v16.13.1 --depth=1 https://github.com/facebook/react.git src/react</code></p>
</li>
<li><p>链接本地源码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件位置: react-test/config/webpack.config.js</span></span><br><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">&quot;react-native&quot;</span>: <span class="string">&quot;react-native-web&quot;</span>,</span><br><span class="line">    <span class="string">&quot;react&quot;</span>: path.resolve(__dirname, <span class="string">&quot;../src/react/packages/react&quot;</span>),</span><br><span class="line">    <span class="string">&quot;react-dom&quot;</span>: path.resolve(__dirname, <span class="string">&quot;../src/react/packages/react-dom&quot;</span>),</span><br><span class="line">    <span class="string">&quot;shared&quot;</span>: path.resolve(__dirname, <span class="string">&quot;../src/react/packages/shared&quot;</span>),</span><br><span class="line">    <span class="string">&quot;react-reconciler&quot;</span>: path.resolve(__dirname, <span class="string">&quot;../src/react/packages/react-reconciler&quot;</span>),</span><br><span class="line">    <span class="string">&quot;legacy-events&quot;</span>: path.resolve(__dirname, <span class="string">&quot;../src/react/packages/legacy-events&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改环境变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件位置: react-test/config/env.js</span></span><br><span class="line"><span class="keyword">const</span> stringified = &#123;</span><br><span class="line">	<span class="string">&quot;process.env&quot;</span>: <span class="built_in">Object</span>.keys(raw).reduce(<span class="function">(<span class="params">env, key</span>) =&gt;</span> &#123;</span><br><span class="line">   	env[key] = <span class="built_in">JSON</span>.stringify(raw[key])</span><br><span class="line">      <span class="keyword">return</span> env</span><br><span class="line">   &#125;, &#123;&#125;),</span><br><span class="line">   __DEV__: <span class="literal">true</span>,</span><br><span class="line">   SharedArrayBuffer: <span class="literal">true</span>,</span><br><span class="line">   spyOnDev: <span class="literal">true</span>,</span><br><span class="line">   spyOnDevAndProd: <span class="literal">true</span>,</span><br><span class="line">   spyOnProd: <span class="literal">true</span>,</span><br><span class="line">   __PROFILE__: <span class="literal">true</span>,</span><br><span class="line">   __UMD__: <span class="literal">true</span>,</span><br><span class="line">   __EXPERIMENTAL__: <span class="literal">true</span>,</span><br><span class="line">   __VARIANT__: <span class="literal">true</span>,</span><br><span class="line">   gate: <span class="literal">true</span>,</span><br><span class="line">   trustedTypes: <span class="literal">true</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>告诉 babel 在转换代码时忽略类型检查</p>
<p><code>npm install @babel/plugin-transform-flow-strip-types -D</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件位置: react-test/config/webpack.config.js [babel-loader]</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="built_in">require</span>.resolve(<span class="string">&quot;@babel/plugin-transform-flow-strip-types&quot;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出 HostConfig</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件位置: /react/packages/react-reconciler/src/ReactFiberHostConfig.js</span></span><br><span class="line">+ <span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./forks/ReactFiberHostConfig.dom&#x27;</span>;</span><br><span class="line">- invariant(<span class="literal">false</span>, <span class="string">&#x27;This module must be shimmed by a specific renderer.&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 ReactSharedInternals.js 文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件位置: /react/packages/shared/ReactSharedInternals.js</span></span><br><span class="line">- <span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">- <span class="keyword">const</span> ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;</span><br><span class="line">+ <span class="keyword">import</span> ReactSharedInternals <span class="keyword">from</span> <span class="string">&#x27;../react/src/ReactSharedInternals&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭 eslint 扩展</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件位置: react/.eslingrc.js [module.exports]</span></span><br><span class="line"><span class="comment">// 删除 extends</span></span><br><span class="line"><span class="keyword">extends</span>: [</span><br><span class="line">  <span class="string">&#x27;fbjs&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;prettier&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>禁止 invariant 报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件位置: /react/packages/shared/invariant.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">invariant</span>(<span class="params">condition, format, a, b, c, d, e, f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (condition) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">    <span class="string">&#x27;Internal React error: invariant() is meant to be replaced at compile &#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;time. There is no runtime version.&#x27;</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>eslint 配置</p>
<p>在 react 源码文件夹中新建 .eslintrc.json 并添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: &quot;react-app&quot;,</span><br><span class="line">  &quot;globals&quot;: &#123;</span><br><span class="line">    &quot;SharedArrayBuffer&quot;: true,</span><br><span class="line">    &quot;spyOnDev&quot;: true,</span><br><span class="line">    &quot;spyOnDevAndProd&quot;: true,</span><br><span class="line">    &quot;spyOnProd&quot;: true,</span><br><span class="line">    &quot;__PROFILE__&quot;: true,</span><br><span class="line">    &quot;__UMD__&quot;: true,</span><br><span class="line">    &quot;__EXPERIMENTAL__&quot;: true,</span><br><span class="line">    &quot;__VARIANT__&quot;: true,</span><br><span class="line">    &quot;gate&quot;: true,</span><br><span class="line">    &quot;trustedTypes&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 react react-dom 引入方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解决 vsCode 中 flow 报错</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;javascript.validate.enable&quot;</span>: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可选项配置</p>
<p>如果你的 vscode 编辑器安装了 prettier 插件并且在保存 react 源码文件时右下角出现如下错误，按照如下步骤解决</p>
<img src="./images/1.png" width="60%" align="left"/>

<ol>
<li><p>全局安装 prettier</p>
<p><code>npm i prettier -g</code></p>
</li>
<li><p>配置 prettier path</p>
<p>Settings &gt; Extensions &gt; Prettier &gt; Prettier path</p>
<img src="./images/2.png" width="80%" align="left"/>
</li>
</ol>
</li>
<li><p>__DEV__ 报错</p>
<p>删除 node_modules 文件夹，执行 npm install</p>
</li>
</ol>
<h2 id="2-创建-React-元素"><a href="#2-创建-React-元素" class="headerlink" title="2. 创建 React 元素"></a>2. 创建 React 元素</h2><p>JSX 被 Babel 编译为 React.createElement 方法的调用，createElement 方法在调用后返回的就是 ReactElement，就是 virtualDOM。</p>
<h3 id="2-1-createElement"><a href="#2-1-createElement" class="headerlink" title="2.1 createElement"></a>2.1 createElement</h3><p><code>文件位置：packages/react/src/ReactElement.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 创建 React Element</span><br><span class="line"> * type      元素类型</span><br><span class="line"> * config    配置属性</span><br><span class="line"> * children  子元素</span><br><span class="line"> * 1. 分离 props 属性和特殊属性</span><br><span class="line"> * 2. 将子元素挂载到 props.children 中</span><br><span class="line"> * 3. 为 props 属性赋默认值 (defaultProps)</span><br><span class="line"> * 4. 创建并返回 ReactElement</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function createElement(type, config, children) &#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * propName -&gt; 属性名称</span><br><span class="line">   * 用于后面的 for 循环</span><br><span class="line">   *&#x2F;</span><br><span class="line">  let propName;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 存储 React Element 中的普通元素属性 即不包含 key ref self source</span><br><span class="line">   *&#x2F;</span><br><span class="line">  const props &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 待提取属性</span><br><span class="line">   * React 内部为了实现某些功能而存在的属性</span><br><span class="line">   *&#x2F;</span><br><span class="line">  let key &#x3D; null;</span><br><span class="line">  let ref &#x3D; null;</span><br><span class="line">  let self &#x3D; null;</span><br><span class="line">  let source &#x3D; null;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果 config 不为 null</span><br><span class="line">  if (config !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果 config 对象中有合法的 ref 属性</span><br><span class="line">    if (hasValidRef(config)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 将 config.ref 属性提取到 ref 变量中</span><br><span class="line">      ref &#x3D; config.ref;</span><br><span class="line">      &#x2F;&#x2F; 在开发环境中</span><br><span class="line">      if (__DEV__) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果 ref 属性的值被设置成了字符串形式就报一个提示</span><br><span class="line">        &#x2F;&#x2F; 说明此用法在将来的版本中会被删除</span><br><span class="line">        warnIfStringRefCannotBeAutoConverted(config);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果在 config 对象中拥有合法的 key 属性</span><br><span class="line">    if (hasValidKey(config)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 将 config.key 属性中的值提取到 key 变量中</span><br><span class="line">      key &#x3D; &#39;&#39; + config.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self &#x3D; config.__self &#x3D;&#x3D;&#x3D; undefined ? null : config.__self;</span><br><span class="line">    source &#x3D; config.__source &#x3D;&#x3D;&#x3D; undefined ? null : config.__source;</span><br><span class="line">    &#x2F;&#x2F; 遍历 config 对象</span><br><span class="line">    for (propName in config) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果当前遍历到的属性是对象自身属性</span><br><span class="line">      &#x2F;&#x2F; 并且在 RESERVED_PROPS 对象中不存在该属性</span><br><span class="line">      if (</span><br><span class="line">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">        !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将满足条件的属性添加到 props 对象中 (普通属性)</span><br><span class="line">        props[propName] &#x3D; config[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 将第三个及之后的参数挂载到 props.children 属性中</span><br><span class="line">   * 如果子元素是多个 props.children 是数组</span><br><span class="line">   * 如果子元素是一个 props.children 是对象</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 由于从第三个参数开始及以后都表示子元素</span><br><span class="line">  &#x2F;&#x2F; 所以减去前两个参数的结果就是子元素的数量</span><br><span class="line">  const childrenLength &#x3D; arguments.length - 2;</span><br><span class="line">  &#x2F;&#x2F; 如果子元素的数量是 1</span><br><span class="line">  if (childrenLength &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 直接将子元素挂载到到 props.children 属性上</span><br><span class="line">    &#x2F;&#x2F; 此时 children 是对象类型</span><br><span class="line">    props.children &#x3D; children;</span><br><span class="line">    &#x2F;&#x2F; 如果子元素的数量大于 1</span><br><span class="line">  &#125; else if (childrenLength &gt; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建数组, 数组中元素的数量等于子元素的数量</span><br><span class="line">    const childArray &#x3D; Array(childrenLength);</span><br><span class="line">    &#x2F;&#x2F; 开启循环 循环次匹配子元素的数量</span><br><span class="line">    for (let i &#x3D; 0; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 将子元素添加到 childArray 数组中</span><br><span class="line">      &#x2F;&#x2F; i + 2 的原因是实参集合的前两个参数不是子元素</span><br><span class="line">      childArray[i] &#x3D; arguments[i + 2];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果是开发环境</span><br><span class="line">    if (__DEV__) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果 Object 对象中存在 freeze 方法</span><br><span class="line">      if (Object.freeze) &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用 freeze 方法 冻结 childArray 数组</span><br><span class="line">        &#x2F;&#x2F; 防止 React 核心对象被修改 冻结对象提高性能</span><br><span class="line">        Object.freeze(childArray);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 将子元素数组挂载到 props.children 属性中</span><br><span class="line">    props.children &#x3D; childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 如果当前处理是组件</span><br><span class="line">   * 看组件身上是否有 defaultProps 属性</span><br><span class="line">   * 这个属性中存储的是 props 对象中属性的默认值</span><br><span class="line">   * 遍历 defaultProps 对象 查看对应的 props 属性的值是否为 undefined</span><br><span class="line">   * 如果为undefined 就将默认值赋值给对应的 props 属性值</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 将 type 属性值视为函数 查看其中是否具有 defaultProps 属性</span><br><span class="line">  if (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 type 函数下的 defaultProps 属性赋值给 defaultProps 变量</span><br><span class="line">    const defaultProps &#x3D; type.defaultProps;</span><br><span class="line">    &#x2F;&#x2F; 遍历 defaultProps 对象中的属性 将属性名称赋值给 propName 变量</span><br><span class="line">    for (propName in defaultProps) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果 props 对象中的该属性的值为 undefined</span><br><span class="line">      if (props[propName] &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将 defaultProps 对象中的对应属性的值赋值给 props 对象中的对应属性的值</span><br><span class="line">        props[propName] &#x3D; defaultProps[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 在开发环境中 如果元素的 key 属性 或者 ref 属性存在</span><br><span class="line">   * 监测开发者是否在组件内部通过 props 对象获取了 key 属性或者 ref 属性</span><br><span class="line">   * 如果获取了 就报错</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果处于开发环境</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    &#x2F;&#x2F; 元素具有 key 属性或者 ref 属性</span><br><span class="line">    if (key || ref) &#123;</span><br><span class="line">      &#x2F;&#x2F; 看一下 type 属性中存储的是否是函数 如果是函数就表示当前元素是组件</span><br><span class="line">      &#x2F;&#x2F; 如果元素不是组件 就直接返回元素类型字符串</span><br><span class="line">      &#x2F;&#x2F; displayName 用于在报错过程中显示是哪一个组件报错了</span><br><span class="line">      &#x2F;&#x2F; 如果开发者显式定义了 displayName 属性 就显示开发者定义的</span><br><span class="line">      &#x2F;&#x2F; 否者就显示组件名称 如果组件也没有名称 就显示 &#39;Unknown&#39;</span><br><span class="line">      const displayName &#x3D;</span><br><span class="line">        typeof type &#x3D;&#x3D;&#x3D; &#39;function&#39;</span><br><span class="line">          ? type.displayName || type.name || &#39;Unknown&#39;</span><br><span class="line">          : type;</span><br><span class="line">      &#x2F;&#x2F; 如果 key 属性存在</span><br><span class="line">      if (key) &#123;</span><br><span class="line">        &#x2F;&#x2F; 为 props 对象添加key 属性</span><br><span class="line">        &#x2F;&#x2F; 并指定当通过 props 对象获取 key 属性时报错</span><br><span class="line">        defineKeyPropWarningGetter(props, displayName);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 如果 ref 属性存在</span><br><span class="line">      if (ref) &#123;</span><br><span class="line">        &#x2F;&#x2F; 为 props 对象添加 ref 属性</span><br><span class="line">        &#x2F;&#x2F; 并指定当通过 props 对象获取 ref 属性时报错</span><br><span class="line">        defineRefPropWarningGetter(props, displayName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 返回 ReactElement</span><br><span class="line">  return ReactElement(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    &#x2F;&#x2F; 在 Virtual DOM 中用于识别自定义组件</span><br><span class="line">    ReactCurrentOwner.current,</span><br><span class="line">    props,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-ReactElement"><a href="#2-2-ReactElement" class="headerlink" title="2.2 ReactElement"></a>2.2 ReactElement</h3><p><code>文件位置：packages/react/src/ReactElement.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 接收参数 返回 ReactElement</span><br><span class="line"> *&#x2F;</span><br><span class="line">const ReactElement &#x3D; function (type, key, ref, self, source, owner, props) &#123;</span><br><span class="line">  const element &#x3D; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 组件的类型, 十六进制数值或者 Symbol 值</span><br><span class="line">     * React 在最终在渲染 DOM 的时候, 需要确保元素的类型是 REACT_ELEMENT_TYPE</span><br><span class="line">     * 需要此属性作为判断的依据</span><br><span class="line">     *&#x2F;</span><br><span class="line">    $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 元素具体的类型值 如果是元素节点 type 属性中存储的就是 div span 等等</span><br><span class="line">     * 如果元素是组件 type 属性中存储的就是组件的构造函数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    type: type,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 元素的唯一标识</span><br><span class="line">     * 用作内部 vdom 比对 提升 DOM 操作性能</span><br><span class="line">     *&#x2F;</span><br><span class="line">    key: key,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 存储元素 DOM 对象或者组件 实例对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    ref: ref,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 存储向组件内部传递的数据</span><br><span class="line">     *&#x2F;</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 记录当前元素所属组件 (记录当前元素是哪个组件创建的)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    _owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line">  &#x2F;&#x2F; 返回 ReactElement</span><br><span class="line">  return element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-hasValidRef"><a href="#2-3-hasValidRef" class="headerlink" title="2.3 hasValidRef"></a>2.3 hasValidRef</h3><p><code>文件位置：packages/react/src/ReactElement.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 查看参数对象中是否有合法的 ref 属性</span><br><span class="line"> * 返回布尔值</span><br><span class="line"> *&#x2F;</span><br><span class="line">function hasValidRef(config) &#123;</span><br><span class="line">  return config.ref !&#x3D;&#x3D; undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-hasValidKey"><a href="#2-4-hasValidKey" class="headerlink" title="2.4 hasValidKey"></a>2.4 hasValidKey</h3><p><code>文件位置：packages/react/src/ReactElement.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 查看参数对象中是否有合法的 key 属性</span><br><span class="line"> * 返回布尔值</span><br><span class="line"> *&#x2F;</span><br><span class="line">function hasValidKey(config) &#123;</span><br><span class="line">  return config.key !&#x3D;&#x3D; undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-isValidElement"><a href="#2-5-isValidElement" class="headerlink" title="2.5 isValidElement"></a>2.5 isValidElement</h3><p><code>文件位置：packages/react/src/ReactElement.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 验证 object 参数是否是 ReactElement. 返回布尔值</span><br><span class="line"> * 验证成功的条件:</span><br><span class="line"> * object 是对象</span><br><span class="line"> * object 不为null</span><br><span class="line"> * object对象中的 $$typeof 属性值为 REACT_ELEMENT_TYPE</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function isValidElement(object) &#123;</span><br><span class="line">  return (</span><br><span class="line">    typeof object &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp;</span><br><span class="line">    object !&#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">    object.$$typeof &#x3D;&#x3D;&#x3D; REACT_ELEMENT_TYPE</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-defineKeyPropWarningGetter"><a href="#2-6-defineKeyPropWarningGetter" class="headerlink" title="2.6 defineKeyPropWarningGetter"></a>2.6 defineKeyPropWarningGetter</h3><p><code>文件位置：packages/react/src/ReactElement.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  指定当通过 props 对象获取 key 属性时报错</span><br><span class="line"> *  props        组件中的 props 对象</span><br><span class="line"> *  displayName  组件名称标识</span><br><span class="line"> *&#x2F;</span><br><span class="line">function defineKeyPropWarningGetter(props, displayName) &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过 props 对象获取 key 属性报错</span><br><span class="line">  const warnAboutAccessingKey &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 在开发环境中</span><br><span class="line">    if (__DEV__) &#123;</span><br><span class="line">      &#x2F;&#x2F; specialPropKeyWarningShown 控制错误只输出一次的变量</span><br><span class="line">      if (!specialPropKeyWarningShown) &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过 specialPropKeyWarningShown 变量锁住判断条件</span><br><span class="line">        specialPropKeyWarningShown &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 指定报错信息和组件名称</span><br><span class="line">        console.error(</span><br><span class="line">          &#39;%s: &#96;key&#96; is not a prop. Trying to access it will result &#39; +</span><br><span class="line">            &#39;in &#96;undefined&#96; being returned. If you need to access the same &#39; +</span><br><span class="line">            &#39;value within the child component, you should pass it as a different &#39; +</span><br><span class="line">            &#39;prop. (https:&#x2F;&#x2F;reactjs.org&#x2F;link&#x2F;special-props)&#39;,</span><br><span class="line">          displayName,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  warnAboutAccessingKey.isReactWarning &#x3D; true;</span><br><span class="line">  &#x2F;&#x2F; 为 props 对象添加 key 属性</span><br><span class="line">  Object.defineProperty(props, &#39;key&#39;, &#123;</span><br><span class="line">    &#x2F;&#x2F; 当获取 key 属性时调用 warnAboutAccessingKey 方法进行报错</span><br><span class="line">    get: warnAboutAccessingKey,</span><br><span class="line">    configurable: true,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-defineRefPropWarningGetter"><a href="#2-7-defineRefPropWarningGetter" class="headerlink" title="2.7 defineRefPropWarningGetter"></a>2.7 defineRefPropWarningGetter</h3><p><code>文件位置：packages/react/src/ReactElement.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  指定当通过 props 对象获取 ref 属性时报错</span><br><span class="line"> *  props        组件中的 props 对象</span><br><span class="line"> *  displayName  组件名称标识</span><br><span class="line"> *&#x2F;</span><br><span class="line">function defineRefPropWarningGetter(props, displayName) &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过 props 对象获取 ref 属性报错</span><br><span class="line">  const warnAboutAccessingRef &#x3D; function () &#123;</span><br><span class="line">    if (__DEV__) &#123;</span><br><span class="line">      &#x2F;&#x2F; specialPropRefWarningShown 控制错误只输出一次的变量</span><br><span class="line">      if (!specialPropRefWarningShown) &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过 specialPropRefWarningShown 变量锁住判断条件</span><br><span class="line">        specialPropRefWarningShown &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 指定报错信息和组件名称</span><br><span class="line">        console.error(</span><br><span class="line">          &#39;%s: &#96;ref&#96; is not a prop. Trying to access it will result &#39; +</span><br><span class="line">            &#39;in &#96;undefined&#96; being returned. If you need to access the same &#39; +</span><br><span class="line">            &#39;value within the child component, you should pass it as a different &#39; +</span><br><span class="line">            &#39;prop. (https:&#x2F;&#x2F;reactjs.org&#x2F;link&#x2F;special-props)&#39;,</span><br><span class="line">          displayName,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  warnAboutAccessingRef.isReactWarning &#x3D; true;</span><br><span class="line">  &#x2F;&#x2F; 为 props 对象添加 key 属性</span><br><span class="line">  Object.defineProperty(props, &#39;ref&#39;, &#123;</span><br><span class="line">    get: warnAboutAccessingRef,</span><br><span class="line">    configurable: true,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-React-架构"><a href="#3-React-架构" class="headerlink" title="3. React 架构"></a>3. React 架构</h2><p>React 16 版本的架构可以分为三层：调度层、协调层、渲染层。</p>
<ul>
<li>Scheduler (调度层)：调度任务的优先级，高优任务优先进入协调器</li>
<li>Reconciler (协调层)：构建 Fiber 数据结构，比对 Fiber 对象找出差异, 记录 Fiber 对象要进行的 DOM 操作</li>
<li>Renderer (渲染层)：负责将发生变化的部分渲染到页面上</li>
</ul>
<h3 id="3-1-Scheduler-调度层"><a href="#3-1-Scheduler-调度层" class="headerlink" title="3.1 Scheduler 调度层"></a>3.1 Scheduler 调度层</h3><p>在 React 15 的版本中，采用了循环加递归的方式进行了 virtualDOM 的比对，由于递归使用 JavaScript 自身的执行栈，一旦开始就无法停止，直到任务执行完成。如果 VirtualDOM 树的层级比较深，virtualDOM 的比对就会长期占用 JavaScript 主线程，由于 JavaScript 又是单线程的无法同时执行其他任务，所以在比对的过程中无法响应用户操作，无法即时执行元素动画，造成了页面卡顿的现象。</p>
<p>在 React 16 的版本中，放弃了 JavaScript 递归的方式进行 virtualDOM 的比对，而是采用循环模拟递归。而且比对的过程是利用浏览器的空闲时间完成的，不会长期占用主线程，这就解决了 virtualDOM 比对造成页面卡顿的问题。</p>
<p>在 window 对象中提供了 requestIdleCallback API，它可以利用浏览器的空闲时间执行任务，但是它自身也存在一些问题，比如说并不是所有的浏览器都支持它，而且它的触发频率也不是很稳定，所以 React 最终放弃了 requestIdleCallback 的使用。</p>
<p>在 React 中，官方实现了自己的任务调度库，这个库就叫做 Scheduler。它也可以实现在浏览器空闲时执行任务，而且还可以设置任务的优先级，高优先级任务先执行，低优先级任务后执行。</p>
<p>Scheduler 存储在 <code>packages/scheduler</code> 文件夹中。</p>
<h3 id="3-2-Reconciler-协调层"><a href="#3-2-Reconciler-协调层" class="headerlink" title="3.2 Reconciler 协调层"></a>3.2 Reconciler 协调层</h3><p>在 React 15 的版本中，协调器和渲染器交替执行，即找到了差异就直接更新差异。在 React 16 的版本中，这种情况发生了变化，协调器和渲染器不再交替执行。协调器负责找出差异，在所有差异找出之后，统一交给渲染器进行 DOM 的更新。也就是说协调器的主要任务就是找出差异部分，并为差异打上标记。</p>
<h3 id="3-3-Renderer-渲染层"><a href="#3-3-Renderer-渲染层" class="headerlink" title="3.3 Renderer 渲染层"></a>3.3 Renderer 渲染层</h3><p>渲染器根据协调器为 Fiber 节点打的标记，同步执行对应的DOM操作。</p>
<p>既然比对的过程从递归变成了可以中断的循环，那么 React 是如何解决中断更新时 DOM 渲染不完全的问题呢？</p>
<p>其实根本就不存在这个问题，因为在整个过程中，调度器和协调器的工作是在内存中完成的是可以被打断的，渲染器的工作被设定成不可以被打断，所以不存在DOM 渲染不完全的问题。</p>
<h2 id="4-数据结构"><a href="#4-数据结构" class="headerlink" title="4. 数据结构"></a>4. 数据结构</h2><h3 id="4-1-Fiber"><a href="#4-1-Fiber" class="headerlink" title="4.1 Fiber"></a>4.1 Fiber</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Fiber &#x3D; &#123;</span><br><span class="line">  &#x2F;************************  DOM 实例相关  *****************************&#x2F;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 标记不同的组件类型, 值详见 WorkTag</span><br><span class="line">  tag: WorkTag,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 组件类型 div、span、组件构造函数</span><br><span class="line">  type: any,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 实例对象, 如类组件的实例、原生 dom 实例, 而 function 组件没有实例, 因此该属性是空</span><br><span class="line">  stateNode: any,</span><br><span class="line"> </span><br><span class="line">	&#x2F;************************  构建 Fiber 树相关  ***************************&#x2F;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 指向自己的父级 Fiber 对象</span><br><span class="line">  return: Fiber | null,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 指向自己的第一个子级 Fiber 对象</span><br><span class="line">  child: Fiber | null,</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 指向自己的下一个兄弟 iber 对象</span><br><span class="line">  sibling: Fiber | null,</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 在 Fiber 树更新的过程中，每个 Fiber 都会有一个跟其对应的 Fiber</span><br><span class="line">  &#x2F;&#x2F; 我们称他为 current &lt;&#x3D;&#x3D;&gt; workInProgress</span><br><span class="line">  &#x2F;&#x2F; 在渲染完成之后他们会交换位置</span><br><span class="line">  &#x2F;&#x2F; alternate 指向当前 Fiber 在 workInProgress 树中的对应 Fiber</span><br><span class="line">	alternate: Fiber | null,</span><br><span class="line">		</span><br><span class="line">  &#x2F;************************  状态数据相关  ********************************&#x2F;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 即将更新的 props</span><br><span class="line">  pendingProps: any, </span><br><span class="line">  &#x2F;&#x2F; 旧的 props</span><br><span class="line">  memoizedProps: any,</span><br><span class="line">  &#x2F;&#x2F; 旧的 state</span><br><span class="line">  memoizedState: any,</span><br><span class="line">		</span><br><span class="line">  &#x2F;************************  副作用相关 ******************************&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 该 Fiber 对应的组件产生的状态更新会存放在这个队列里面 </span><br><span class="line">  updateQueue: UpdateQueue&lt;any&gt; | null,</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 用来记录当前 Fiber 要执行的 DOM 操作</span><br><span class="line">  effectTag: SideEffectTag,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 存储要执行的 DOM 操作</span><br><span class="line">  firstEffect: Fiber | null,</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 单链表用来快速查找下一个 side effect</span><br><span class="line">  nextEffect: Fiber | null,</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 存储 DOM 操作完后的副租用 比如调用生命周期函数或者钩子函数的调用</span><br><span class="line">  lastEffect: Fiber | null,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 任务的过期时间</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">  </span><br><span class="line">	&#x2F;&#x2F; 当前组件及子组件处于何种渲染模式 详见 TypeOfMode</span><br><span class="line">  mode: TypeOfMode,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="./images/6.png"/>

<h3 id="4-2-WorkTag"><a href="#4-2-WorkTag" class="headerlink" title="4.2 WorkTag"></a>4.2 WorkTag</h3><p><code>文件位置：packages/shared/ReactWorkTags.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type WorkTag &#x3D;</span><br><span class="line">  | 0</span><br><span class="line">  | 1</span><br><span class="line">  | 2</span><br><span class="line">  | 3</span><br><span class="line">  | 4</span><br><span class="line">  | 5</span><br><span class="line">  | 6</span><br><span class="line">  | 7</span><br><span class="line">  | 8</span><br><span class="line">  | 9</span><br><span class="line">  | 10</span><br><span class="line">  | 11</span><br><span class="line">  | 12</span><br><span class="line">  | 13</span><br><span class="line">  | 14</span><br><span class="line">  | 15</span><br><span class="line">  | 16</span><br><span class="line">  | 17</span><br><span class="line">  | 18</span><br><span class="line">  | 19</span><br><span class="line">  | 20</span><br><span class="line">  | 21</span><br><span class="line">  | 22;</span><br><span class="line"></span><br><span class="line">export const FunctionComponent &#x3D; 0;</span><br><span class="line">export const ClassComponent &#x3D; 1;</span><br><span class="line">export const IndeterminateComponent &#x3D; 2;</span><br><span class="line">export const HostRoot &#x3D; 3;</span><br><span class="line">export const HostPortal &#x3D; 4;</span><br><span class="line">export const HostComponent &#x3D; 5;</span><br><span class="line">export const HostText &#x3D; 6;</span><br><span class="line">export const Fragment &#x3D; 7;</span><br><span class="line">export const Mode &#x3D; 8;</span><br><span class="line">export const ContextConsumer &#x3D; 9;</span><br><span class="line">export const ContextProvider &#x3D; 10;</span><br><span class="line">export const ForwardRef &#x3D; 11;</span><br><span class="line">export const Profiler &#x3D; 12;</span><br><span class="line">export const SuspenseComponent &#x3D; 13;</span><br><span class="line">export const MemoComponent &#x3D; 14;</span><br><span class="line">export const SimpleMemoComponent &#x3D; 15;</span><br><span class="line">export const LazyComponent &#x3D; 16;</span><br><span class="line">export const IncompleteClassComponent &#x3D; 17;</span><br><span class="line">export const DehydratedFragment &#x3D; 18;</span><br><span class="line">export const SuspenseListComponent &#x3D; 19;</span><br><span class="line">export const FundamentalComponent &#x3D; 20;</span><br><span class="line">export const ScopeComponent &#x3D; 21;</span><br><span class="line">export const Block &#x3D; 22;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-TypeOfMode"><a href="#4-3-TypeOfMode" class="headerlink" title="4.3 TypeOfMode"></a>4.3 TypeOfMode</h3><p><code>文件位置: packages/react-reconciler/src/ReactTypeOfMode.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export type TypeOfMode &#x3D; number;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 0 同步渲染模式</span><br><span class="line">export const NoMode &#x3D; 0b0000;</span><br><span class="line">&#x2F;&#x2F; 1 严格模式</span><br><span class="line">export const StrictMode &#x3D; 0b0001;</span><br><span class="line">&#x2F;&#x2F; 10 异步渲染过渡模式</span><br><span class="line">export const BlockingMode &#x3D; 0b0010;</span><br><span class="line">&#x2F;&#x2F; 100 异步渲染模式</span><br><span class="line">export const ConcurrentMode &#x3D; 0b0100;</span><br><span class="line">&#x2F;&#x2F; 1000 性能测试模式</span><br><span class="line">export const ProfileMode &#x3D; 0b1000;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-SideEffectTag"><a href="#4-3-SideEffectTag" class="headerlink" title="4.3 SideEffectTag"></a>4.3 SideEffectTag</h3><p><code>文件位置：packages/shared/ReactSideEffectTags.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export type SideEffectTag &#x3D; number;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Don&#39;t change these two values. They&#39;re used by React Dev Tools.</span><br><span class="line">export const NoEffect &#x3D; &#x2F;*              *&#x2F; 0b0000000000000; &#x2F;&#x2F; 0</span><br><span class="line">export const PerformedWork &#x3D; &#x2F;*         *&#x2F; 0b0000000000001; &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; You can change the rest (and add more).</span><br><span class="line">export const Placement &#x3D; &#x2F;*             *&#x2F; 0b0000000000010; &#x2F;&#x2F; 2</span><br><span class="line">export const Update &#x3D; &#x2F;*                *&#x2F; 0b0000000000100; &#x2F;&#x2F; 4</span><br><span class="line">export const PlacementAndUpdate &#x3D; &#x2F;*    *&#x2F; 0b0000000000110; &#x2F;&#x2F; 6</span><br><span class="line">export const Deletion &#x3D; &#x2F;*              *&#x2F; 0b0000000001000; &#x2F;&#x2F; 8</span><br><span class="line">export const ContentReset &#x3D; &#x2F;*          *&#x2F; 0b0000000010000; &#x2F;&#x2F; 16</span><br><span class="line">export const Callback &#x3D; &#x2F;*              *&#x2F; 0b0000000100000; &#x2F;&#x2F; 32</span><br><span class="line">export const DidCapture &#x3D; &#x2F;*            *&#x2F; 0b0000001000000; &#x2F;&#x2F; 64</span><br><span class="line">export const Ref &#x3D; &#x2F;*                   *&#x2F; 0b0000010000000; &#x2F;&#x2F; 128</span><br><span class="line">export const Snapshot &#x3D; &#x2F;*              *&#x2F; 0b0000100000000; &#x2F;&#x2F; 256</span><br><span class="line">export const Passive &#x3D; &#x2F;*               *&#x2F; 0b0001000000000; &#x2F;&#x2F; 512</span><br><span class="line">export const Hydrating &#x3D; &#x2F;*             *&#x2F; 0b0010000000000; &#x2F;&#x2F; 1024</span><br><span class="line">export const HydratingAndUpdate &#x3D; &#x2F;*    *&#x2F; 0b0010000000100; &#x2F;&#x2F; 1028</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Passive &amp; Update &amp; Callback &amp; Ref &amp; Snapshot</span><br><span class="line">export const LifecycleEffectMask &#x3D; &#x2F;*   *&#x2F; 0b0001110100100; &#x2F;&#x2F; 932</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Union of all host effects</span><br><span class="line">export const HostEffectMask &#x3D; &#x2F;*        *&#x2F; 0b0011111111111; &#x2F;&#x2F; 2047</span><br><span class="line"></span><br><span class="line">export const Incomplete &#x3D; &#x2F;*            *&#x2F; 0b0100000000000; &#x2F;&#x2F; 2048</span><br><span class="line">export const ShouldCapture &#x3D; &#x2F;*         *&#x2F; 0b1000000000000; &#x2F;&#x2F; 4096</span><br></pre></td></tr></table></figure>

<h3 id="4-4-Update"><a href="#4-4-Update" class="headerlink" title="4.4 Update"></a>4.4 Update</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let update: Update&lt;*&gt; &#x3D; &#123;</span><br><span class="line">  expirationTime,</span><br><span class="line">  suspenseConfig,</span><br><span class="line"></span><br><span class="line">  tag: UpdateState,</span><br><span class="line">  payload: null,</span><br><span class="line">  callback: null,</span><br><span class="line"></span><br><span class="line">  next: (null: any),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-UpdateQueue"><a href="#4-5-UpdateQueue" class="headerlink" title="4.5 UpdateQueue"></a>4.5 UpdateQueue</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const queue: &lt;State&gt; &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 上一次更新之后的 state, 作为下一次更新的基础</span><br><span class="line">  baseState: fiber.memoizedState,</span><br><span class="line">  baseQueue: null,</span><br><span class="line">  shared: &#123;</span><br><span class="line">    pending: null,</span><br><span class="line">  &#125;,</span><br><span class="line">  effects: null,</span><br><span class="line">&#125;</span><br><span class="line">fiber.updateQueue &#x3D; queue;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-RootTag"><a href="#4-6-RootTag" class="headerlink" title="4.6 RootTag"></a>4.6 RootTag</h3><p><code>文件位置：packages/shared/ReactRootTags.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export type RootTag &#x3D; 0 | 1 | 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ReactDOM.render</span><br><span class="line">export const LegacyRoot &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F; ReactDOM.createBlockingRoot</span><br><span class="line">export const BlockingRoot &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F; ReactDOM.createRoot</span><br><span class="line">export const ConcurrentRoot &#x3D; 2;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-双缓存技术"><a href="#4-7-双缓存技术" class="headerlink" title="4.7 双缓存技术"></a>4.7 双缓存技术</h3><p>在 React 中，DOM 的更新采用了双缓存技术，双缓存技术致力于更快速的 DOM 更新。</p>
<p>什么是双缓存？举个例子，使用 canvas 绘制动画时，在绘制每一帧前都会清除上一帧的画面，清除上一帧需要花费时间，如果当前帧画面计算量又比较大，又需要花费比较长的时间，这就导致上一帧清除到下一帧显示中间会有较长的间隙，就会出现白屏。</p>
<p>为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，这样的话在帧画面替换的过程中就会节约非常多的时间，就不会出现白屏问题。这种在内存中构建并直接替换的技术叫做双缓存。</p>
<p>React 使用双缓存技术完成 Fiber 树的构建与替换，实现DOM对象的快速更新。</p>
<p>在 React 中最多会同时存在两棵 Fiber 树，当前在屏幕中显示的内容对应的 Fiber 树叫做 current Fiber 树，当发生更新时，React 会在内存中重新构建一颗新的 Fiber 树，这颗正在构建的 Fiber 树叫做 workInProgress Fiber 树。在双缓存技术中，workInProgress Fiber 树就是即将要显示在页面中的 Fiber 树，当这颗 Fiber 树构建完成后，React 会使用它直接替换 current Fiber 树达到快速更新 DOM 的目的，因为 workInProgress Fiber 树是在内存中构建的所以构建它的速度是非常快的。</p>
<p>一旦 workInProgress Fiber 树在屏幕上呈现，它就会变成 current Fiber 树。</p>
<p>在 current Fiber 节点对象中有一个 alternate 属性指向对应的 workInProgress Fiber 节点对象，在 workInProgress Fiber 节点中有一个 alternate 属性也指向对应的 current Fiber 节点对象。</p>
<img src="./images/3.png" width="40%"/>

<img src="./images/4.png" width="40%"/>

<h3 id="4-8-区分-fiberRoot-与-rootFiber"><a href="#4-8-区分-fiberRoot-与-rootFiber" class="headerlink" title="4.8 区分 fiberRoot 与 rootFiber"></a>4.8 区分 fiberRoot 与 rootFiber</h3><p>fiberRoot 表示 Fiber 数据结构对象，是 Fiber 数据结构中的最外层对象</p>
<p>rootFiber 表示组件挂载点对应的 Fiber 对象，比如 React 应用中默认的组件挂载点就是 id 为 root 的 div</p>
<p>fiberRoot 包含 rootFiber，在 fiberRoot 对象中有一个 current 属性，存储 rootFiber</p>
<p>rootFiber 指向 fiberRoot，在 rootFiber 对象中有一个 stateNode 属性，指向 fiberRoot</p>
<p>在 React 应用中 FiberRoot 只有一个，而 rootFiber 可以有多个，因为 render 方法是可以调用多次的</p>
<p>fiberRoot 会记录应用的更新信息，比如协调器在完成工作后，会将工作成果存储在 fiberRoot 中。</p>
<img src="./images/7.png" width="90%" align="left"/>

<h2 id="5-初始化渲染"><a href="#5-初始化渲染" class="headerlink" title="5. 初始化渲染"></a>5. 初始化渲染</h2><p>要将 React 元素渲染到页面中，分为两个阶段，render 阶段和 commit 阶段。</p>
<p>render 阶段负责创建 Fiber 数据结构并为 Fiber 节点打标记，标记当前 Fiber 节点要进行的 DOM 操作。</p>
<p>commit 阶段负责根据 Fiber 节点标记 ( effectTag ) 进行相应的 DOM 操作。</p>
<h3 id="5-1-render-阶段"><a href="#5-1-render-阶段" class="headerlink" title="5.1 render 阶段"></a>5.1 render 阶段</h3><h4 id="5-1-1-render"><a href="#5-1-1-render" class="headerlink" title="5.1.1 render"></a>5.1.1 render</h4><p><code>文件位置：packages/react-dom/src/client/ReactDOMLegacy.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 渲染入口</span><br><span class="line"> * element 要进行渲染的 ReactElement, createElement 方法的返回值</span><br><span class="line"> * container 渲染容器 &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"> * callback 渲染完成后执行的回调函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function render(</span><br><span class="line">  element: React$Element&lt;any&gt;,</span><br><span class="line">  container: Container,</span><br><span class="line">  callback: ?Function,</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F; 检测 container 是否是符合要求的渲染容器</span><br><span class="line">  &#x2F;&#x2F; 即检测 container 是否是真实的DOM对象</span><br><span class="line">  &#x2F;&#x2F; 如果不符合要求就报错</span><br><span class="line">  invariant(</span><br><span class="line">    isValidContainer(container),</span><br><span class="line">    &#39;Target container is not a DOM element.&#39;,</span><br><span class="line">  );</span><br><span class="line">  return legacyRenderSubtreeIntoContainer(</span><br><span class="line">    &#x2F;&#x2F; 父组件 初始渲染没有父组件 传递 null 占位</span><br><span class="line">    null,</span><br><span class="line">    element,</span><br><span class="line">    container,</span><br><span class="line">    &#x2F;&#x2F; 是否为服务器端渲染 false 不是服务器端渲染 true 是服务器端渲染</span><br><span class="line">    false,</span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-2-isValidContainer"><a href="#5-1-2-isValidContainer" class="headerlink" title="5.1.2 isValidContainer"></a>5.1.2 isValidContainer</h4><p><code>文件位置：packages/react-dom/src/client/ReactDOMRoot.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 判断 node 是否是符合要求的 DOM 节点</span><br><span class="line"> * 1. node 可以是元素节点</span><br><span class="line"> * 2. node 可以是 document 节点</span><br><span class="line"> * 3. node 可以是 文档碎片节点</span><br><span class="line"> * 4. node 可以是注释节点但注释内容必须是 react-mount-point-unstable</span><br><span class="line"> * 		react 内部会找到注释节点的父级 通过调用父级元素的 insertBefore 方法, 将 element 插入到注释节点的前面</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function isValidContainer(node: mixed): boolean &#123;</span><br><span class="line">  return !!(</span><br><span class="line">    node &amp;&amp;</span><br><span class="line">    (node.nodeType &#x3D;&#x3D;&#x3D; ELEMENT_NODE ||</span><br><span class="line">      node.nodeType &#x3D;&#x3D;&#x3D; DOCUMENT_NODE ||</span><br><span class="line">      node.nodeType &#x3D;&#x3D;&#x3D; DOCUMENT_FRAGMENT_NODE ||</span><br><span class="line">      (node.nodeType &#x3D;&#x3D;&#x3D; COMMENT_NODE &amp;&amp;</span><br><span class="line">        (node: any).nodeValue &#x3D;&#x3D;&#x3D; &#39; react-mount-point-unstable &#39;))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-3-初始化-FiberRoot"><a href="#5-1-3-初始化-FiberRoot" class="headerlink" title="5.1.3 初始化 FiberRoot"></a>5.1.3 初始化 FiberRoot</h4><h5 id="5-1-3-1-legacyRenderSubtreeIntoContainer"><a href="#5-1-3-1-legacyRenderSubtreeIntoContainer" class="headerlink" title="5.1.3.1 legacyRenderSubtreeIntoContainer"></a>5.1.3.1 legacyRenderSubtreeIntoContainer</h5><p><code>文件位置: packages/react-dom/src/client/ReactDOMLegacy.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 将子树渲染到容器中 (初始化 Fiber 数据结构: 创建 fiberRoot 及 rootFiber)</span><br><span class="line"> * parentComponent: 父组件, 初始渲染传入了 null</span><br><span class="line"> * children: render 方法中的第一个参数, 要渲染的 ReactElement</span><br><span class="line"> * container: 渲染容器</span><br><span class="line"> * forceHydrate: true 为服务端渲染, false 为客户端渲染</span><br><span class="line"> * callback: 组件渲染完成后需要执行的回调函数</span><br><span class="line"> **&#x2F;</span><br><span class="line">function legacyRenderSubtreeIntoContainer(</span><br><span class="line">  parentComponent: ?React$Component&lt;any, any&gt;,</span><br><span class="line">  children: ReactNodeList,</span><br><span class="line">  container: Container,</span><br><span class="line">  forceHydrate: boolean,</span><br><span class="line">  callback: ?Function,</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 检测 container 是否已经是初始化过的渲染容器</span><br><span class="line">   * react 在初始渲染时会为最外层容器添加 _reactRootContainer 属性</span><br><span class="line">   * react 会根据此属性进行不同的渲染方式</span><br><span class="line">   * root 不存在 表示初始渲染</span><br><span class="line">   * root 存在 表示更新</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#x2F;&#x2F; 获取 container 容器对象下是否有 _reactRootContainer 属性</span><br><span class="line">  let root: RootType &#x3D; (container._reactRootContainer: any);</span><br><span class="line">  &#x2F;&#x2F; 即将存储根 Fiber 对象</span><br><span class="line">  let fiberRoot;</span><br><span class="line">  if (!root) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始渲染</span><br><span class="line">    &#x2F;&#x2F; 初始化根 Fiber 数据结构</span><br><span class="line">    &#x2F;&#x2F; 为 container 容器添加 _reactRootContainer 属性</span><br><span class="line">    &#x2F;&#x2F; 在 _reactRootContainer 对象中有一个属性叫做 _internalRoot</span><br><span class="line">    &#x2F;&#x2F; _internalRoot 属性值即为 FiberRoot 表示根节点 Fiber 数据结构</span><br><span class="line">    &#x2F;&#x2F; legacyCreateRootFromDOMContainer</span><br><span class="line">    &#x2F;&#x2F; createLegacyRoot</span><br><span class="line">    &#x2F;&#x2F; new ReactDOMBlockingRoot -&gt; this._internalRoot</span><br><span class="line">    &#x2F;&#x2F; createRootImpl</span><br><span class="line">    root &#x3D; container._reactRootContainer &#x3D; legacyCreateRootFromDOMContainer(</span><br><span class="line">      container,</span><br><span class="line">      forceHydrate,</span><br><span class="line">    );</span><br><span class="line">    &#x2F;&#x2F; 获取 Fiber Root 对象</span><br><span class="line">    fiberRoot &#x3D; root._internalRoot;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 改变 callback 函数中的 this 指向</span><br><span class="line">     * 使其指向 render 方法第一个参数的真实 DOM 对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 如果 callback 参数是函数类型</span><br><span class="line">    if (typeof callback &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      &#x2F;&#x2F; 使用 originalCallback 存储 callback 函数</span><br><span class="line">      const originalCallback &#x3D; callback;</span><br><span class="line">      &#x2F;&#x2F; 为 callback 参数重新赋值</span><br><span class="line">      callback &#x3D; function () &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取 render 方法第一个参数的真实 DOM 对象</span><br><span class="line">        &#x2F;&#x2F; 实际上就是 id&#x3D;&quot;root&quot; 的 div 的子元素</span><br><span class="line">        &#x2F;&#x2F; rootFiber.child.stateNode</span><br><span class="line">        &#x2F;&#x2F; rootFiber 就是 id&#x3D;&quot;root&quot; 的 div</span><br><span class="line">        const instance &#x3D; getPublicRootInstance(fiberRoot);</span><br><span class="line">        &#x2F;&#x2F; 调用 callback 函数并改变函数内部 this 指向</span><br><span class="line">        originalCallback.call(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 初始化渲染不执行批量更新</span><br><span class="line">    &#x2F;&#x2F; 因为批量更新是异步的是可以被打断的, 但是初始化渲染应该尽快完成不能被打断</span><br><span class="line">    &#x2F;&#x2F; 所以不执行批量更新</span><br><span class="line">    unbatchedUpdates(() &#x3D;&gt; &#123;</span><br><span class="line">      updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 非初始化渲染 即更新</span><br><span class="line">    fiberRoot &#x3D; root._internalRoot;</span><br><span class="line">    if (typeof callback &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      const originalCallback &#x3D; callback;</span><br><span class="line">      callback &#x3D; function () &#123;</span><br><span class="line">        const instance &#x3D; getPublicRootInstance(fiberRoot);</span><br><span class="line">        originalCallback.call(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Update</span><br><span class="line">    updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 返回 render 方法第一个参数的真实 DOM 对象作为 render 方法的返回值</span><br><span class="line">  &#x2F;&#x2F; 就是说渲染谁 返回谁的真实 DOM 对象</span><br><span class="line">  return getPublicRootInstance(fiberRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="./images/5.png" width="80%" align="left"/>

<h5 id="5-1-3-2-legacyCreateRootFromDOMContainer"><a href="#5-1-3-2-legacyCreateRootFromDOMContainer" class="headerlink" title="5.1.3.2 legacyCreateRootFromDOMContainer"></a>5.1.3.2 legacyCreateRootFromDOMContainer</h5><p><code>文件位置: packages/react-dom/src/client/ReactDOMLegacy.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 判断是否为服务器端渲染 如果不是服务器端渲染</span><br><span class="line"> * 清空 container 容器中的节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">function legacyCreateRootFromDOMContainer(</span><br><span class="line">  container: Container,</span><br><span class="line">  forceHydrate: boolean,</span><br><span class="line">): RootType &#123;</span><br><span class="line">  &#x2F;&#x2F; container &#x3D;&gt; &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &#x2F;&#x2F; 检测是否为服务器端渲染</span><br><span class="line">  const shouldHydrate &#x3D;</span><br><span class="line">    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);</span><br><span class="line">  &#x2F;&#x2F; 如果不是服务器端渲染</span><br><span class="line">  if (!shouldHydrate) &#123;</span><br><span class="line">    let rootSibling;</span><br><span class="line">    &#x2F;&#x2F; 开启循环 删除 container 容器中的节点</span><br><span class="line">    while ((rootSibling &#x3D; container.lastChild)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 删除 container 容器中的节点</span><br><span class="line">      container.removeChild(rootSibling);</span><br><span class="line">      &#x2F;**</span><br><span class="line">       * 为什么要清除 container 中的元素 ?</span><br><span class="line">       * 为提供首屏加载的用户体验, 有时需要在 container 中放置一些占位图或者 loading 图</span><br><span class="line">       * 就无可避免的要向 container 中加入 html 标记.</span><br><span class="line">       * 在将 ReactElement 渲染到 container 之前, 必然要先清空 container</span><br><span class="line">       * 因为占位图和 ReactElement 不能同时显示</span><br><span class="line">       *</span><br><span class="line">       * 在加入占位代码时, 最好只有一个父级元素, 可以减少内部代码的循环次数以提高性能</span><br><span class="line">       * &lt;div&gt;</span><br><span class="line">       *  &lt;p&gt;placement&lt;p&gt;</span><br><span class="line">       *  &lt;p&gt;placement&lt;p&gt;</span><br><span class="line">       *  &lt;p&gt;placement&lt;p&gt;</span><br><span class="line">       * &lt;&#x2F;div&gt;</span><br><span class="line">       *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return createLegacyRoot(</span><br><span class="line">    container,</span><br><span class="line">    shouldHydrate</span><br><span class="line">      ? &#123;</span><br><span class="line">          hydrate: true,</span><br><span class="line">        &#125;</span><br><span class="line">      : undefined,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-3-3-createLegacyRoot"><a href="#5-1-3-3-createLegacyRoot" class="headerlink" title="5.1.3.3 createLegacyRoot"></a>5.1.3.3 createLegacyRoot</h5><p><code>文件位置: packages/react-dom/src/client/ReactDOMRoot.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 通过实例化 ReactDOMBlockingRoot 类创建 LegacyRoot</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function createLegacyRoot(</span><br><span class="line">  container: Container,</span><br><span class="line">  options?: RootOptions,</span><br><span class="line">): RootType &#123;</span><br><span class="line">  &#x2F;&#x2F; container &#x3D;&gt; &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &#x2F;&#x2F; LegacyRoot 常量, 值为 0,</span><br><span class="line">  &#x2F;&#x2F; 通过 render 方法创建的 container 就是 LegacyRoot</span><br><span class="line">  return new ReactDOMBlockingRoot(container, LegacyRoot, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-3-3-ReactDOMBlockingRoot"><a href="#5-1-3-3-ReactDOMBlockingRoot" class="headerlink" title="5.1.3.3 ReactDOMBlockingRoot"></a>5.1.3.3 ReactDOMBlockingRoot</h5><p><code>文件位置: packages/react-dom/src/client/ReactDOMRoot.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 类, 通过它可以创建 LegacyRoot 的 Fiber 数据结构</span><br><span class="line"> *&#x2F;</span><br><span class="line">function ReactDOMBlockingRoot(</span><br><span class="line">  container: Container,</span><br><span class="line">  tag: RootTag,</span><br><span class="line">  options: void | RootOptions,</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F; tag &#x3D;&gt; 0 &#x3D;&gt; legacyRoot</span><br><span class="line">  &#x2F;&#x2F; container &#x3D;&gt; &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &#x2F;&#x2F; container._reactRootContainer &#x3D; &#123;_internalRoot: &#123;&#125;&#125;</span><br><span class="line">  this._internalRoot &#x3D; createRootImpl(container, tag, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-3-4-createRootImpl"><a href="#5-1-3-4-createRootImpl" class="headerlink" title="5.1.3.4 createRootImpl"></a>5.1.3.4 createRootImpl</h5><p><code>文件位置: packages/react-dom/src/client/ReactDOMRoot.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function createRootImpl(</span><br><span class="line">  container: Container,</span><br><span class="line">  tag: RootTag,</span><br><span class="line">  options: void | RootOptions,</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F; container &#x3D;&gt; &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &#x2F;&#x2F; tag &#x3D;&gt; 0</span><br><span class="line">  &#x2F;&#x2F; options &#x3D;&gt; undefined</span><br><span class="line">  const root &#x3D; createContainer(container, tag, hydrate, hydrationCallbacks);</span><br><span class="line">  markContainerAsRoot(root.current, container);</span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-3-5-createContainer"><a href="#5-1-3-5-createContainer" class="headerlink" title="5.1.3.5 createContainer"></a>5.1.3.5 createContainer</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberReconciler.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建 container</span><br><span class="line">export function createContainer(</span><br><span class="line">  containerInfo: Container,</span><br><span class="line">  tag: RootTag,</span><br><span class="line">  hydrate: boolean,</span><br><span class="line">  hydrationCallbacks: null | SuspenseHydrationCallbacks,</span><br><span class="line">): OpaqueRoot &#123;</span><br><span class="line">  &#x2F;&#x2F; containerInfo &#x3D;&gt; &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &#x2F;&#x2F; tag: 0</span><br><span class="line">  &#x2F;&#x2F; hydrate: false</span><br><span class="line">  &#x2F;&#x2F; hydrationCallbacks: null</span><br><span class="line">  &#x2F;&#x2F; 忽略了和服务器端渲染相关的内容</span><br><span class="line">  return createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-3-6-createFiberRoot"><a href="#5-1-3-6-createFiberRoot" class="headerlink" title="5.1.3.6 createFiberRoot"></a>5.1.3.6 createFiberRoot</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberRoot.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建根节点对应的 fiber 对象</span><br><span class="line">export function createFiberRoot(</span><br><span class="line">  containerInfo: any,</span><br><span class="line">  tag: RootTag,</span><br><span class="line">  hydrate: boolean,</span><br><span class="line">  hydrationCallbacks: null | SuspenseHydrationCallbacks,</span><br><span class="line">): FiberRoot &#123;</span><br><span class="line">  &#x2F;&#x2F; 创建 FiberRoot</span><br><span class="line">  const root: FiberRoot &#x3D; (new FiberRootNode(containerInfo, tag, hydrate): any);</span><br><span class="line">  &#x2F;&#x2F; 创建根节点对应的 rootFiber</span><br><span class="line">  const uninitializedFiber &#x3D; createHostRootFiber(tag);</span><br><span class="line">  &#x2F;&#x2F; 为 fiberRoot 添加 current 属性 值为 rootFiber</span><br><span class="line">  root.current &#x3D; uninitializedFiber;</span><br><span class="line">  &#x2F;&#x2F; 为 rootFiber 添加 stateNode 属性 值为 fiberRoot</span><br><span class="line">  uninitializedFiber.stateNode &#x3D; root;</span><br><span class="line">  &#x2F;&#x2F; 为 fiber 对象添加 updateQueue 属性, 初始化 updateQueue 对象</span><br><span class="line">  &#x2F;&#x2F; updateQueue 用于存放 Update 对象</span><br><span class="line">  &#x2F;&#x2F; Update 对象用于记录组件状态的改变</span><br><span class="line">  initializeUpdateQueue(uninitializedFiber);</span><br><span class="line">  &#x2F;&#x2F; 返回 root</span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-3-7-FiberRootNode"><a href="#5-1-3-7-FiberRootNode" class="headerlink" title="5.1.3.7 FiberRootNode"></a>5.1.3.7 FiberRootNode</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberRoot.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function FiberRootNode(containerInfo, tag, hydrate) &#123;</span><br><span class="line">  this.tag &#x3D; tag;</span><br><span class="line">  this.current &#x3D; null;</span><br><span class="line">  this.containerInfo &#x3D; containerInfo;</span><br><span class="line">  this.pendingChildren &#x3D; null;</span><br><span class="line">  this.pingCache &#x3D; null;</span><br><span class="line">  this.finishedExpirationTime &#x3D; NoWork;</span><br><span class="line">  this.finishedWork &#x3D; null;</span><br><span class="line">  this.timeoutHandle &#x3D; noTimeout;</span><br><span class="line">  this.context &#x3D; null;</span><br><span class="line">  this.pendingContext &#x3D; null;</span><br><span class="line">  this.hydrate &#x3D; hydrate;</span><br><span class="line">  this.callbackNode &#x3D; null;</span><br><span class="line">  this.callbackPriority &#x3D; NoPriority;</span><br><span class="line">  this.firstPendingTime &#x3D; NoWork;</span><br><span class="line">  this.firstSuspendedTime &#x3D; NoWork;</span><br><span class="line">  this.lastSuspendedTime &#x3D; NoWork;</span><br><span class="line">  this.nextKnownPendingLevel &#x3D; NoWork;</span><br><span class="line">  this.lastPingedTime &#x3D; NoWork;</span><br><span class="line">  this.lastExpiredTime &#x3D; NoWork;</span><br><span class="line">  if (enableSchedulerTracing) &#123;</span><br><span class="line">    this.interactionThreadID &#x3D; unstable_getThreadID();</span><br><span class="line">    this.memoizedInteractions &#x3D; new Set();</span><br><span class="line">    this.pendingInteractionMap &#x3D; new Map();</span><br><span class="line">  &#125;</span><br><span class="line">  if (enableSuspenseCallback) &#123;</span><br><span class="line">    this.hydrationCallbacks &#x3D; null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-1-8-initializeUpdateQueue"><a href="#5-3-1-8-initializeUpdateQueue" class="headerlink" title="5.3.1.8 initializeUpdateQueue"></a>5.3.1.8 initializeUpdateQueue</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberRoot.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function initializeUpdateQueue&lt;State&gt;(fiber: Fiber): void &#123;</span><br><span class="line">  const queue: UpdateQueue&lt;State&gt; &#x3D; &#123;</span><br><span class="line">    baseState: fiber.memoizedState,</span><br><span class="line">    baseQueue: null,</span><br><span class="line">    shared: &#123;</span><br><span class="line">      pending: null,</span><br><span class="line">    &#125;,</span><br><span class="line">    effects: null,</span><br><span class="line">  &#125;;</span><br><span class="line">  fiber.updateQueue &#x3D; queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-1-4-获取-rootFiber-child-实例对象"><a href="#5-1-4-获取-rootFiber-child-实例对象" class="headerlink" title="5.1.4 获取 rootFiber.child 实例对象"></a>5.1.4 获取 rootFiber.child 实例对象</h4><h5 id="5-1-4-1-getPublicRootInstance"><a href="#5-1-4-1-getPublicRootInstance" class="headerlink" title="5.1.4.1  getPublicRootInstance"></a>5.1.4.1  getPublicRootInstance</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberReconciler.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 获取 container 的第一个子元素的实例对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function getPublicRootInstance(</span><br><span class="line">  &#x2F;&#x2F; FiberRoot</span><br><span class="line">  container: OpaqueRoot,</span><br><span class="line">): React$Component&lt;any, any&gt; | PublicInstance | null &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取 rootFiber</span><br><span class="line">  const containerFiber &#x3D; container.current;</span><br><span class="line">  &#x2F;&#x2F; 如果 rootFiber 没有子元素</span><br><span class="line">  &#x2F;&#x2F; 指的就是 id&#x3D;&quot;root&quot; 的 div 没有子元素</span><br><span class="line">  if (!containerFiber.child) &#123;</span><br><span class="line">    &#x2F;&#x2F; 返回 null</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 匹配子元素的类型</span><br><span class="line">  switch (containerFiber.child.tag) &#123;</span><br><span class="line">    &#x2F;&#x2F; 普通</span><br><span class="line">    case HostComponent:</span><br><span class="line">      return getPublicInstance(containerFiber.child.stateNode);</span><br><span class="line">    default:</span><br><span class="line">      &#x2F;&#x2F; 返回子元素的真实 DOM 对象</span><br><span class="line">      return containerFiber.child.stateNode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-4-2-getPublicInstance"><a href="#5-1-4-2-getPublicInstance" class="headerlink" title="5.1.4.2 getPublicInstance"></a>5.1.4.2 getPublicInstance</h5><p><code>文件位置: packages/react-dom/src/client/ReactDOMHostConfig.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function getPublicInstance(instance: Instance): * &#123;</span><br><span class="line">  return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-5-updateContainer"><a href="#5-1-5-updateContainer" class="headerlink" title="5.1.5 updateContainer"></a>5.1.5 updateContainer</h4><p><code>文件位置: packages/react-reconciler/src/ReactFiberReconciler.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 计算任务的过期时间</span><br><span class="line"> * 再根据任务过期时间创建 Update 任务</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function updateContainer(</span><br><span class="line">	&#x2F;&#x2F; element 要渲染的 ReactElement</span><br><span class="line">  element: ReactNodeList,</span><br><span class="line">  &#x2F;&#x2F; container Fiber Root 对象</span><br><span class="line">  container: OpaqueRoot,</span><br><span class="line">  &#x2F;&#x2F; parentComponent 父组件 初始渲染为 null</span><br><span class="line">  parentComponent: ?React$Component&lt;any, any&gt;,</span><br><span class="line">  &#x2F;&#x2F; ReactElement 渲染完成执行的回调函数</span><br><span class="line">  callback: ?Function,</span><br><span class="line">): ExpirationTime &#123;  </span><br><span class="line">  &#x2F;&#x2F; container 获取 rootFiber</span><br><span class="line">  const current &#x3D; container.current;</span><br><span class="line">  &#x2F;&#x2F; 获取当前距离 react 应用初始化的时间 1073741805</span><br><span class="line">  const currentTime &#x3D; requestCurrentTimeForUpdate();</span><br><span class="line">  &#x2F;&#x2F; 异步加载设置</span><br><span class="line">  const suspenseConfig &#x3D; requestCurrentSuspenseConfig();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 计算过期时间</span><br><span class="line">  &#x2F;&#x2F; 为防止任务因为优先级的原因一直被打断而未能执行</span><br><span class="line">  &#x2F;&#x2F; react 会设置一个过期时间, 当时间到了过期时间的时候</span><br><span class="line">  &#x2F;&#x2F; 如果任务还未执行的话, react 将会强制执行该任务</span><br><span class="line">  &#x2F;&#x2F; 初始化渲染时, 任务同步执行不涉及被打断的问题 1073741823</span><br><span class="line">  const expirationTime &#x3D; computeExpirationForFiber(</span><br><span class="line">    currentTime,</span><br><span class="line">    current,</span><br><span class="line">    suspenseConfig,</span><br><span class="line">  );</span><br><span class="line">  &#x2F;&#x2F; 设置FiberRoot.context, 首次执行返回一个emptyContext, 是一个 &#123;&#125;</span><br><span class="line">  const context &#x3D; getContextForSubtree(parentComponent);</span><br><span class="line">  &#x2F;&#x2F; 初始渲染时 Fiber Root 对象中的 context 属性值为 null</span><br><span class="line">  &#x2F;&#x2F; 所以会进入到 if 中</span><br><span class="line">  if (container.context &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始渲染时将 context 属性值设置为 &#123;&#125;</span><br><span class="line">    container.context &#x3D; context;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    container.pendingContext &#x3D; context;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 创建一个待执行任务</span><br><span class="line">  const update &#x3D; createUpdate(expirationTime, suspenseConfig);</span><br><span class="line">  &#x2F;&#x2F; 将要更新的内容挂载到更新对象中的 payload 中</span><br><span class="line">  &#x2F;&#x2F; 将要更新的组件存储在 payload 对象中, 方便后期获取</span><br><span class="line">  update.payload &#x3D; &#123;element&#125;;</span><br><span class="line">  &#x2F;&#x2F; 判断 callback 是否存在</span><br><span class="line">  callback &#x3D; callback &#x3D;&#x3D;&#x3D; undefined ? null : callback;</span><br><span class="line">  &#x2F;&#x2F; 如果 callback 存在</span><br><span class="line">  if (callback !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 callback 挂载到 update 对象中</span><br><span class="line">    &#x2F;&#x2F; 其实就是一层层传递 方便 ReactElement 元素渲染完成调用</span><br><span class="line">    &#x2F;&#x2F; 回调函数执行完成后会被清除 可以在代码的后面加上 return 进行验证</span><br><span class="line">    update.callback &#x3D; callback;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 将 update 对象加入到当前 Fiber 的更新队列当中 (updateQueue)</span><br><span class="line">  enqueueUpdate(current, update);</span><br><span class="line">  &#x2F;&#x2F; 调度和更新 current 对象</span><br><span class="line">  scheduleWork(current, expirationTime);</span><br><span class="line">  &#x2F;&#x2F; 返回过期时间</span><br><span class="line">  return expirationTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-6-enqueueUpdate"><a href="#5-1-6-enqueueUpdate" class="headerlink" title="5.1.6 enqueueUpdate"></a>5.1.6 enqueueUpdate</h4><p><code>文件位置: packages/react-reconciler/src/ReactUpdateQueue.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将任务(Update)存放于任务队列(updateQueue)中</span><br><span class="line">&#x2F;&#x2F; 创建单向链表结构存放 update, next 用来串联 update</span><br><span class="line">export function enqueueUpdate&lt;State&gt;(fiber: Fiber, update: Update&lt;State&gt;) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取当前 Fiber 的 更新队列</span><br><span class="line">  const updateQueue &#x3D; fiber.updateQueue;</span><br><span class="line">  &#x2F;&#x2F; 如果更新队列不存在 就返回 null</span><br><span class="line">  if (updateQueue &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 仅发生在 fiber 已经被卸载</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 获取待执行的 Update 任务</span><br><span class="line">  &#x2F;&#x2F; 初始渲染时没有待执行的任务</span><br><span class="line">  const sharedQueue &#x3D; updateQueue.shared;</span><br><span class="line">  const pending &#x3D; sharedQueue.pending;</span><br><span class="line">  &#x2F;&#x2F; 如果没有待执行的 Update 任务</span><br><span class="line">  if (pending &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 这是第一次更新, 创建一个循环列表.</span><br><span class="line">    update.next &#x3D; update;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    update.next &#x3D; pending.next;</span><br><span class="line">    pending.next &#x3D; update;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 将 Update 任务存储在 pending 属性中</span><br><span class="line">  sharedQueue.pending &#x3D; update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-7-scheduleUpdateOnFiber"><a href="#5-1-7-scheduleUpdateOnFiber" class="headerlink" title="5.1.7 scheduleUpdateOnFiber"></a>5.1.7 scheduleUpdateOnFiber</h4><p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 判断任务是否为同步 调用同步任务入口</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function scheduleUpdateOnFiber(</span><br><span class="line">  &#x2F;&#x2F; rootFiber</span><br><span class="line">  fiber: Fiber,</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * fiber: 初始化渲染时为 rootFiber, 即 &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt; 对应的 Fiber 对象</span><br><span class="line">   * expirationTime: 任务过期时间 &#x3D;&gt;1073741823</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 判断是否是无限循环的 update 如果是就报错</span><br><span class="line">   * 在 componentWillUpdate 或者 componentDidUpdate 生命周期函数中重复调用</span><br><span class="line">   * setState 方法时, 可能会发生这种情况, React 限制了嵌套更新的数量以防止无限循环</span><br><span class="line">   * 限制的嵌套更新数量为 50, 可通过 NESTED_UPDATE_LIMIT 全局变量获取</span><br><span class="line">   *&#x2F;</span><br><span class="line">  checkForNestedUpdates();</span><br><span class="line">  &#x2F;&#x2F; 判断任务是否是同步任务 Sync的值为: 1073741823</span><br><span class="line">  if (expirationTime &#x3D;&#x3D;&#x3D; Sync) &#123;</span><br><span class="line">    if (</span><br><span class="line">      &#x2F;&#x2F; 检查是否处于非批量更新模式</span><br><span class="line">      (executionContext &amp; LegacyUnbatchedContext) !&#x3D;&#x3D; NoContext &amp;&amp;</span><br><span class="line">      &#x2F;&#x2F; 检查是否没有处于正在进行渲染的任务</span><br><span class="line">      (executionContext &amp; (RenderContext | CommitContext)) &#x3D;&#x3D;&#x3D; NoContext</span><br><span class="line">    ) &#123;</span><br><span class="line">      &#x2F;&#x2F; 同步任务入口点</span><br><span class="line">      performSyncWorkOnRoot(root);</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;&#x2F; 忽略了一些初始化渲染不会得到执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-8-构建-Fiber-对象"><a href="#5-1-8-构建-Fiber-对象" class="headerlink" title="5.1.8 构建 Fiber 对象"></a>5.1.8 构建 Fiber 对象</h4><h5 id="5-1-8-1-performSyncWorkOnRoot"><a href="#5-1-8-1-performSyncWorkOnRoot" class="headerlink" title="5.1.8.1 performSyncWorkOnRoot"></a>5.1.8.1 performSyncWorkOnRoot</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 进入 render 阶段, 构建 workInProgress Fiber 树</span><br><span class="line">function performSyncWorkOnRoot(root) &#123;</span><br><span class="line">  &#x2F;&#x2F; 参数 root 为 fiberRoot 对象</span><br><span class="line">  &#x2F;&#x2F; 检查是否有过期的任务</span><br><span class="line">  &#x2F;&#x2F; 如果没有过期的任务 值为 0</span><br><span class="line">  &#x2F;&#x2F; 初始化渲染没有过期的任务待执行</span><br><span class="line">  const lastExpiredTime &#x3D; root.lastExpiredTime;</span><br><span class="line">  &#x2F;&#x2F; NoWork 值为 0</span><br><span class="line">  &#x2F;&#x2F; 如果有过期的任务 将过期时间设置为 lastExpiredTime 否则将过期时间设置为 Sync</span><br><span class="line">  &#x2F;&#x2F; 初始渲染过期时间被设置成了 Sync</span><br><span class="line">  const expirationTime &#x3D; lastExpiredTime !&#x3D;&#x3D; NoWork ? lastExpiredTime : Sync;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果 root 和 workInProgressRoot 不相等</span><br><span class="line">  &#x2F;&#x2F; 说明 workInProgressRoot 不存在, 说明还没有构建 workInProgress Fiber 树</span><br><span class="line">  &#x2F;&#x2F; workInProgressRoot 为全局变量 默认值为 null, 初始渲染时值为 null</span><br><span class="line">  &#x2F;&#x2F; expirationTime &#x3D;&gt; 1073741823</span><br><span class="line">  &#x2F;&#x2F; renderExpirationTime &#x3D;&gt; 0</span><br><span class="line">  &#x2F;&#x2F; true</span><br><span class="line">  if (root !&#x3D;&#x3D; workInProgressRoot || expirationTime !&#x3D;&#x3D; renderExpirationTime) &#123;</span><br><span class="line">    &#x2F;&#x2F; 构建 workInProgressFiber 树及rootFiber</span><br><span class="line">    prepareFreshStack(root, expirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; workInProgress 如果不为 null</span><br><span class="line">  if (workInProgress !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 以同步的方式开始构建 Fiber 对象</span><br><span class="line">        workLoopSync();</span><br><span class="line">        &#x2F;&#x2F; 跳出 while 循环</span><br><span class="line">        break;</span><br><span class="line">      &#125; catch (thrownValue) &#123;</span><br><span class="line">        handleError(root, thrownValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; while (true);</span><br><span class="line">    </span><br><span class="line">    if (workInProgress !&#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 这是一个同步渲染, 所以我们应该完成整棵树.</span><br><span class="line">      &#x2F;&#x2F; 无法提交不完整的 root, 此错误可能是由于React中的错误所致. 请提出问题.</span><br><span class="line">      invariant(</span><br><span class="line">        false,</span><br><span class="line">        &#39;Cannot commit an incomplete root. This error is likely caused by a &#39; +</span><br><span class="line">          &#39;bug in React. Please file an issue.&#39;,</span><br><span class="line">      );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 将构建好的新 Fiber 对象存储在 finishedWork 属性中</span><br><span class="line">      &#x2F;&#x2F; 提交阶段使用</span><br><span class="line">      root.finishedWork &#x3D; (root.current.alternate: any);</span><br><span class="line">      root.finishedExpirationTime &#x3D; expirationTime;</span><br><span class="line">      &#x2F;&#x2F; 结束 render 阶段</span><br><span class="line">      &#x2F;&#x2F; 进入 commit 阶段</span><br><span class="line">      finishSyncRender(root);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-8-2-prepareFreshStack"><a href="#5-1-8-2-prepareFreshStack" class="headerlink" title="5.1.8.2 prepareFreshStack"></a>5.1.8.2 prepareFreshStack</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 根据 currentFiber 树中的 rootFiber</span><br><span class="line"> * 构建 workInProgressFiber 树中的 rootFiber</span><br><span class="line"> *&#x2F;</span><br><span class="line">function prepareFreshStack(root, expirationTime) &#123;</span><br><span class="line">  &#x2F;&#x2F; 为 FiberRoot 对象添加 finishedWork 属性</span><br><span class="line">  &#x2F;&#x2F; finishedWork 表示 render 阶段执行完成后构建的待提交的 Fiber 对象</span><br><span class="line">  root.finishedWork &#x3D; null;</span><br><span class="line">  &#x2F;&#x2F; 初始化 finishedExpirationTime 值为 0</span><br><span class="line">  root.finishedExpirationTime &#x3D; NoWork;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 建构 workInProgress Fiber 树的 Fiber 对象</span><br><span class="line">  workInProgressRoot &#x3D; root;</span><br><span class="line">  &#x2F;&#x2F; 构建 workInProgress Fiber 树中的 rootFiber</span><br><span class="line">  workInProgress &#x3D; createWorkInProgress(root.current, null);</span><br><span class="line">  renderExpirationTime &#x3D; expirationTime;</span><br><span class="line">  workInProgressRootExitStatus &#x3D; RootIncomplete;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-8-3-createWorkInProgress"><a href="#5-1-8-3-createWorkInProgress" class="headerlink" title="5.1.8.3 createWorkInProgress"></a>5.1.8.3 createWorkInProgress</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiber.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 构建 workInProgress Fiber 树中的 rootFiber</span><br><span class="line">&#x2F;&#x2F; 构建完成后会替换 current fiber</span><br><span class="line">&#x2F;&#x2F; 初始渲染 pendingProps 为 null</span><br><span class="line">export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber &#123;</span><br><span class="line">  &#x2F;&#x2F; current: current Fiber 中的 rootFiber</span><br><span class="line">  &#x2F;&#x2F; 获取 current Fiber 中对应的 workInProgress Fiber</span><br><span class="line">  let workInProgress &#x3D; current.alternate;</span><br><span class="line">  &#x2F;&#x2F; 如果 workInProgress 不存在</span><br><span class="line">  if (workInProgress &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建 fiber 对象</span><br><span class="line">    workInProgress &#x3D; createFiber(</span><br><span class="line">      current.tag,</span><br><span class="line">      pendingProps,</span><br><span class="line">      current.key,</span><br><span class="line">      current.mode,</span><br><span class="line">    );</span><br><span class="line">    &#x2F;&#x2F; 属性复用</span><br><span class="line">    workInProgress.elementType &#x3D; current.elementType;</span><br><span class="line">    workInProgress.type &#x3D; current.type;</span><br><span class="line">    workInProgress.stateNode &#x3D; current.stateNode;</span><br><span class="line">    &#x2F;&#x2F; 使用 alternate 存储 current</span><br><span class="line">    workInProgress.alternate &#x3D; current;</span><br><span class="line">    &#x2F;&#x2F; 使用 alternate 存储 workInProgress</span><br><span class="line">    current.alternate &#x3D; workInProgress;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  workInProgress.childExpirationTime &#x3D; current.childExpirationTime;</span><br><span class="line">  workInProgress.expirationTime &#x3D; current.expirationTime;</span><br><span class="line">  workInProgress.child &#x3D; current.child;</span><br><span class="line">  workInProgress.memoizedProps &#x3D; current.memoizedProps;</span><br><span class="line">  workInProgress.memoizedState &#x3D; current.memoizedState;</span><br><span class="line">  workInProgress.updateQueue &#x3D; current.updateQueue;</span><br><span class="line">  workInProgress.sibling &#x3D; current.sibling;</span><br><span class="line">  workInProgress.index &#x3D; current.index;</span><br><span class="line">  workInProgress.ref &#x3D; current.ref;</span><br><span class="line">	</span><br><span class="line">  &#x2F;&#x2F; 返回创建好的 workInProgress Fiber 对象</span><br><span class="line">  return workInProgress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-8-4-workLoopSync"><a href="#5-1-8-4-workLoopSync" class="headerlink" title="5.1.8.4 workLoopSync"></a>5.1.8.4 workLoopSync</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 以同步的方式构建 workInProgress Fiber 对象</span><br><span class="line">function workLoopSync() &#123;</span><br><span class="line">  &#x2F;&#x2F; workInProgress 是一个 fiber 对象</span><br><span class="line">  &#x2F;&#x2F; 它的值不为 null 意味着该 fiber 对象上仍然有更新要执行</span><br><span class="line">  while (workInProgress !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    workInProgress &#x3D; performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-8-5-performUnitOfWork"><a href="#5-1-8-5-performUnitOfWork" class="headerlink" title="5.1.8.5 performUnitOfWork"></a>5.1.8.5 performUnitOfWork</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function performUnitOfWork(unitOfWork: Fiber): Fiber | null &#123;</span><br><span class="line">  &#x2F;&#x2F; unitOfWork &#x3D;&gt; workInProgress Fiber 树中的 rootFiber</span><br><span class="line">  &#x2F;&#x2F; current &#x3D;&gt; currentFiber 树中的 rootFiber</span><br><span class="line">  const current &#x3D; unitOfWork.alternate;</span><br><span class="line">  &#x2F;&#x2F; 存储下一个要构建的子级 Fiber 对象</span><br><span class="line">  let next;</span><br><span class="line">  &#x2F;&#x2F; false</span><br><span class="line">  if (enableProfilerTimer &amp;&amp; (unitOfWork.mode &amp; ProfileMode) !&#x3D;&#x3D; NoMode) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始渲染 不执行</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; beginWork: 从父到子, 构建 Fiber 节点对象</span><br><span class="line">    &#x2F;&#x2F; 返回值 next 为当前节点的子节点</span><br><span class="line">    next &#x3D; beginWork(current, unitOfWork, renderExpirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 为旧的 props 属性赋值</span><br><span class="line">  &#x2F;&#x2F; 此次更新后 pendingProps 变为 memoizedProps</span><br><span class="line">  unitOfWork.memoizedProps &#x3D; unitOfWork.pendingProps;</span><br><span class="line">  &#x2F;&#x2F; 如果子节点不存在说明当前节点向下遍历子节点已经到底了</span><br><span class="line">  &#x2F;&#x2F; 继续向上返回 遇到兄弟节点 构建兄弟节点的子 Fiber 对象 直到返回到根 Fiber 对象</span><br><span class="line">  if (next &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 从子到父, 构建其余节点 Fiber 对象</span><br><span class="line">    next &#x3D; completeUnitOfWork(unitOfWork);</span><br><span class="line">  &#125;</span><br><span class="line">  return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-8-6-beginWork"><a href="#5-1-8-6-beginWork" class="headerlink" title="5.1.8.6 beginWork"></a>5.1.8.6 beginWork</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberBeginWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 从父到子, 构建 Fiber 节点对象</span><br><span class="line">function beginWork(</span><br><span class="line">  current: Fiber | null,</span><br><span class="line">  workInProgress: Fiber,</span><br><span class="line">  renderExpirationTime: ExpirationTime,</span><br><span class="line">): Fiber | null &#123;</span><br><span class="line">  &#x2F;&#x2F; NoWork 常量 值为0 清空过期时间</span><br><span class="line">  workInProgress.expirationTime &#x3D; NoWork;</span><br><span class="line">  &#x2F;&#x2F; 根据当前 Fiber 的类型决定如何构建起子级 Fiber 对象</span><br><span class="line">  &#x2F;&#x2F; 文件位置: shared&#x2F;ReactWorkTags.js</span><br><span class="line">  switch (workInProgress.tag) &#123;</span><br><span class="line">    &#x2F;&#x2F; 2</span><br><span class="line">    &#x2F;&#x2F; 函数型组件在第一次渲染组件时使用</span><br><span class="line">    case IndeterminateComponent: &#123;</span><br><span class="line">      return mountIndeterminateComponent(</span><br><span class="line">        &#x2F;&#x2F; 旧 Fiber</span><br><span class="line">        current,</span><br><span class="line">        &#x2F;&#x2F; 新 Fiber</span><br><span class="line">        workInProgress,</span><br><span class="line">        &#x2F;&#x2F; 新 Fiber 的 type 值 初始渲染时是App组件函数</span><br><span class="line">        workInProgress.type,</span><br><span class="line">        &#x2F;&#x2F; 同步 整数最大值 1073741823</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 0</span><br><span class="line">    case FunctionComponent: &#123;</span><br><span class="line">      const Component &#x3D; workInProgress.type;</span><br><span class="line">      const unresolvedProps &#x3D; workInProgress.pendingProps;</span><br><span class="line">      const resolvedProps &#x3D;</span><br><span class="line">        workInProgress.elementType &#x3D;&#x3D;&#x3D; Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      return updateFunctionComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 1</span><br><span class="line">    case ClassComponent: &#123;</span><br><span class="line">      const Component &#x3D; workInProgress.type;</span><br><span class="line">      const unresolvedProps &#x3D; workInProgress.pendingProps;</span><br><span class="line">      const resolvedProps &#x3D;</span><br><span class="line">        workInProgress.elementType &#x3D;&#x3D;&#x3D; Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      return updateClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 3</span><br><span class="line">    case HostRoot:</span><br><span class="line">      return updateHostRoot(current, workInProgress, renderExpirationTime);</span><br><span class="line">    &#x2F;&#x2F; 5</span><br><span class="line">    case HostComponent:</span><br><span class="line">      return updateHostComponent(current, workInProgress, renderExpirationTime);</span><br><span class="line">    &#x2F;&#x2F; 6</span><br><span class="line">    case HostText:</span><br><span class="line">      return updateHostText(current, workInProgress);</span><br><span class="line">  &#x2F;&#x2F; 组件类型未知 报错</span><br><span class="line">  invariant(</span><br><span class="line">    false,</span><br><span class="line">    &#39;Unknown unit of work tag (%s). This error is likely caused by a bug in &#39; +</span><br><span class="line">      &#39;React. Please file an issue.&#39;,</span><br><span class="line">    workInProgress.tag,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-8-7-updateHostRoot"><a href="#5-1-8-7-updateHostRoot" class="headerlink" title="5.1.8.7 updateHostRoot"></a>5.1.8.7 updateHostRoot</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberBeginWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; HostRoot &#x3D;&gt; &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt; 对应的 Fiber 对象</span><br><span class="line">&#x2F;&#x2F; 找出 HostRoot 的子 ReactElement 并为其构建 Fiber 对象</span><br><span class="line">function updateHostRoot(current, workInProgress, renderExpirationTime) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取更新队列</span><br><span class="line">  const updateQueue &#x3D; workInProgress.updateQueue;</span><br><span class="line">  &#x2F;&#x2F; 获取新的 props 对象 null</span><br><span class="line">  const nextProps &#x3D; workInProgress.pendingProps;</span><br><span class="line">  &#x2F;&#x2F; 获取上一次渲染使用的 state null</span><br><span class="line">  const prevState &#x3D; workInProgress.memoizedState;</span><br><span class="line">  &#x2F;&#x2F; 获取上一次渲染使用的 children null</span><br><span class="line">  const prevChildren &#x3D; prevState !&#x3D;&#x3D; null ? prevState.element : null;</span><br><span class="line">  &#x2F;&#x2F; 浅复制更新队列, 防止引用属性互相影响</span><br><span class="line">  &#x2F;&#x2F; workInProgress.updateQueue 浅拷贝 current.updateQueue</span><br><span class="line">  cloneUpdateQueue(current, workInProgress);</span><br><span class="line">  &#x2F;&#x2F; 获取 updateQueue.payload 并赋值到 workInProgress.memoizedState</span><br><span class="line">  &#x2F;&#x2F; 要更新的内容就是 element 就是 rootFiber 的子元素</span><br><span class="line">  processUpdateQueue(workInProgress, nextProps, null, renderExpirationTime);</span><br><span class="line">  &#x2F;&#x2F; 获取 element 所在对象</span><br><span class="line">  const nextState &#x3D; workInProgress.memoizedState;</span><br><span class="line">  &#x2F;&#x2F; 从对象中获取 element</span><br><span class="line">  const nextChildren &#x3D; nextState.element;</span><br><span class="line">  &#x2F;&#x2F; 获取 fiberRoot 对象</span><br><span class="line">  const root: FiberRoot &#x3D; workInProgress.stateNode;</span><br><span class="line">  &#x2F;&#x2F; 服务器端渲染走 if</span><br><span class="line">  if (root.hydrate &amp;&amp; enterHydrationState(workInProgress)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 忽略</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 客户端渲染走 else</span><br><span class="line">    &#x2F;&#x2F; 构建子节点 fiber 对象</span><br><span class="line">    reconcileChildren(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 返回子节点 fiber 对象</span><br><span class="line">  return workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-8-8-reconcileChildren"><a href="#5-1-8-8-reconcileChildren" class="headerlink" title="5.1.8.8 reconcileChildren"></a>5.1.8.8 reconcileChildren</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberBeginWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function reconcileChildren(</span><br><span class="line">  &#x2F;&#x2F; 旧 Fiber</span><br><span class="line">  current: Fiber | null,</span><br><span class="line">  &#x2F;&#x2F; 父级 Fiber</span><br><span class="line">  workInProgress: Fiber,</span><br><span class="line">  &#x2F;&#x2F; 子级 vdom 对象</span><br><span class="line">  nextChildren: any,</span><br><span class="line">  &#x2F;&#x2F; 初始渲染 整型最大值 代表同步任务</span><br><span class="line">  renderExpirationTime: ExpirationTime,</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 为什么要传递 current ?</span><br><span class="line">   * 如果不是初始渲染的情况, 要进行新旧 Fiber 对比</span><br><span class="line">   * 初始渲染时则用不到 current</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#x2F;&#x2F; 如果就 Fiber 为 null 表示初始渲染</span><br><span class="line">  if (current &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 为当前构建的 Fiber 对象添加子级 Fiber 对象</span><br><span class="line">    workInProgress.child &#x3D; mountChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      null,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 忽略了 else 的情况</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-8-9-ChildReconciler"><a href="#5-1-8-9-ChildReconciler" class="headerlink" title="5.1.8.9 ChildReconciler"></a>5.1.8.9 ChildReconciler</h5><p><code>文件位置: packages/react-reconciler/src/ReactChildFiber.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * shouldTrackSideEffects 标识, 是否为 Fiber 对象添加 effectTag</span><br><span class="line"> * true 添加 false 不添加</span><br><span class="line"> * 对于初始渲染来说, 只有根组件需要添加, 其他元素不需要添加, 防止过多的 DOM 操作</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 用于初始渲染</span><br><span class="line">export const mountChildFibers &#x3D; ChildReconciler(false);</span><br><span class="line"></span><br><span class="line">function ChildReconciler(shouldTrackSideEffects) &#123;</span><br><span class="line"> </span><br><span class="line">  function placeChild(</span><br><span class="line">    newFiber: Fiber,</span><br><span class="line">    lastPlacedIndex: number,</span><br><span class="line">    newIndex: number,</span><br><span class="line">  ): number &#123;</span><br><span class="line">    newFiber.index &#x3D; newIndex;</span><br><span class="line">    if (!shouldTrackSideEffects) &#123;</span><br><span class="line">      return lastPlacedIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 忽略了一部分初始化渲染不执行的代码</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function placeSingleChild(newFiber: Fiber): Fiber &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果是初始渲染 会在根组件(App)上设置 effectTag 属性为 Placement 值为 1</span><br><span class="line">    &#x2F;&#x2F; 其他子级节点具有默认值为 0 防止在 commit 阶段反复操作真实DOM</span><br><span class="line">    &#x2F;&#x2F; 初始渲染时如果当前处理的是根组件 true 其他组件 false</span><br><span class="line">    if (shouldTrackSideEffects &amp;&amp; newFiber.alternate &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; Placement 表示新创建的节点</span><br><span class="line">      newFiber.effectTag &#x3D; Placement;</span><br><span class="line">    &#125;</span><br><span class="line">    return newFiber;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 处理子元素是数组的情况</span><br><span class="line">  function reconcileChildrenArray(</span><br><span class="line">    &#x2F;&#x2F; 父级 Fiber</span><br><span class="line">    returnFiber: Fiber,</span><br><span class="line">    currentFirstChild: Fiber | null,</span><br><span class="line">    &#x2F;&#x2F; 子级 vdom 数组</span><br><span class="line">    newChildren: Array&lt;*&gt;,</span><br><span class="line">    expirationTime: ExpirationTime,</span><br><span class="line">  ): Fiber | null &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 存储第一个子节点 Fiber 对象</span><br><span class="line">     * 方法返回的也是第一个子节点 Fiber 对象</span><br><span class="line">     * 因为其他子节点 Fiber 对象都存储在上一个子 Fiber 节点对象的 sibling 属性中</span><br><span class="line">     *&#x2F;</span><br><span class="line">    let resultingFirstChild: Fiber | null &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 上一次创建的 Fiber 对象</span><br><span class="line">    let previousNewFiber: Fiber | null &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 初始渲染没有旧的子级 所以为 null</span><br><span class="line">    let oldFiber &#x3D; currentFirstChild;</span><br><span class="line"></span><br><span class="line">    let lastPlacedIndex &#x3D; 0;</span><br><span class="line">    let newIdx &#x3D; 0;</span><br><span class="line">    let nextOldFiber &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; oldFiber 为空 说明是初始渲染</span><br><span class="line">    if (oldFiber &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 遍历子 vdom 对象</span><br><span class="line">      for (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建子 vdom 对应的 fiber 对象</span><br><span class="line">        const newFiber &#x3D; createChild(</span><br><span class="line">          returnFiber,</span><br><span class="line">          newChildren[newIdx],</span><br><span class="line">          expirationTime,</span><br><span class="line">        );</span><br><span class="line">        &#x2F;&#x2F; 如果 newFiber 为 null</span><br><span class="line">        if (newFiber &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F; 进入下次循环</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 初始渲染时只为 newFiber 添加了 index 属性,</span><br><span class="line">        &#x2F;&#x2F; 其他事没干. lastPlacedIndex 被原封不动的返回了</span><br><span class="line">        lastPlacedIndex &#x3D; placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        &#x2F;&#x2F; 为当前节点设置下一个兄弟节点</span><br><span class="line">        if (previousNewFiber &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F; 存储第一个子 Fiber 发生在第一次循环时</span><br><span class="line">          resultingFirstChild &#x3D; newFiber;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; 为节点设置下一个兄弟 Fiber</span><br><span class="line">          previousNewFiber.sibling &#x3D; newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 在循环的过程中更新上一个创建的Fiber 对象</span><br><span class="line">        previousNewFiber &#x3D; newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 返回创建好的子 Fiber</span><br><span class="line">      &#x2F;&#x2F; 其他 Fiber 都作为 sibling 存在</span><br><span class="line">      return resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回第一个子元素 Fiber 对象</span><br><span class="line">    return resultingFirstChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 处理子元素是文本或者数值的情况</span><br><span class="line">  function reconcileSingleTextNode(</span><br><span class="line">    returnFiber: Fiber,</span><br><span class="line">    currentFirstChild: Fiber | null,</span><br><span class="line">    textContent: string,</span><br><span class="line">    expirationTime: ExpirationTime,</span><br><span class="line">  ): Fiber &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始渲染不执行</span><br><span class="line">    if (currentFirstChild !&#x3D;&#x3D; null &amp;&amp; currentFirstChild.tag &#x3D;&#x3D;&#x3D; HostText) &#123;</span><br><span class="line">      &#x2F;&#x2F; We already have an existing node so let&#39;s just update it and delete</span><br><span class="line">      &#x2F;&#x2F; the rest.</span><br><span class="line">      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);</span><br><span class="line">      const existing &#x3D; useFiber(currentFirstChild, textContent);</span><br><span class="line">      existing.return &#x3D; returnFiber;</span><br><span class="line">      return existing;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 现有的第一个子节点不是文本节点，因此我们需要创建一个并删除现有的.</span><br><span class="line">    &#x2F;&#x2F; 初始渲染不执行</span><br><span class="line">    deleteRemainingChildren(returnFiber, currentFirstChild);</span><br><span class="line">    &#x2F;&#x2F; 根据文本创建 Fiber 对象</span><br><span class="line">    const created &#x3D; createFiberFromText(</span><br><span class="line">      textContent,</span><br><span class="line">      returnFiber.mode,</span><br><span class="line">      expirationTime,</span><br><span class="line">    );</span><br><span class="line">    &#x2F;&#x2F; 设置父 Fiber 对象</span><br><span class="line">    created.return &#x3D; returnFiber;</span><br><span class="line">    &#x2F;&#x2F; 返回创建好的 Fiber 对象</span><br><span class="line">    return created;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 处理子元素是单个对象的情况</span><br><span class="line">  function reconcileSingleElement(</span><br><span class="line">    &#x2F;&#x2F; 父 Fiber 对象</span><br><span class="line">    returnFiber: Fiber,</span><br><span class="line">    &#x2F;&#x2F; 备份子 fiber</span><br><span class="line">    currentFirstChild: Fiber | null,</span><br><span class="line">    &#x2F;&#x2F; 子 vdom 对象</span><br><span class="line">    element: ReactElement,</span><br><span class="line">    expirationTime: ExpirationTime,</span><br><span class="line">  ): Fiber &#123;</span><br><span class="line">    &#x2F;&#x2F; 查看子 vdom 对象是否表示 fragment</span><br><span class="line">    if (element.type &#x3D;&#x3D;&#x3D; REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">      &#x2F;&#x2F; false</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 根据 React Element 创建 Fiber 对象</span><br><span class="line">      &#x2F;&#x2F; 返回创建好的 Fiber 对象</span><br><span class="line">      const created &#x3D; createFiberFromElement(</span><br><span class="line">        element,</span><br><span class="line">        &#x2F;&#x2F; 用来表示当前组件下的所有子组件要用处于何种渲染模式</span><br><span class="line">        &#x2F;&#x2F; 文件位置: .&#x2F;ReactTypeOfMode.js</span><br><span class="line">        &#x2F;&#x2F; 0    同步渲染模式</span><br><span class="line">        &#x2F;&#x2F; 100  异步渲染模式</span><br><span class="line">        returnFiber.mode,</span><br><span class="line">        expirationTime,</span><br><span class="line">      );</span><br><span class="line">      &#x2F;&#x2F; 添加 ref 属性 &#123; current: DOM &#125;</span><br><span class="line">      created.ref &#x3D; coerceRef(returnFiber, currentFirstChild, element);</span><br><span class="line">      &#x2F;&#x2F; 添加父级 Fiber 对象</span><br><span class="line">      created.return &#x3D; returnFiber;</span><br><span class="line">      &#x2F;&#x2F; 返回创建好的子 Fiber</span><br><span class="line">      return created;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function reconcileChildFibers(</span><br><span class="line">    &#x2F;&#x2F; 父 Fiber 对象</span><br><span class="line">    returnFiber: Fiber,</span><br><span class="line">    &#x2F;&#x2F; 旧的第一个子 Fiber 初始渲染 null</span><br><span class="line">    currentFirstChild: Fiber | null,</span><br><span class="line">    &#x2F;&#x2F; 新的子 vdom 对象</span><br><span class="line">    newChild: any,</span><br><span class="line">    &#x2F;&#x2F; 初始渲染 整型最大值 代表同步任务</span><br><span class="line">    expirationTime: ExpirationTime,</span><br><span class="line">  ): Fiber | null &#123;</span><br><span class="line">    &#x2F;&#x2F; 这是入口方法, 根据 newChild 类型进行对应处理</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 判断新的子 vdom 是否为占位组件 比如 &lt;&gt;&lt;&#x2F;&gt;</span><br><span class="line">    &#x2F;&#x2F; false</span><br><span class="line">    const isUnkeyedTopLevelFragment &#x3D;</span><br><span class="line">      typeof newChild &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp;</span><br><span class="line">      newChild !&#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">      newChild.type &#x3D;&#x3D;&#x3D; REACT_FRAGMENT_TYPE &amp;&amp;</span><br><span class="line">      newChild.key &#x3D;&#x3D;&#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果 newChild 为占位符, 使用 占位符组件的子元素作为 newChild</span><br><span class="line">    if (isUnkeyedTopLevelFragment) &#123;</span><br><span class="line">      newChild &#x3D; newChild.props.children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检测 newChild 是否为对象类型</span><br><span class="line">    const isObject &#x3D; typeof newChild &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; newChild !&#x3D;&#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; newChild 是单个对象的情况</span><br><span class="line">    if (isObject) &#123;</span><br><span class="line">      &#x2F;&#x2F; 匹配子元素的类型</span><br><span class="line">      switch (newChild.$$typeof) &#123;</span><br><span class="line">        &#x2F;&#x2F; 子元素为 ReactElement</span><br><span class="line">        case REACT_ELEMENT_TYPE:</span><br><span class="line">          &#x2F;&#x2F; 为 Fiber 对象设置 effectTag 属性</span><br><span class="line">          &#x2F;&#x2F; 返回创建好的子 Fiber</span><br><span class="line">          return placeSingleChild(</span><br><span class="line">            &#x2F;&#x2F; 处理单个 React Element 的情况</span><br><span class="line">            &#x2F;&#x2F; 内部会调用其他方法创建对应的 Fiber 对象</span><br><span class="line">            reconcileSingleElement(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              expirationTime,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F; 处理 children 为文本和数值的情况 return &quot;App works&quot;</span><br><span class="line">    if (typeof newChild &#x3D;&#x3D;&#x3D; &#39;string&#39; || typeof newChild &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;</span><br><span class="line">      return placeSingleChild(</span><br><span class="line">        reconcileSingleTextNode(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          &#x2F;&#x2F; 如果 newChild 是数值, 转换为字符串</span><br><span class="line">          &#39;&#39; + newChild,</span><br><span class="line">          expirationTime,</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; children 是数组的情况</span><br><span class="line">    if (isArray(newChild)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回创建好的子 Fiber</span><br><span class="line">      return reconcileChildrenArray(</span><br><span class="line">        returnFiber,</span><br><span class="line">        currentFirstChild,</span><br><span class="line">        newChild,</span><br><span class="line">        expirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-8-10-completeUnitOfWork"><a href="#5-1-8-10-completeUnitOfWork" class="headerlink" title="5.1.8.10 completeUnitOfWork"></a>5.1.8.10 completeUnitOfWork</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * 从下至上移动到该节点的兄弟节点, 如果一直往上没有兄弟节点就返回父节点, 最终会到达 root 节点</span><br><span class="line"> * 1. 创建其他节点的 Fiber 对象</span><br><span class="line"> * 2. 创建每一个节点的真实 DOM 对象并将其添加到 stateNode 属性中</span><br><span class="line"> * 3. 构建 effect 链表结构</span><br><span class="line"> *&#x2F;</span><br><span class="line">function completeUnitOfWork(unitOfWork: Fiber): Fiber | null &#123;</span><br><span class="line">  &#x2F;&#x2F; 为 workInProgress 全局变量重新赋值</span><br><span class="line">  workInProgress &#x3D; unitOfWork;</span><br><span class="line">  do &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取备份节点</span><br><span class="line">    &#x2F;&#x2F; 初始化渲染 非根 Fiber 对象没有备份节点 所以 current 为 null</span><br><span class="line">    const current &#x3D; workInProgress.alternate;</span><br><span class="line">    &#x2F;&#x2F; 父级 Fiber 对象, 非根 Fiber 对象都有父级</span><br><span class="line">    const returnFiber &#x3D; workInProgress.return;</span><br><span class="line">    &#x2F;&#x2F; 判断传入的 Fiber 对象是否构建完成, 任务调度相关</span><br><span class="line">    &#x2F;&#x2F; &amp; 是表示位的与运算, 把左右两边的数字转化为二进制</span><br><span class="line">    &#x2F;&#x2F; 然后每一位分别进行比较, 如果相等就为1, 不相等即为0</span><br><span class="line">    &#x2F;&#x2F; 此处应用&quot;位与&quot;运算符的目的是&quot;清零&quot;</span><br><span class="line">    &#x2F;&#x2F; true</span><br><span class="line">    if ((workInProgress.effectTag &amp; Incomplete) &#x3D;&#x3D;&#x3D; NoEffect) &#123;</span><br><span class="line">      let next;</span><br><span class="line">      &#x2F;&#x2F; 如果不能使用分析器的 timer, 直接执行 completeWork</span><br><span class="line">      &#x2F;&#x2F; enableProfilerTimer &#x3D;&gt; true</span><br><span class="line">      &#x2F;&#x2F; 但此处无论条件是否成立都会执行 completeWork</span><br><span class="line">      if (</span><br><span class="line">        !enableProfilerTimer ||</span><br><span class="line">        (workInProgress.mode &amp; ProfileMode) &#x3D;&#x3D;&#x3D; NoMode</span><br><span class="line">      ) &#123;</span><br><span class="line">        &#x2F;&#x2F; 重点代码(二)</span><br><span class="line">        &#x2F;&#x2F; 创建节点真实 DOM 对象并将其添加到 stateNode 属性中</span><br><span class="line">        next &#x3D; completeWork(current, workInProgress, renderExpirationTime);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建节点真实 DOM 对象并将其添加到 stateNode 属性中</span><br><span class="line">        next &#x3D; completeWork(current, workInProgress, renderExpirationTime);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 重点代码(一)</span><br><span class="line">      &#x2F;&#x2F; 如果子级存在</span><br><span class="line">      if (next !&#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 返回子级 一直返回到 workLoopSync</span><br><span class="line">        &#x2F;&#x2F; 再重新执行 performUnitOfWork 构建子级 Fiber 节点对象</span><br><span class="line">        return next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 构建 effect 链表结构</span><br><span class="line">      &#x2F;&#x2F; 如果不是根 Fiber 就是 true 否则就是 false</span><br><span class="line">      &#x2F;&#x2F; 将子树和此 Fiber 的所有 effect 附加到父级的 effect 列表中</span><br><span class="line">      if (</span><br><span class="line">        &#x2F;&#x2F; 如果父 Fiber 存在 并且</span><br><span class="line">        returnFiber !&#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">        &#x2F;&#x2F; 父 Fiber 对象中的 effectTag 为 0</span><br><span class="line">        (returnFiber.effectTag &amp; Incomplete) &#x3D;&#x3D;&#x3D; NoEffect</span><br><span class="line">      ) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将子树和此 Fiber 的所有副作用附加到父级的 effect 列表上</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 以下两个判断的作用是搜集子 Fiber的 effect 到父 Fiber</span><br><span class="line">        if (returnFiber.firstEffect &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F; first</span><br><span class="line">          returnFiber.firstEffect &#x3D; workInProgress.firstEffect;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (workInProgress.lastEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">          if (returnFiber.lastEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; next</span><br><span class="line">            returnFiber.lastEffect.nextEffect &#x3D; workInProgress.firstEffect;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; last</span><br><span class="line">          returnFiber.lastEffect &#x3D; workInProgress.lastEffect;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取副作用标记</span><br><span class="line">        &#x2F;&#x2F; 初始渲染时除[根组件]以外的 Fiber, effectTag 值都为 0, 即不需要执行任何真实DOM操作</span><br><span class="line">        &#x2F;&#x2F; 根组件的 effectTag 值为 3, 即需要将此节点对应的真实DOM对象添加到页面中</span><br><span class="line">        const effectTag &#x3D; workInProgress.effectTag;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建 effect 列表时跳过 NoWork(0) 和 PerformedWork(1) 标记</span><br><span class="line">        &#x2F;&#x2F; PerformedWork 由 React DevTools 读取, 不提交</span><br><span class="line">        &#x2F;&#x2F; 初始渲染时 只有遍历到了根组件 判断条件才能成立, 将 effect 链表添加到 rootFiber</span><br><span class="line">        &#x2F;&#x2F; 初始渲染 FiberRoot 对象中的 firstEffect 和 lastEffect 都是 App 组件</span><br><span class="line">        &#x2F;&#x2F; 因为当所有节点在内存中构建完成后, 只需要一次将所有 DOM 添加到页面中</span><br><span class="line">        if (effectTag &gt; PerformedWork) &#123;</span><br><span class="line">          &#x2F;&#x2F; false</span><br><span class="line">          if (returnFiber.lastEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">            returnFiber.lastEffect.nextEffect &#x3D; workInProgress;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 为 fiberRoot 添加 firstEffect</span><br><span class="line">            returnFiber.firstEffect &#x3D; workInProgress;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; 为 fiberRoot 添加 lastEffect</span><br><span class="line">          returnFiber.lastEffect &#x3D; workInProgress;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	&#x2F;&#x2F; 忽略了初始渲染不执行的代码      </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 获取下一个同级 Fiber 对象</span><br><span class="line">    const siblingFiber &#x3D; workInProgress.sibling;</span><br><span class="line">    &#x2F;&#x2F; 如果下一个同级 Fiber 对象存在</span><br><span class="line">    if (siblingFiber !&#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回下一个同级 Fiber 对象</span><br><span class="line">      return siblingFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 否则退回父级</span><br><span class="line">    workInProgress &#x3D; returnFiber;</span><br><span class="line">  &#125; while (workInProgress !&#x3D;&#x3D; null);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当执行到这里的时候, 说明遍历到了 root 节点, 已完成遍历</span><br><span class="line">  &#x2F;&#x2F; 更新 workInProgressRootExitStatus 的状态为 已完成</span><br><span class="line">  if (workInProgressRootExitStatus &#x3D;&#x3D;&#x3D; RootIncomplete) &#123;</span><br><span class="line">    workInProgressRootExitStatus &#x3D; RootCompleted;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-8-11-completeWork"><a href="#5-1-8-11-completeWork" class="headerlink" title="5.1.8.11 completeWork"></a>5.1.8.11 completeWork</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberCompleteWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function completeWork(</span><br><span class="line">  current: Fiber | null,</span><br><span class="line">  workInProgress: Fiber,</span><br><span class="line">  renderExpirationTime: ExpirationTime,</span><br><span class="line">): Fiber | null &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取待更新 props</span><br><span class="line">  const newProps &#x3D; workInProgress.pendingProps;</span><br><span class="line">  switch (workInProgress.tag) &#123;</span><br><span class="line">    &#x2F;&#x2F; 0</span><br><span class="line">    case FunctionComponent:</span><br><span class="line">      return null;</span><br><span class="line">    &#x2F;&#x2F; 3</span><br><span class="line">    case HostRoot: &#123;</span><br><span class="line">      updateHostContainer(workInProgress);</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 5</span><br><span class="line">    case HostComponent: &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取 rootDOM 节点 &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">      const rootContainerInstance &#x3D; getRootHostContainer();</span><br><span class="line">      &#x2F;&#x2F; 节点的具体的类型 div span ...</span><br><span class="line">      const type &#x3D; workInProgress.type;</span><br><span class="line">      &#x2F;&#x2F; false current &#x3D; null</span><br><span class="line">      if (current !&#x3D;&#x3D; null &amp;&amp; workInProgress.stateNode !&#x3D; null) &#123;</span><br><span class="line">       &#x2F;&#x2F; 初始渲染不执行</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">				&#x2F;&#x2F; false</span><br><span class="line">        if (wasHydrated) &#123;</span><br><span class="line">         &#x2F;&#x2F; 初始渲染不执行</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; 创建节点实例对象 &lt;div&gt;&lt;&#x2F;div&gt; &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">          let instance &#x3D; createInstance(</span><br><span class="line">            type,</span><br><span class="line">            newProps,</span><br><span class="line">            rootContainerInstance,</span><br><span class="line">            currentHostContext,</span><br><span class="line">            workInProgress,</span><br><span class="line">          );</span><br><span class="line">          &#x2F;**</span><br><span class="line">           * 将所有的子级追加到父级中</span><br><span class="line">           * instance 为父级</span><br><span class="line">           * workInProgress.child 为子级</span><br><span class="line">           *&#x2F;</span><br><span class="line">          appendAllChildren(instance, workInProgress, false, false);</span><br><span class="line">          &#x2F;&#x2F; 为 Fiber 对象添加 stateNode 属性</span><br><span class="line">          workInProgress.stateNode &#x3D; instance;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 处理 ref DOM 引用</span><br><span class="line">        if (workInProgress.ref !&#x3D;&#x3D; null) &#123;</span><br><span class="line">          markRef(workInProgress);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-8-12-appendAllChildren"><a href="#5-1-8-12-appendAllChildren" class="headerlink" title="5.1.8.12 appendAllChildren"></a>5.1.8.12 appendAllChildren</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberCompleteWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendAllChildren &#x3D; function (</span><br><span class="line">    parent: Instance,</span><br><span class="line">    workInProgress: Fiber,</span><br><span class="line">    needsVisibilityToggle: boolean,</span><br><span class="line">    isHidden: boolean,</span><br><span class="line">  ) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取子级</span><br><span class="line">    let node &#x3D; workInProgress.child;</span><br><span class="line">    &#x2F;&#x2F; 如果子级不为空 执行循环</span><br><span class="line">    while (node !&#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果 node 是普通 ReactElement 或者为文本</span><br><span class="line">      if (node.tag &#x3D;&#x3D;&#x3D; HostComponent || node.tag &#x3D;&#x3D;&#x3D; HostText) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将子级追加到父级中</span><br><span class="line">        appendInitialChild(parent, node.stateNode);</span><br><span class="line">      &#125; else if (node.child !&#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果 node 不是普通 ReactElement 又不是文本</span><br><span class="line">        &#x2F;&#x2F; 将 node 视为组件, 组件本身不能转换为真实 DOM 元素</span><br><span class="line">        &#x2F;&#x2F; 获取到组件的第一个子元素, 继续执行循环</span><br><span class="line">        node.child.return &#x3D; node;</span><br><span class="line">        node &#x3D; node.child;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 如果 node 和 workInProgress 是同一个节点</span><br><span class="line">      &#x2F;&#x2F; 说明 node 已经退回到父级 终止循环</span><br><span class="line">      &#x2F;&#x2F; 说明此时所有子级都已经追加到父级中了</span><br><span class="line">      if (node &#x3D;&#x3D;&#x3D; workInProgress) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 处理子级节点的兄弟节点</span><br><span class="line">      while (node.sibling &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果节点没有父级或者节点的父级是自己, 退出循环</span><br><span class="line">        &#x2F;&#x2F; 说明此时所有子级都已经追加到父级中了</span><br><span class="line">        if (node.return &#x3D;&#x3D;&#x3D; null || node.return &#x3D;&#x3D;&#x3D; workInProgress) &#123;</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 更新 node</span><br><span class="line">        node &#x3D; node.return;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 更新父级 方便回退</span><br><span class="line">      node.sibling.return &#x3D; node.return;</span><br><span class="line">      &#x2F;&#x2F; 将 node 更新为下一个兄弟节点</span><br><span class="line">      node &#x3D; node.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-commit-阶段"><a href="#5-2-commit-阶段" class="headerlink" title="5.2 commit 阶段"></a>5.2 commit 阶段</h3><h4 id="5-2-1-finishSyncRender"><a href="#5-2-1-finishSyncRender" class="headerlink" title="5.2.1 finishSyncRender"></a>5.2.1 finishSyncRender</h4><p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function finishSyncRender(root) &#123;</span><br><span class="line">  &#x2F;&#x2F; 销毁 workInProgress Fiber 树</span><br><span class="line">  &#x2F;&#x2F; 因为待提交 Fiber 对象已经被存储在了 root.finishedWork 中</span><br><span class="line">  workInProgressRoot &#x3D; null;</span><br><span class="line">  &#x2F;&#x2F; 进入 commit 阶段</span><br><span class="line">  commitRoot(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-commitRoot"><a href="#5-2-2-commitRoot" class="headerlink" title="5.2.2 commitRoot"></a>5.2.2 commitRoot</h4><p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function commitRoot(root) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取任务优先级 97 &#x3D;&gt; 普通优先级</span><br><span class="line">  const renderPriorityLevel &#x3D; getCurrentPriorityLevel();</span><br><span class="line">  &#x2F;&#x2F; 使用最高优先级执行当前任务, 因为 commit 阶段不可以被打断</span><br><span class="line">  &#x2F;&#x2F; ImmediatePriority, 优先级为 99, 最高优先级</span><br><span class="line">  runWithPriority(</span><br><span class="line">    ImmediatePriority,</span><br><span class="line">    commitRootImpl.bind(null, root, renderPriorityLevel),</span><br><span class="line">  );</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-commitRootImpl"><a href="#5-2-3-commitRootImpl" class="headerlink" title="5.2.3 commitRootImpl"></a>5.2.3 commitRootImpl</h4><p>commit 阶段可以分为三个子阶段：</p>
<ul>
<li>before mutation 阶段（执行 DOM 操作前）</li>
<li>mutation 阶段（执行 DOM 操作）</li>
<li>layout 阶段（执行 DOM 操作后）</li>
</ul>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function commitRootImpl(root, renderPriorityLevel) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取待提交 Fiber 对象 rootFiber</span><br><span class="line">  const finishedWork &#x3D; root.finishedWork;</span><br><span class="line">  &#x2F;&#x2F; 如果没有任务要执行</span><br><span class="line">  if (finishedWork &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 阻止程序继续向下执行</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 重置为默认值</span><br><span class="line">  root.finishedWork &#x3D; null;</span><br><span class="line">  root.callbackNode &#x3D; null;</span><br><span class="line">  root.callbackExpirationTime &#x3D; NoWork;</span><br><span class="line">  root.callbackPriority &#x3D; NoPriority;</span><br><span class="line">  root.nextKnownPendingLevel &#x3D; NoWork;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 获取要执行 DOM 操作的副作用列表</span><br><span class="line">  let firstEffect &#x3D; finishedWork.firstEffect;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; true</span><br><span class="line">  if (firstEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; commit 第一个子阶段</span><br><span class="line">    nextEffect &#x3D; firstEffect;</span><br><span class="line">    &#x2F;&#x2F; 处理类组件的 getSnapShotBeforeUpdate 生命周期函数</span><br><span class="line">    do &#123;</span><br><span class="line">      invokeGuardedCallback(null, commitBeforeMutationEffects, null);</span><br><span class="line">    &#125; while (nextEffect !&#x3D;&#x3D; null);</span><br><span class="line">    </span><br><span class="line">		&#x2F;&#x2F; commit 第二个子阶段</span><br><span class="line">    nextEffect &#x3D; firstEffect;</span><br><span class="line">    do &#123;</span><br><span class="line">      invokeGuardedCallback(null, commitMutationEffects, null, root, renderPriorityLevel);</span><br><span class="line">    &#125; while (nextEffect !&#x3D;&#x3D; null);</span><br><span class="line">    &#x2F;&#x2F; 将 workInProgress Fiber 树变成 current Fiber 树</span><br><span class="line">    root.current &#x3D; finishedWork;</span><br><span class="line">    </span><br><span class="line">		&#x2F;&#x2F; commit 第三个子阶段</span><br><span class="line">    nextEffect &#x3D; firstEffect;</span><br><span class="line">    do &#123;</span><br><span class="line">      invokeGuardedCallback(null, commitLayoutEffects, null, root,expirationTime);</span><br><span class="line">    &#125; while (nextEffect !&#x3D;&#x3D; null);</span><br><span class="line">		</span><br><span class="line">    &#x2F;&#x2F; 重置 nextEffect</span><br><span class="line">    nextEffect &#x3D; null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-4-第一子阶段"><a href="#5-2-4-第一子阶段" class="headerlink" title="5.2.4 第一子阶段"></a>5.2.4 第一子阶段</h4><h5 id="5-2-4-1-commitBeforeMutationEffects"><a href="#5-2-4-1-commitBeforeMutationEffects" class="headerlink" title="5.2.4.1 commitBeforeMutationEffects"></a>5.2.4.1 commitBeforeMutationEffects</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; commit 阶段的第一个子阶段</span><br><span class="line">&#x2F;&#x2F; 调用类组件的 getSnapshotBeforeUpdate 生命周期函数</span><br><span class="line">function commitBeforeMutationEffects() &#123;</span><br><span class="line">  &#x2F;&#x2F; 循环 effect 链</span><br><span class="line">  while (nextEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; nextEffect 是 effect 链上从 firstEffect 到 lastEffec 的每一个需要commit的 fiber 对象</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 初始化渲染第一个 nextEffect 为 App 组件</span><br><span class="line">    &#x2F;&#x2F; effectTag &#x3D;&gt; 3</span><br><span class="line">    const effectTag &#x3D; nextEffect.effectTag;</span><br><span class="line">    &#x2F;&#x2F; console.log(effectTag);</span><br><span class="line">    &#x2F;&#x2F; nextEffect &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果 fiber 对象中里有 Snapshot 这个 effectTag 的话</span><br><span class="line">    &#x2F;&#x2F; Snapshot 和更新有关系 初始化渲染 不执行</span><br><span class="line">    &#x2F;&#x2F; false</span><br><span class="line">    if ((effectTag &amp; Snapshot) !&#x3D;&#x3D; NoEffect) &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取当前 fiber 节点</span><br><span class="line">      const current &#x3D; nextEffect.alternate;</span><br><span class="line">      &#x2F;&#x2F; 当 nextEffect 上有 Snapshot 这个 effectTag 时</span><br><span class="line">      &#x2F;&#x2F; 执行以下方法, 主要是类组件调用 getSnapshotBeforeUpdate 生命周期函数</span><br><span class="line">      commitBeforeMutationEffectOnFiber(current, nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 更新循环条件</span><br><span class="line">    nextEffect &#x3D; nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-4-2-commitBeforeMutationLifeCycles"><a href="#5-2-4-2-commitBeforeMutationLifeCycles" class="headerlink" title="5.2.4.2 commitBeforeMutationLifeCycles"></a>5.2.4.2 commitBeforeMutationLifeCycles</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberCommitWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function commitBeforeMutationLifeCycles(</span><br><span class="line">  current: Fiber | null,</span><br><span class="line">  finishedWork: Fiber,</span><br><span class="line">): void &#123;</span><br><span class="line">  switch (finishedWork.tag) &#123;</span><br><span class="line">    case FunctionComponent:</span><br><span class="line">    case ForwardRef:</span><br><span class="line">    case SimpleMemoComponent:</span><br><span class="line">    case Block: &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果该 fiber 类型是 ClassComponent</span><br><span class="line">    case ClassComponent: &#123;</span><br><span class="line">      if (finishedWork.effectTag &amp; Snapshot) &#123;</span><br><span class="line">        if (current !&#x3D;&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F; 旧的 props</span><br><span class="line">          const prevProps &#x3D; current.memoizedProps;</span><br><span class="line">          &#x2F;&#x2F; 旧的 state</span><br><span class="line">          const prevState &#x3D; current.memoizedState;</span><br><span class="line">          &#x2F;&#x2F; 获取 classComponent 组件的实例对象</span><br><span class="line">          const instance &#x3D; finishedWork.stateNode;</span><br><span class="line">          &#x2F;&#x2F; 执行 getSnapshotBeforeUpdate 生命周期函数</span><br><span class="line">          &#x2F;&#x2F; 在组件更新前捕获一些 DOM 信息</span><br><span class="line">          &#x2F;&#x2F; 返回自定义的值或 null, 统称为 snapshot</span><br><span class="line">          const snapshot &#x3D; instance.getSnapshotBeforeUpdate(</span><br><span class="line">            finishedWork.elementType &#x3D;&#x3D;&#x3D; finishedWork.type</span><br><span class="line">              ? prevProps</span><br><span class="line">              : resolveDefaultProps(finishedWork.type, prevProps),</span><br><span class="line">            prevState,</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    case HostRoot:</span><br><span class="line">    case HostComponent:</span><br><span class="line">    case HostText:</span><br><span class="line">    case HostPortal:</span><br><span class="line">    case IncompleteClassComponent:</span><br><span class="line">      &#x2F;&#x2F; Nothing to do for these component types</span><br><span class="line">      return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-5-第二子阶段"><a href="#5-2-5-第二子阶段" class="headerlink" title="5.2.5 第二子阶段"></a>5.2.5 第二子阶段</h4><h5 id="5-2-5-1-commitMutationEffects"><a href="#5-2-5-1-commitMutationEffects" class="headerlink" title="5.2.5.1 commitMutationEffects"></a>5.2.5.1 commitMutationEffects</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; commit 阶段的第二个子阶段</span><br><span class="line">&#x2F;&#x2F; 根据 effectTag 执行 DOM 操作</span><br><span class="line">function commitMutationEffects(root: FiberRoot, renderPriorityLevel) &#123;</span><br><span class="line">  &#x2F;&#x2F; 循环 effect 链</span><br><span class="line">  while (nextEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 effectTag</span><br><span class="line">    &#x2F;&#x2F; 初始渲染第一次循环为 App 组件</span><br><span class="line">    &#x2F;&#x2F; 即将根组件及内部所有内容一次性添加到页面中</span><br><span class="line">    const effectTag &#x3D; nextEffect.effectTag;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据 effectTag 分别处理</span><br><span class="line">    let primaryEffectTag &#x3D;</span><br><span class="line">      effectTag &amp; (Placement | Update | Deletion | Hydrating);</span><br><span class="line">    &#x2F;&#x2F; 匹配 effectTag</span><br><span class="line">    &#x2F;&#x2F; 初始渲染 primaryEffectTag 为 2 匹配到 Placement</span><br><span class="line">    switch (primaryEffectTag) &#123;</span><br><span class="line">      &#x2F;&#x2F; 针对该节点及子节点进行插入操作</span><br><span class="line">      case Placement: &#123;</span><br><span class="line">        commitPlacement(nextEffect);</span><br><span class="line">        &#x2F;&#x2F; effectTag 从 3 变为 1</span><br><span class="line">        &#x2F;&#x2F; 从 effect 标签中清除 &quot;placement&quot; 重置 effectTag 值</span><br><span class="line">        &#x2F;&#x2F; 以便我们知道在调用诸如componentDidMount之类的任何生命周期之前已将其插入。</span><br><span class="line">        nextEffect.effectTag &amp;&#x3D; ~Placement;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 插入并更新 DOM</span><br><span class="line">      case PlacementAndUpdate: &#123;</span><br><span class="line">        &#x2F;&#x2F; 插入</span><br><span class="line">        commitPlacement(nextEffect);</span><br><span class="line">        nextEffect.effectTag &amp;&#x3D; ~Placement;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 更新</span><br><span class="line">        const current &#x3D; nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 服务器端渲染</span><br><span class="line">      case Hydrating: &#123;</span><br><span class="line">        nextEffect.effectTag &amp;&#x3D; ~Hydrating;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 服务器端渲染</span><br><span class="line">      case HydratingAndUpdate: &#123;</span><br><span class="line">        nextEffect.effectTag &amp;&#x3D; ~Hydrating;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Update</span><br><span class="line">        const current &#x3D; nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 更新 DOM</span><br><span class="line">      case Update: &#123;</span><br><span class="line">        const current &#x3D; nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 删除 DOM</span><br><span class="line">      case Deletion: &#123;</span><br><span class="line">        commitDeletion(root, nextEffect, renderPriorityLevel);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect &#x3D; nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-5-2-commitPlacement"><a href="#5-2-5-2-commitPlacement" class="headerlink" title="5.2.5.2 commitPlacement"></a>5.2.5.2 commitPlacement</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberCommitWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 挂载 DOM 元素</span><br><span class="line">function commitPlacement(finishedWork: Fiber): void &#123;</span><br><span class="line">  &#x2F;&#x2F; finishedWork 初始化渲染时为根组件 Fiber 对象</span><br><span class="line">  &#x2F;&#x2F; 获取非组件父级 Fiber 对象</span><br><span class="line">  &#x2F;&#x2F; 初始渲染时为 &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  const parentFiber &#x3D; getHostParentFiber(finishedWork);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 存储真正的父级 DOM 节点对象</span><br><span class="line">  let parent;</span><br><span class="line">  &#x2F;&#x2F; 是否为渲染容器</span><br><span class="line">  &#x2F;&#x2F; 渲染容器和普通react元素的主要区别在于是否需要特殊处理注释节点</span><br><span class="line">  let isContainer;</span><br><span class="line">  &#x2F;&#x2F; 获取父级 DOM 节点对象</span><br><span class="line">  &#x2F;&#x2F; 但是初始渲染时 rootFiber 对象中的 stateNode 存储的是 FiberRoot</span><br><span class="line">  const parentStateNode &#x3D; parentFiber.stateNode;</span><br><span class="line">  &#x2F;&#x2F; 判断父节点的类型</span><br><span class="line">  &#x2F;&#x2F; 初始渲染时是 hostRoot 3</span><br><span class="line">  switch (parentFiber.tag) &#123;</span><br><span class="line">    case HostComponent:</span><br><span class="line">      parent &#x3D; parentStateNode;</span><br><span class="line">      isContainer &#x3D; false;</span><br><span class="line">      break;</span><br><span class="line">    case HostRoot:</span><br><span class="line">      &#x2F;&#x2F; 获取真正的 DOM 节点对象</span><br><span class="line">      &#x2F;&#x2F; &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">      parent &#x3D; parentStateNode.containerInfo;</span><br><span class="line">      &#x2F;&#x2F; 是 container 容器</span><br><span class="line">      isContainer &#x3D; true;</span><br><span class="line">      break;</span><br><span class="line">    case HostPortal:</span><br><span class="line">      parent &#x3D; parentStateNode.containerInfo;</span><br><span class="line">      isContainer &#x3D; true;</span><br><span class="line">      break;</span><br><span class="line">    case FundamentalComponent:</span><br><span class="line">      if (enableFundamentalAPI) &#123;</span><br><span class="line">        parent &#x3D; parentStateNode.instance;</span><br><span class="line">        isContainer &#x3D; false;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 查看当前节点是否有下一个兄弟节点</span><br><span class="line">  &#x2F;&#x2F; 有, 执行 insertBefore</span><br><span class="line">  &#x2F;&#x2F; 没有, 执行 appendChild</span><br><span class="line">  const before &#x3D; getHostSibling(finishedWork);</span><br><span class="line">	&#x2F;&#x2F; 渲染容器</span><br><span class="line">  if (isContainer) &#123;</span><br><span class="line">    &#x2F;&#x2F; 向父节点中追加节点 或者 将子节点插入到 before 节点的前面</span><br><span class="line">    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 非渲染容器</span><br><span class="line">    &#x2F;&#x2F; 向父节点中追加节点 或者 将子节点插入到 before 节点的前面</span><br><span class="line">    insertOrAppendPlacementNode(finishedWork, before, parent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-5-3-getHostParentFiber"><a href="#5-2-5-3-getHostParentFiber" class="headerlink" title="5.2.5.3 getHostParentFiber"></a>5.2.5.3 getHostParentFiber</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberCommitWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取 HostRootFiber 对象</span><br><span class="line">function getHostParentFiber(fiber: Fiber): Fiber &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取当前 Fiber 父级</span><br><span class="line">  let parent &#x3D; fiber.return;</span><br><span class="line">  &#x2F;&#x2F; 查看父级是否为 null</span><br><span class="line">  while (parent !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 查看父级是否为 hostRoot</span><br><span class="line">    if (isHostParent(parent)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回</span><br><span class="line">      return parent;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 继续向上查找</span><br><span class="line">    parent &#x3D; parent.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-5-4-insertOrAppendPlacementNodeIntoContainer"><a href="#5-2-5-4-insertOrAppendPlacementNodeIntoContainer" class="headerlink" title="5.2.5.4 insertOrAppendPlacementNodeIntoContainer"></a>5.2.5.4 insertOrAppendPlacementNodeIntoContainer</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberCommitWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 向容器中追加 | 插入到某一个节点的前面</span><br><span class="line">function insertOrAppendPlacementNodeIntoContainer(</span><br><span class="line">  node: Fiber,</span><br><span class="line">  before: ?Instance,</span><br><span class="line">  parent: Container,</span><br><span class="line">): void &#123;</span><br><span class="line">  const &#123;tag&#125; &#x3D; node;</span><br><span class="line">  &#x2F;&#x2F; 如果待插入的节点是一个 DOM 元素或者文本的话</span><br><span class="line">  &#x2F;&#x2F; 比如 组件fiber &#x3D;&gt; false div &#x3D;&gt; true</span><br><span class="line">  const isHost &#x3D; tag &#x3D;&#x3D;&#x3D; HostComponent || tag &#x3D;&#x3D;&#x3D; HostText;</span><br><span class="line"></span><br><span class="line">  if (isHost || (enableFundamentalAPI &amp;&amp; tag &#x3D;&#x3D;&#x3D; FundamentalComponent)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 DOM 节点</span><br><span class="line">    const stateNode &#x3D; isHost ? node.stateNode : node.stateNode.instance;</span><br><span class="line">    &#x2F;&#x2F; 如果 before 存在</span><br><span class="line">    if (before) &#123;</span><br><span class="line">      &#x2F;&#x2F; 插入到 before 前面</span><br><span class="line">      insertInContainerBefore(parent, stateNode, before);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 追加到父容器中</span><br><span class="line">      appendChildToContainer(parent, stateNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果是组件节点, 比如 ClassComponent, 则找它的第一个子节点(DOM 元素)</span><br><span class="line">    &#x2F;&#x2F; 进行插入操作</span><br><span class="line">    const child &#x3D; node.child;</span><br><span class="line">    if (child !&#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 向父级中追加子节点或者将子节点插入到 before 的前面</span><br><span class="line">      insertOrAppendPlacementNodeIntoContainer(child, before, parent);</span><br><span class="line">      &#x2F;&#x2F; 获取下一个兄弟节点</span><br><span class="line">      let sibling &#x3D; child.sibling;</span><br><span class="line">      &#x2F;&#x2F; 如果兄弟节点存在</span><br><span class="line">      while (sibling !&#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 向父级中追加子节点或者将子节点插入到 before 的前面</span><br><span class="line">        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);</span><br><span class="line">        &#x2F;&#x2F; 同步兄弟节点</span><br><span class="line">        sibling &#x3D; sibling.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-5-5-insertInContainerBefore"><a href="#5-2-5-5-insertInContainerBefore" class="headerlink" title="5.2.5.5 insertInContainerBefore"></a>5.2.5.5 insertInContainerBefore</h5><p><code>文件位置: packages/react-dom/src/client/ReactDOMHostConfig.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function insertInContainerBefore(</span><br><span class="line">  container: Container,</span><br><span class="line">  child: Instance | TextInstance,</span><br><span class="line">  beforeChild: Instance | TextInstance | SuspenseInstance,</span><br><span class="line">): void &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果父容器是注释节点</span><br><span class="line">  if (container.nodeType &#x3D;&#x3D;&#x3D; COMMENT_NODE) &#123;</span><br><span class="line">    &#x2F;&#x2F; 找到注释节点的父级节点 因为注释节点没法调用 insertBefore</span><br><span class="line">    (container.parentNode: any).insertBefore(child, beforeChild);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 child 插入到 beforeChild 的前面</span><br><span class="line">    container.insertBefore(child, beforeChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-5-6-appendChildToContainer"><a href="#5-2-5-6-appendChildToContainer" class="headerlink" title="5.2.5.6 appendChildToContainer"></a>5.2.5.6 appendChildToContainer</h5><p><code>文件位置: packages/react-dom/src/client/ReactDOMHostConfig.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function appendChildToContainer(</span><br><span class="line">  container: Container,</span><br><span class="line">  child: Instance | TextInstance,</span><br><span class="line">): void &#123;</span><br><span class="line">  &#x2F;&#x2F; 监测 container 是否注释节点</span><br><span class="line">  if (container.nodeType &#x3D;&#x3D;&#x3D; COMMENT_NODE) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取父级的父级</span><br><span class="line">    parentNode &#x3D; (container.parentNode: any);</span><br><span class="line">    &#x2F;&#x2F; 将子级节点插入到注释节点的前面</span><br><span class="line">    parentNode.insertBefore(child, container);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 直接将 child 插入到父级中</span><br><span class="line">    parentNode &#x3D; container;</span><br><span class="line">    parentNode.appendChild(child);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-6-第三子阶段"><a href="#5-2-6-第三子阶段" class="headerlink" title="5.2.6 第三子阶段"></a>5.2.6 第三子阶段</h4><h5 id="5-2-6-1-commitLayoutEffects"><a href="#5-2-6-1-commitLayoutEffects" class="headerlink" title="5.2.6.1 commitLayoutEffects"></a>5.2.6.1 commitLayoutEffects</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; commit 阶段的第三个子阶段</span><br><span class="line">function commitLayoutEffects(</span><br><span class="line">  root: FiberRoot,</span><br><span class="line">  committedExpirationTime: ExpirationTime,</span><br><span class="line">) &#123;</span><br><span class="line">  while (nextEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 此时 effectTag 已经被重置为 1, 表示 DOM 操作已经完成</span><br><span class="line">    const effectTag &#x3D; nextEffect.effectTag;</span><br><span class="line">    &#x2F;&#x2F; 调用生命周期函数和钩子函数</span><br><span class="line">    &#x2F;&#x2F; 前提是类组件中调用了生命周期函数 或者函数组件中调用了 useEffect</span><br><span class="line">    if (effectTag &amp; (Update | Callback)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 类组件处理生命周期函数</span><br><span class="line">      &#x2F;&#x2F; 函数组件处理钩子函数</span><br><span class="line">      commitLayoutEffectOnFiber(root, current,nextEffect, committedExpirationTime);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 更新循环条件</span><br><span class="line">    nextEffect &#x3D; nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-6-2-commitLifeCycles"><a href="#5-2-6-2-commitLifeCycles" class="headerlink" title="5.2.6.2 commitLifeCycles"></a>5.2.6.2 commitLifeCycles</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberCommitWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function commitLifeCycles(</span><br><span class="line">  finishedRoot: FiberRoot,</span><br><span class="line">  current: Fiber | null,</span><br><span class="line">  finishedWork: Fiber,</span><br><span class="line">  committedExpirationTime: ExpirationTime,</span><br><span class="line">): void &#123;</span><br><span class="line">  switch (finishedWork.tag) &#123;</span><br><span class="line">    case FunctionComponent: &#123;</span><br><span class="line">      &#x2F;&#x2F; 处理钩子函数</span><br><span class="line">      commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    case ClassComponent: &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取类组件实例对象</span><br><span class="line">      const instance &#x3D; finishedWork.stateNode;</span><br><span class="line">      &#x2F;&#x2F; 如果在类组件中存在生命周期函数判断条件就会成立</span><br><span class="line">      if (finishedWork.effectTag &amp; Update) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始渲染阶段</span><br><span class="line">        if (current &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F; 调用 componentDidMount 生命周期函数</span><br><span class="line">          instance.componentDidMount();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; 更新阶段</span><br><span class="line">          &#x2F;&#x2F; 获取旧的 props</span><br><span class="line">          const prevProps &#x3D; finishedWork.elementType &#x3D;&#x3D;&#x3D; finishedWork.type</span><br><span class="line">              ? current.memoizedProps</span><br><span class="line">              : resolveDefaultProps(finishedWork.type, current.memoizedProps);</span><br><span class="line">          &#x2F;&#x2F; 获取旧的 state</span><br><span class="line">          const prevState &#x3D; current.memoizedState;</span><br><span class="line">          &#x2F;&#x2F; 调用 componentDidUpdate 生命周期函数</span><br><span class="line">          &#x2F;&#x2F; instance.__reactInternalSnapshotBeforeUpdate 快照 getSnapShotBeforeUpdate 方法的返回值</span><br><span class="line">          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 获取任务队列</span><br><span class="line">      const updateQueue &#x3D; finishedWork.updateQueue;</span><br><span class="line">      &#x2F;&#x2F; 如果任务队列存在</span><br><span class="line">      if (updateQueue !&#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 调用 ReactElement 渲染完成之后的回调函数</span><br><span class="line">         * 即 render 方法的第三个参数</span><br><span class="line">         *&#x2F;</span><br><span class="line">        commitUpdateQueue(finishedWork, updateQueue, instance);</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-6-3-commitUpdateQueue"><a href="#5-2-6-3-commitUpdateQueue" class="headerlink" title="5.2.6.3 commitUpdateQueue"></a>5.2.6.3 commitUpdateQueue</h5><p><code>文件位置: packages/react-reconciler/src/ReactUpdateQueue.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 执行渲染完成之后的回调函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function commitUpdateQueue&lt;State&gt;(</span><br><span class="line">  finishedWork: Fiber,</span><br><span class="line">  finishedQueue: UpdateQueue&lt;State&gt;,</span><br><span class="line">  instance: any,</span><br><span class="line">): void &#123;</span><br><span class="line">  &#x2F;&#x2F; effects 为数组, 存储任务对象 (Update 对象)</span><br><span class="line">  &#x2F;&#x2F; 但前提是在调用 render 方法时传递了回调函数, 就是 render 方法的第三个参数</span><br><span class="line">  const effects &#x3D; finishedQueue.effects;</span><br><span class="line">  &#x2F;&#x2F; 重置 finishedQueue.effects 数组</span><br><span class="line">  finishedQueue.effects &#x3D; null;</span><br><span class="line">  &#x2F;&#x2F; 如果传递了 render 方法的第三个参数, effect 数组就不会为 null</span><br><span class="line">  if (effects !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 遍历 effect 数组</span><br><span class="line">    for (let i &#x3D; 0; i &lt; effects.length; i++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取数组中的第 i 个需要执行的 effect</span><br><span class="line">      const effect &#x3D; effects[i];</span><br><span class="line">      &#x2F;&#x2F; 获取 callback 回调函数</span><br><span class="line">      const callback &#x3D; effect.callback;</span><br><span class="line">      &#x2F;&#x2F; 如果回调函数不为 null</span><br><span class="line">      if (callback !&#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 清空 effect 中的 callback</span><br><span class="line">        effect.callback &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 执行回调函数</span><br><span class="line">        callCallback(callback, instance);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-6-4-commitHookEffectListMount"><a href="#5-2-6-4-commitHookEffectListMount" class="headerlink" title="5.2.6.4 commitHookEffectListMount"></a>5.2.6.4 commitHookEffectListMount</h5><p><code>文件位置: packages/react-reconciler/src/ReactFiberCommitWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * useEffect 回调函数调用</span><br><span class="line"> *&#x2F;</span><br><span class="line">function commitHookEffectListMount(tag: number, finishedWork: Fiber) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取任务队列</span><br><span class="line">  const updateQueue: FunctionComponentUpdateQueue | null &#x3D; (finishedWork.updateQueue: any);</span><br><span class="line">  &#x2F;&#x2F; 获取 lastEffect</span><br><span class="line">  let lastEffect &#x3D; updateQueue !&#x3D;&#x3D; null ? updateQueue.lastEffect : null;</span><br><span class="line">  &#x2F;&#x2F; 如果 lastEffect 不为 null</span><br><span class="line">  if (lastEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取要执行的副作用</span><br><span class="line">    const firstEffect &#x3D; lastEffect.next;</span><br><span class="line">    let effect &#x3D; firstEffect;</span><br><span class="line">    &#x2F;&#x2F; 通过遍历的方式调用 useEffect 中的回调函数</span><br><span class="line">    &#x2F;&#x2F; 在组件中定义了调用了几次 useEffect 遍历就会执行几次</span><br><span class="line">    do &#123;</span><br><span class="line">      if ((effect.tag &amp; tag) &#x3D;&#x3D;&#x3D; tag) &#123;</span><br><span class="line">        &#x2F;&#x2F; Mount</span><br><span class="line">        const create &#x3D; effect.create;</span><br><span class="line">        &#x2F;&#x2F; create 就是 useEffect 方法的第一个参数</span><br><span class="line">        &#x2F;&#x2F; 返回值就是清理函数</span><br><span class="line">        effect.destroy &#x3D; create();</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 更新循环条件</span><br><span class="line">      effect &#x3D; effect.next;</span><br><span class="line">    &#125; while (effect !&#x3D;&#x3D; firstEffect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
