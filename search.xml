<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS异步编程</title>
    <url>/2020/08/26/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>javascript最初设计为了实现页面的交互操作，为了避免不同线程同时处理dom导致无法判断以那个结果为准，所以不得不采用单线程模式工作，</p>
<ul>
<li>同步模式与异步模式</li>
<li>事件循环与消息队列</li>
<li>异步编程方式</li>
<li>Promise异步方案、宏任务/微任务</li>
<li>Generator异步方案、Async/Await语法糖</li>
</ul>
<h3 id="同步模式，排队执行"><a href="#同步模式，排队执行" class="headerlink" title="同步模式，排队执行"></a>同步模式，排队执行</h3><p>js通过调用栈执行函数语句，正在执行的操作会入栈，操作完成后出栈<br>耗时操作会阻塞后边函数的执行</p>
<h3 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h3><p>开始执行后，js现成遇到异步操作会将异步操作放入异步调用线程（web APIs），之后立即开始下一个任务。<br>异步调用线程会在异步执行完成后，将回调函数压入消息队列中<br>在js主线程的函数栈操作完毕后，Event Loop 会循环将回调函数取出回调函数交给主线程执行</p>
<img src="/2020/08/26/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/yibu.png" class="">
<p>运行环境提供的API是以同步或者异步模式的方式工作的，比如console.log()会在主线程同步执行，当执行setTimeout时会交给异步线程去处理。</p>
<h3 id="回调函数-异步编程方案的根基"><a href="#回调函数-异步编程方案的根基" class="headerlink" title="回调函数-异步编程方案的根基"></a>回调函数-异步编程方案的根基</h3><p>回调函数<br>事件机制<br>发布订阅</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>三种状态<br>Pending、Fulfilled、Rejected。<br>Promise执行完成后的状态不可被改变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// resolve 和 reject 函数只能执行一个</span></span><br><span class="line">    resolve(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reject(new Error(&#x27;promise rejected&#x27;));</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><p>Promise then方法会返回一个新的Promise对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">123</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise === promise2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>前面then方法回调函数的返回值会作为后面then 方法回调的参数<br>后面的then方法实际上是为上一个then方法返回的promise注册回调</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">123</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// 123</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// undefined  // 上一个函数没有返回一个新的Promise或者数值，所以res是undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;上个then中返回的Promse结果&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// 上个then中返回的Promse结果  // 如果上个then函数返回了新的Promise， 相当于执行返回的Promise的then（）函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>如果promise执行中遇到了抛出异常，就会执行 onRejectd 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;手动抛出异常&#x27;</span>);</span><br><span class="line">    resolve(<span class="number">123</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// undefined  // 上一个函数没有返回一个新的Promise或者数值，所以res是undefined  </span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: 手动抛出异常</span></span><br></pre></td></tr></table></figure>

<p>上面的方式可以写成在最后添加catch方法的方式，在promise中异常会通过他很方法向后传递，因此在最后添加catch（）方法可以捕获整个链式过程中抛出的异常，相当于为整个Promise链条注册的失败回调</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;手动抛出异常&#x27;</span>);</span><br><span class="line">    resolve(<span class="number">123</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// undefined  // 上一个函数没有返回一个新的Promise或者数值，所以res是undefined  </span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 </span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;手动抛出异常&#x27;</span>);</span><br><span class="line">    resolve(<span class="number">123</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// undefined  // 上一个函数没有返回一个新的Promise或者数值，所以res是undefined  </span></span><br><span class="line">&#125;).then(<span class="literal">undefined</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当然也可以在全局为出现异常的Promise 添加异常处理，不过这种方式不推荐，因改为每一个promise添加特定的异常处理<br>浏览器环境</p>
<img src="/2020/08/26/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/2.png" class="">

<p>node环境</p>
<img src="/2020/08/26/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/3.png" class="">

<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>Promise.resolve()        快速地把一个值转化为Promise对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// Promise &#123; true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果接受一个Promise对象，则会返回该Promise对象</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(promise) === promise</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 thenable 接口</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params">onResolve, onReject</span>) </span>&#123;</span><br><span class="line">        onResolve(<span class="string">&#x27;thenable&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise.reject()     返回一个失败地Promise对象</p>
<h4 id="Promise-并行执行"><a href="#Promise-并行执行" class="headerlink" title="Promise 并行执行"></a>Promise 并行执行</h4><ul>
<li>Promise.all()<br>多个Promise 合并为一个Promise，会在下个then方法传递给回调函数 结果数组，需要注意all方法中地任意一个Promise执行了reject（）方法或者抛出异常，会导致触发整个Promise.all返回的Promise对象执行onReject回调</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">1000</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">5000</span>)</span><br><span class="line">            &#125;, <span class="number">5000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 1000, 5000 ]   // 5 s 后</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Promise.race();<br>Promise.race()方法同样会合并多个Promise，与all()不同的是，race方法会等待第一个完成的任务，并向后传递第一个执行完成的任务的结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">1000</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">5000</span>)</span><br><span class="line">    &#125;, <span class="number">5000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1000   // 1 s 后</span></span><br></pre></td></tr></table></figure>

<h4 id="微任务，promise执行顺序"><a href="#微任务，promise执行顺序" class="headerlink" title="微任务，promise执行顺序"></a>微任务，promise执行顺序</h4><p>promise（除此之外还有MutationObserver对象，node中的process.nextTick）的回调会作为微任务执行，微任务会在当前任务执行结束后立即执行，不会在消息队列的队尾排队<br>类似setTimeout 等大部分异步调用都会作为宏任务 执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;code start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Promise&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;code end&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// code start</span></span><br><span class="line"><span class="comment">// code end</span></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure>

<h3 id="Generator异步方案"><a href="#Generator异步方案" class="headerlink" title="Generator异步方案"></a>Generator异步方案</h3><p>生成器函数的调用会返回生成器对象而不是立即执行函数内容，只有调用生成器对象的next()方法函数才会开始执行</p>
]]></content>
      <tags>
        <tag>notes</tag>
        <tag>javascript</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>centos虚拟机安装</title>
    <url>/2021/12/14/centos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="centos-虚拟机安装"><a href="#centos-虚拟机安装" class="headerlink" title="centos 虚拟机安装"></a>centos 虚拟机安装</h2><h3 id="下载镜像并创建虚拟机"><a href="#下载镜像并创建虚拟机" class="headerlink" title="下载镜像并创建虚拟机"></a>下载镜像并创建虚拟机</h3><p>略</p>
<h3 id="centos-安装"><a href="#centos-安装" class="headerlink" title="centos 安装"></a>centos 安装</h3><ol>
<li><p>打开虚拟机，上下选择键选择 install CentOS</p>
</li>
<li><p>安装完成后会提示选择语言，点继续</p>
</li>
<li><p>之后会发现 begin installation 无法点击，此时选择 installation destination</p>
<img src="/2021/12/14/centos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20211214151819195.png" class="">
</li>
<li><p>选择 i will configure partitioning , 点击 done</p>
</li>
<li><p>点击左下角 + 号</p>
<ul>
<li><p>选择 /boot , 分配1024M 空间</p>
</li>
<li><p>选择 swap , 分配4096M 空间</p>
</li>
<li><p>选择 / , 直接点击 add mount point, 自动将剩余的空间分配到根目录</p>
</li>
<li><p>点击 done</p>
<img src="/2021/12/14/centos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20211214152211656.png" class="">
</li>
<li><p>点击 accept changes</p>
</li>
</ul>
</li>
<li><p>点击 begin install</p>
</li>
<li><p>设置 root password， 点击两次done</p>
</li>
<li><p>等待安装结束后，点击 reboot</p>
</li>
</ol>
<h3 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h3><ol>
<li><p>查看VMware 虚拟网络配置</p>
<p>点击虚拟机的编辑 -&gt; 虚拟机网络编辑器 -&gt; 选择 VMnet8 NET 模式<br>查看 子网ip、子网掩码、网关ip</p>
<img src="/2021/12/14/centos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20211214153040179.png" class="">

<p>查看 起止 ip 区间</p>
<img src="/2021/12/14/centos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20211214153632288.png" class="">
</li>
<li><p>修改网络配置<br>cd /etc/sysconfig/network-scripts/目录下</p>
<p>vi ifcfg-ens32  (这个文件每个人可能都不一样，是系统随机命名的，但都是ifcfg-enxxx这种格式)</p>
<p>修改 BOOTPROTO 和 ONBOOT 字段，并追加内容如图</p>
<img src="/2021/12/14/centos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20211214154752201.png" class=""></li>
<li><p>重启网卡服务 service network restart</p>
<img src="/2021/12/14/centos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/20200406221633148.png" class="">
</li>
<li><p>ping baidu.com 检查网络状态</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>centos</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab搭建</title>
    <url>/2021/12/14/gitlab%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="gitlab代码仓库搭建"><a href="#gitlab代码仓库搭建" class="headerlink" title="gitlab代码仓库搭建"></a>gitlab代码仓库搭建</h2><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><ol>
<li><p>安装ssh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y curl policycoreutils-pythonopenssh-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>将SSH服务设置成开机自启动</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable sshd</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>启动SSH服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start sshd</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装开启防火墙,如果已经安装了防火墙并且已经在运行状态跳过此步骤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install firewalld systemd -y</span><br><span class="line"></span><br><span class="line">service firewalld  start</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加http服务到firewalld,pemmanent表示永久生效，若不加–permanent系统下次启动后就会失效。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --add-service&#x3D;http</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>重启防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl reload firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装Postfix以发送通知邮件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install postfix</span><br></pre></td></tr></table></figure>
</li>
<li><p>将postfix服务设置成开机自启动</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable postfix</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>启动postfix</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start postfix</span><br></pre></td></tr></table></figure>

<ol start="10">
<li><p>wget 用于从外网上下载插件  <code>wget -V</code> 查看版本，已安装掠过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install wget</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装vim编辑器, 系统一般会安装，可略过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install vim</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="安装gitlab"><a href="#安装gitlab" class="headerlink" title="安装gitlab"></a>安装gitlab</h3><ol>
<li><p>添加gitlab镜像<br>镜像需要跟自己的centos版本对应</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; centos 7</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gitlab-ce&#x2F;yum&#x2F;el7&#x2F;gitlab-ce-10.0.0-ce.0.el7.x86_64.rpm</span><br><span class="line">&#x2F;&#x2F; centos 8</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gitlab-ce&#x2F;yum&#x2F;el8&#x2F;gitlab-ce-12.10.1-ce.0.el8.x86_64.rpm</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装gitlab</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; centos 7</span><br><span class="line">rpm -i gitlab-ce-10.0.0-ce.0.el7.x86_64.rpm</span><br><span class="line">&#x2F;&#x2F; centos 8</span><br><span class="line">rpm -i gitlab-ce-12.10.1-ce.0.el8.x86_64.rpm</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如提示缺少相应的python依赖，手动安装即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install policycoreutils-python</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改gitlab配置文件指定服务器ip和自定义端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb</span><br></pre></td></tr></table></figure>
<p>修改 GitLab Url 模块下的 external_url</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">external_url &#39;http:&#x2F;&#x2F;ip:prot&#39;</span><br></pre></td></tr></table></figure>
<p>注意 port 端口不能被占用, 如果netstat 未安装 <code>yum -y install net-tools</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat  -anp|grep   端口号</span><br></pre></td></tr></table></figure>
<p>防火墙添加开放端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;端口号&#x2F;tcp --permanent</span><br><span class="line">&#x2F;&#x2F; success</span><br></pre></td></tr></table></figure>
<p>重新载入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br><span class="line">&#x2F;&#x2F;success</span><br></pre></td></tr></table></figure>
<p>查看防火墙端口状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --query-port&#x3D;9999&#x2F;tcp</span><br><span class="line">&#x2F;&#x2F;yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启动gitlab<br>首次等待时间会较长</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>
<p>重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure>




</li>
</ol>
<blockquote>
<p>原文地址 <a href="https://blog.csdn.net/ainixiya/article/details/103782511">https://blog.csdn.net/ainixiya/article/details/103782511</a></p>
</blockquote>
<p>tt<br>t</p>
]]></content>
      <tags>
        <tag>centos</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript面试题</title>
    <url>/2020/08/27/javascript%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><h4 id="按顺序写出控制台打印结果"><a href="#按顺序写出控制台打印结果" class="headerlink" title="按顺序写出控制台打印结果"></a>按顺序写出控制台打印结果</h4><p>（2020 碧桂园）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> User = &#123;</span><br><span class="line">    count:<span class="number">1</span>,</span><br><span class="line">    action:&#123;</span><br><span class="line">        getCount:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getCount = User.action.getCount;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;result 1&quot;</span>,User.action.getCount())</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;result 2&quot;</span>,getCount())</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// result 2, undefined</span></span><br><span class="line"><span class="comment">// result 1, undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><h4 id="基于es6的proxy方法设计一个属性拦截读取操作"><a href="#基于es6的proxy方法设计一个属性拦截读取操作" class="headerlink" title="基于es6的proxy方法设计一个属性拦截读取操作"></a>基于es6的proxy方法设计一个属性拦截读取操作</h4><p>要求实现去访问目标对象example中不存在的属性时，抛出错误：Property “$(property)” does not exist （2018 今日头条）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 案例代码</span></span><br><span class="line"><span class="keyword">const</span> man = &#123;</span><br><span class="line">    name:<span class="string">&#x27;jscoder&#x27;</span>,</span><br><span class="line">    age:<span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//补全代码</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(...)</span><br><span class="line">proxy.name   <span class="comment">// &quot;jscoder&quot;</span></span><br><span class="line">proxy.age     <span class="comment">// 22</span></span><br><span class="line">proxy.location   <span class="comment">// Property &quot;$(property)&quot; does not exist</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 答案</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(man, &#123;</span><br><span class="line">    get(target, property) &#123;</span><br><span class="line">        <span class="keyword">return</span> property <span class="keyword">in</span> target ? target[property] : <span class="built_in">console</span>.error(<span class="string">`Property &quot;<span class="subst">$&#123;property&#125;</span>&quot; does not exist`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2021/12/20/test/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>jenkins安装</title>
    <url>/2021/12/22/jenkins%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h3><p>Jenkins是java语言开发的，因需要jdk环境</p>
<p>搜索<code>jdk</code>安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum search java|grep jdk</span><br></pre></td></tr></table></figure>

<p>下载，默认路径 /usr/lib/jvm/</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install java</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<h3 id="jenkins安装"><a href="#jenkins安装" class="headerlink" title="jenkins安装"></a>jenkins安装</h3><p>按照官网的步骤安装</p>
<p>To use this repository, run the following command:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;jenkins.repo https:&#x2F;&#x2F;pkg.jenkins.io&#x2F;redhat-stable&#x2F;jenkins.repo</span><br><span class="line">sudo rpm --import https:&#x2F;&#x2F;pkg.jenkins.io&#x2F;redhat-stable&#x2F;jenkins.io.key</span><br></pre></td></tr></table></figure>

<p>If you’ve previously imported the key from Jenkins, the rpm –import will fail because you already have a key. Please ignore that and move on.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install epel-release # repository that provides &#39;daemonize&#39;</span><br><span class="line">yum install java-11-openjdk-devel</span><br><span class="line">yum install jenkins</span><br></pre></td></tr></table></figure>

<p>The rpm packages were signed using this key:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pub   rsa4096 2020-03-30 [SC] [expires: 2023-03-30]</span><br><span class="line">      62A9756BFD780C377CF24BA8FCEF32E745F2C3D5</span><br><span class="line">uid                      Jenkins Project</span><br><span class="line">sub   rsa4096 2020-03-30 [E] [expires: 2023-03-30]</span><br></pre></td></tr></table></figure>

<p>按照以上步骤安装时，如果提示无法连接，需要重新制作缓存,<a href="https://blog.csdn.net/Alan_Wdd/article/details/116260084">Jenkins yum [Errno 256] No more mirrors to try 解决方法</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>


<p>配置 jenkins 端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysconfig&#x2F;jenkins</span><br></pre></td></tr></table></figure>

<p>修改端口 ，<br>ps 需要检查端口占用情况 <code>netstat -anp|grep 9999</code><br>防火墙端口状态查看 <code>firewall-cmd --zone=public --query-port=9999/tcp</code><br>防火墙开启端口 <code>firewall-cmd --zone=public --add-port=端口号/tcp --permanent</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JENKINS_PORT&#x3D;&quot;9999&quot;</span><br></pre></td></tr></table></figure>

<p>启动jenkins</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service jenkins start&#x2F;stop&#x2F;restart</span><br></pre></td></tr></table></figure>

<h3 id="访问jenkins"><a href="#访问jenkins" class="headerlink" title="访问jenkins"></a>访问jenkins</h3><p>访问服务器端口<br>会看到需要初始密码，初始密码在 /var/lib/jenkins/secrets/initialAdminPassword</p>
<p>选择 Install suggested plugins 安装默认插件</p>
<p>等待安装完成后，创建管理员账户</p>
<p>ok!</p>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p><a href="https://www.cnblogs.com/niuben/p/12938501.html">nodejs安装</a></p>
<p>参照node 方式安装yarn 并设置全局依赖和缓存目录，并设置yarn 的软连接</p>
<p>全局安装hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn global add hexo-cli</span><br></pre></td></tr></table></figure>

<p>进入到全局yarn 地址 ，设置hexo 软链</p>
]]></content>
  </entry>
  <entry>
    <title>ES6</title>
    <url>/2020/08/26/ES6/</url>
    <content><![CDATA[<h2 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h2><h3 id="let块级作用域"><a href="#let块级作用域" class="headerlink" title="let块级作用域"></a>let块级作用域</h3><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>只读的let，不可以修改内存地址</p>
<h3 id="let-var-const-三者的区别"><a href="#let-var-const-三者的区别" class="headerlink" title="let,var,const 三者的区别"></a>let,var,const 三者的区别</h3><p>var声明的变量不存在块级作用域，并且存在变量提升，在变量声明之前使用可以取到一个undefined的值。<br>在最外层作用域生命的var变量会挂载到全局对象上<br>let和const声明的变量存在块级作用域，不会挂在到全局对象上。在声明之前使用会报错。let变量值可以随意赋值，const的值不允许改变，因此const在定义时必须初始化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;vara&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;window.a: &#x27;</span>, <span class="built_in">window</span>.a); <span class="comment">// vara</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&#x27;letb&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;window.b: &#x27;</span>, <span class="built_in">window</span>.b); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    c = <span class="string">&#x27;bar_c&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="string">&#x27;bar_d&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        e = <span class="string">&#x27;foo_e&#x27;</span>;</span><br><span class="line">        <span class="keyword">var</span> f = <span class="string">&#x27;foo_f&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    foo();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;e: &#x27;</span>, e); <span class="comment">// foo_e</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;window.e: &#x27;</span>, <span class="built_in">window</span>.e) <span class="comment">// foo_e</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;f: &#x27;</span>, f); <span class="comment">// test.html:24 Uncaught ReferenceError: f is not defined</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;window.c: &#x27;</span>, <span class="built_in">window</span>.c); <span class="comment">// bar_c</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;c: &#x27;</span>, c); <span class="comment">// bar_C</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;window.d: &#x27;</span>, <span class="built_in">window</span>.d); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// console.log(&#x27;d: &#x27;, d); // Uncaught ReferenceError: d is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;e: &#x27;</span>, e); <span class="comment">// foo_e</span></span><br></pre></td></tr></table></figure>

<h3 id="数组的解构"><a href="#数组的解构" class="headerlink" title="数组的解构"></a>数组的解构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> [a, b, c] = arr;</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, ...b] = arr;</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构时附默认值</span></span><br><span class="line"><span class="keyword">const</span> [a, b, c, d = <span class="number">4</span>] = arr;</span><br><span class="line"><span class="comment">// d = 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="string">&#x27;2020/12/20&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> [, month] = path.split(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="comment">// month = 12</span></span><br></pre></td></tr></table></figure>

<h3 id="对象的解构"><a href="#对象的解构" class="headerlink" title="对象的解构"></a>对象的解构</h3><p>类似数组解构，除此之外，可以在解构时重命名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;along&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">name</span>: newName&#125; = obj;</span><br><span class="line"><span class="comment">// newName = along</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构同时赋默认值</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">age</span>: newAge = <span class="number">24</span>&#125;;</span><br><span class="line"><span class="comment">// newAge = 24;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化代码</span></span><br><span class="line"><span class="keyword">const</span> &#123;log&#125; = <span class="built_in">console</span>;</span><br></pre></td></tr></table></figure>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">    可以支持换行</span></span><br><span class="line"><span class="string">    可以支持插值，使用表达式</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;name&#125;</span></span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;<span class="number">1</span>+<span class="number">1</span>&#125;</span></span></span><br><span class="line"><span class="string">`</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符标签函数</span></span><br><span class="line"><span class="comment">// 该用法会返回字符串数组和所有的插入值</span></span><br><span class="line"><span class="built_in">console</span>.log<span class="string">`hello <span class="subst">$&#123;<span class="string">&#x27;along&#x27;</span>&#125;</span> age <span class="subst">$&#123;<span class="number">23</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// [&#x27;hello &#x27;, &#x27; age &#x27;], &#x27;along&#x27;, 23</span></span><br><span class="line">alert<span class="string">``</span>hello $&#123;<span class="string">&#x27;along&#x27;</span>&#125; age $&#123;<span class="number">23</span>&#125;<span class="string">`</span></span><br><span class="line"><span class="string">// [&#x27;hello &#x27;, &#x27; age &#x27;] </span></span><br></pre></td></tr></table></figure>

<h3 id="字符串拓展方法"><a href="#字符串拓展方法" class="headerlink" title="字符串拓展方法"></a>字符串拓展方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello along&#x27;</span></span><br><span class="line">includes(<span class="string">&#x27;alo&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">stratsWith(<span class="string">&#x27;he&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">endsWith(<span class="string">&#x27;along&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">a = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a + <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add1() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="展开数组-Spread"><a href="#展开数组-Spread" class="headerlink" title="展开数组 Spread"></a>展开数组 Spread</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// console.log.apply(console, arr)</span></span><br><span class="line"><span class="built_in">console</span>.log(...arr);</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简化代码</span></span><br><span class="line"><span class="keyword">const</span> add1 = <span class="function"><span class="params">num</span> =&gt;</span> num + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this指向</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;along&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> people = &#123;</span><br><span class="line">    name: <span class="string">&#x27;peoplename&#x27;</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    fn2: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">people.fn(); <span class="comment">// peoplename</span></span><br><span class="line">people.fn2(); <span class="comment">// &quot;&quot;  fn2 中的 this 指向 window 而不是 全局作用域的name</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，箭头含数arguments 指向的对象并不是当前函数所属的argments，而是上级函数的arguments</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(<span class="number">1</span>,<span class="number">2</span>)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Arguments] &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2 &#125;</span></span><br><span class="line"><span class="comment">// [Arguments] &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="对象字面量-增强"><a href="#对象字面量-增强" class="headerlink" title="对象字面量 增强"></a>对象字面量 增强</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象属性值简略写法</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;along&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name,</span><br><span class="line">    <span class="comment">// 函数的简写，注意这种方式同 </span></span><br><span class="line">    <span class="comment">// fn: function() &#123;console.log(this.name)&#125;</span></span><br><span class="line">    <span class="comment">// 其中的this取决于它的调用者</span></span><br><span class="line">    fn() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 计算属性名</span></span><br><span class="line">    [<span class="number">1</span>+<span class="number">2</span>]: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象扩展方法"><a href="#对象扩展方法" class="headerlink" title="对象扩展方法"></a>对象扩展方法</h3><h4 id="object-assign"><a href="#object-assign" class="headerlink" title="object.assign"></a>object.assign</h4><p>object.assign 将源对象中的属性复制到目标对象中  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123;</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;<span class="attr">b</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">const</span> res = <span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">res === target <span class="comment">// true  </span></span><br></pre></td></tr></table></figure>
<p>将对象传给函数进行属性操作时，为了避免对原对象修改，在函数内部复制新的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;along&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">tar</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 参数是对象时tar是一个引用地址，指向参数的对象地址</span></span><br><span class="line">    <span class="comment">// 直接操作tar会改变参数的属性</span></span><br><span class="line">    <span class="comment">// tar.name = &#x27;new along&#x27;;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> newobj = <span class="built_in">Object</span>.assign(&#123;&#125;, tar);</span><br><span class="line">    newobj.name = <span class="string">&#x27;new along&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(newobj);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(obj); <span class="comment">// &#123;name: &#x27;new along&#x27;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: &#x27;along&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以通过Object.assign()为对象参数设置默认值、</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> defaultparams = &#123;</span><br><span class="line">        page: <span class="number">1</span>,</span><br><span class="line">        pagesize: <span class="number">10</span>,</span><br><span class="line">        method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> params = <span class="built_in">Object</span>.assign(&#123;&#125;, option, defaultparams);</span><br><span class="line">    <span class="built_in">console</span>.log(params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> option = &#123;</span><br><span class="line">    method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    url: <span class="string">&#x27;localhost:8080&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(option)</span><br></pre></td></tr></table></figure>

<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>判断两个值是否相等 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>); <span class="comment">// false   </span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">    get(target, property) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(target, property);</span><br><span class="line">        <span class="keyword">return</span> property <span class="keyword">in</span> target ? target[property] : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, property, value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (property === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`age must be a number but <span class="subst">$&#123;value&#125;</span> [<span class="subst">$&#123;<span class="keyword">typeof</span> value&#125;</span>]`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        target[property] = value;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(personProxy.name);</span><br><span class="line"><span class="comment">// &#123; name: &#x27;along&#x27;, age: 20 &#125; name</span></span><br><span class="line"><span class="comment">// along</span></span><br><span class="line"><span class="built_in">console</span>.log(personProxy.bb);</span><br><span class="line"><span class="comment">// &#123; name: &#x27;along&#x27;, age: 20 &#125; bb</span></span><br><span class="line"><span class="comment">// -</span></span><br><span class="line">personProxy.age = <span class="string">&#x27;20&#x27;</span></span><br><span class="line"><span class="comment">// throw new TypeError(`age must be a number but $&#123;value&#125; [$&#123;typeof value&#125;]`);</span></span><br><span class="line"><span class="comment">// ^</span></span><br><span class="line"><span class="comment">// TypeError: age must be a number but 20 [string]</span></span><br></pre></td></tr></table></figure>

<p>vue 3.0 开始使用proxy 实现内部数据的相应</p>
<h4 id="Proxy-与-Object-defineProperty-比较"><a href="#Proxy-与-Object-defineProperty-比较" class="headerlink" title="Proxy 与 Object.defineProperty 比较"></a>Proxy 与 Object.defineProperty 比较</h4><p>defineProperty  只能监视对象的读取和写入 Proxy 可以监视一些 defineProperty  监视不到的行为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">     deleteProperty(target, property) &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&#x27;delete&#x27;</span>, property);</span><br><span class="line">         <span class="keyword">delete</span> target[property];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> personProxy.name;</span><br><span class="line"><span class="built_in">console</span>.log(personProxy);</span><br><span class="line"><span class="comment">// delete name</span></span><br><span class="line"><span class="comment">// &#123; age: 20 &#125;</span></span><br></pre></td></tr></table></figure>

<p>除了删除操作之外，可操作的行为见下表</p>
<img src="/2020/08/26/ES6/clipboard.png" class="">

<h4 id="借助Proxy监视数组操作"><a href="#借助Proxy监视数组操作" class="headerlink" title="借助Proxy监视数组操作"></a>借助Proxy监视数组操作</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> listProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(list, &#123;</span><br><span class="line">    set(target, property, value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(target, property, value); </span><br><span class="line">        target[property] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 需要返回true表示操作成功</span></span><br><span class="line">    &#125;,</span><br><span class="line">    deleteProperty(target, property) &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&#x27;delete&#x27;</span>, property);</span><br><span class="line">         <span class="keyword">delete</span> target[property];</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 需要返回true表示操作成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">listProxy.push(<span class="number">1</span>); <span class="comment">// push 操作会至少触发两次set</span></span><br><span class="line"><span class="comment">// [] 0 1</span></span><br><span class="line"><span class="comment">// [ 1 ] length 1</span></span><br><span class="line">listProxy.push(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// [ 1 ] 1 2</span></span><br><span class="line"><span class="comment">// [ 1, 2 ] length 2</span></span><br><span class="line">listProxy.push(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// [ 1, 2 ] 2 3</span></span><br><span class="line"><span class="comment">// [ 1, 2, 3 ] length 3</span></span><br><span class="line">listProxy.push(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// [ 1, 2, 3 ] 3 4</span></span><br><span class="line"><span class="comment">// [ 1, 2, 3, 4 ] length 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里执行到shift时，会首先出发三次set，讲数组最后的三个元素前移，</span></span><br><span class="line"><span class="comment">// 然后触发删除操作</span></span><br><span class="line"><span class="comment">// 最后再次触发 set 的操作修改length</span></span><br><span class="line">listProxy.shift(); </span><br><span class="line"><span class="comment">// [ 1, 2, 3, 4 ] 0 2</span></span><br><span class="line"><span class="comment">// [ 2, 2, 3, 4 ] 1 3</span></span><br><span class="line"><span class="comment">// [ 2, 3, 3, 4 ] 2 4</span></span><br><span class="line"><span class="comment">// delete 3</span></span><br><span class="line"><span class="comment">// [ 2, 3, 4, &lt;1 empty item&gt; ] length 3</span></span><br></pre></td></tr></table></figure>
<h4 id="Proxy-以非侵入的方式监管对象读写"><a href="#Proxy-以非侵入的方式监管对象读写" class="headerlink" title="Proxy 以非侵入的方式监管对象读写"></a>Proxy 以非侵入的方式监管对象读写</h4><p>defineProperty 需要通过监听特定的属性，如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;along&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> person._name;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;name 被修改&#x27;</span>);</span><br><span class="line">        person._name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line">person.name = <span class="string">&#x27;along&#x27;</span>;</span><br><span class="line"><span class="comment">// name 被修改</span></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br><span class="line"><span class="comment">// &#123; name: [Getter/Setter], _name: &#x27;along&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name)</span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="comment">// along</span></span><br></pre></td></tr></table></figure>

<p>从以上代码可以看出，defineProperty方式会修改被监控的对象本身，读取写入操作需要借助辅助内存空间来保存真实值</p>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>静态类，不能用new操作符<br>Reflect 内部封装了一系列对对象的底层操作<br>Reflect 成员方法就是Proxy处理对象的默认实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">    <span class="comment">// 在不设置 get 方法时，相当于返回 Reflect.get(target, property);</span></span><br><span class="line">    get (target, property) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(personProxy.name)</span><br></pre></td></tr></table></figure>

<h4 id="统一操作对象的API"><a href="#统一操作对象的API" class="headerlink" title="统一操作对象的API"></a>统一操作对象的API</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">    age: <span class="number">24</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="built_in">Reflect</span>.has(person, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// true  相当于  &#x27;name&#x27; in person</span></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(person, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// 相当于 delete person[&#x27;name&#x27;] | delete person.name</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(person);</span><br><span class="line"><span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;]  相当于  person.keys();</span></span><br></pre></td></tr></table></figure>

<h3 id="class-类"><a href="#class-类" class="headerlink" title="class 类"></a>class 类</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    say () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> say`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;along&#x27;</span>);</span><br><span class="line">person.say();</span><br><span class="line"><span class="comment">// along say</span></span><br></pre></td></tr></table></figure>

<h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><ul>
<li>实例方法（通过实例调用）实例方法中的this指向实例</li>
<li>静态方法（通过类本身调用）静态方法中的this指向类本身</li>
</ul>
<h4 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    say () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> say`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> create (name) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = Person.create(<span class="string">&#x27;along&#x27;</span>);</span><br><span class="line"><span class="comment">// [Function: Person]</span></span><br><span class="line">person.say();</span><br><span class="line"><span class="comment">// Person &#123; name: &#x27;along&#x27; &#125;</span></span><br><span class="line"><span class="comment">// along say</span></span><br></pre></td></tr></table></figure>

<h3 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承 extends"></a>继承 extends</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    say () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> say`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> create (name) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">        <span class="comment">// return new this(name); 可以使用new this , </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, schoolname)&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.schoolname = schoolname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    welcome() &#123;</span><br><span class="line">        <span class="built_in">super</span>.say();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`from <span class="subst">$&#123;<span class="built_in">this</span>.schoolname&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> along = <span class="keyword">new</span> Student(<span class="string">&#x27;along&#x27;</span>, <span class="string">&#x27;黑科技&#x27;</span>);</span><br><span class="line">along.welcome()</span><br><span class="line"><span class="comment">// Student &#123; name: &#x27;along&#x27;, schoolname: &#x27;黑科技&#x27; &#125;</span></span><br><span class="line"><span class="comment">// along say</span></span><br><span class="line"><span class="comment">// from 黑科技</span></span><br><span class="line"><span class="built_in">console</span>.log(Student.create(<span class="string">&#x27;along&#x27;</span>));</span><br><span class="line"><span class="comment">// [Function: Student]                  Student继承的Person的静态方法，this指向Student类</span></span><br><span class="line"><span class="comment">// Person &#123; name: &#x27;along&#x27; &#125;            </span></span><br></pre></td></tr></table></figure>

<h3 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h3><p>不重复元素的集合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"><span class="comment">// Set &#123; 1, 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 不能用 for in, 不能用下标取值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者 forEach</span></span><br><span class="line">s.forEach(<span class="function"><span class="params">l</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(l);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Set 长度</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;size&#x27;</span>, s.size);</span><br><span class="line"><span class="comment">// size 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否存在某个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(s.has(<span class="number">100</span>));</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除某个元素，删除成功返回true，失败即本来不存在返回false</span></span><br><span class="line"><span class="built_in">console</span>.log(s.delete(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">s.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)); <span class="comment">// [...new Set(arr)]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<h3 id="Map-数据结构，映射两个任意类型数据之间的关系"><a href="#Map-数据结构，映射两个任意类型数据之间的关系" class="headerlink" title="Map 数据结构，映射两个任意类型数据之间的关系"></a>Map 数据结构，映射两个任意类型数据之间的关系</h3><p>可以使用任何数据作为键，普通对象只能用字符串作为键</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> along = &#123;<span class="attr">name</span>: <span class="string">&#x27;along&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(along, <span class="number">25</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map)</span><br><span class="line"><span class="comment">// Map &#123; &#123; name: &#x27;along&#x27; &#125; =&gt; 25 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(along))</span><br><span class="line"><span class="comment">// 25</span></span><br><span class="line">map.has(along); <span class="comment">// 查看是否存在键  返回true</span></span><br><span class="line">map.delete(along); <span class="comment">// 返回删除结果</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">map.clear() <span class="comment">// 清空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 forEach 获取 for of </span></span><br><span class="line">map.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, key)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Symbol-第七个数据类型，-esmascript-2017-第八个数据类型BigInt"><a href="#Symbol-第七个数据类型，-esmascript-2017-第八个数据类型BigInt" class="headerlink" title="Symbol  第七个数据类型，(esmascript 2017 第八个数据类型BigInt)"></a>Symbol  第七个数据类型，(esmascript 2017 第八个数据类型BigInt)</h3><p>可以避免属性名冲突，为对象定义独一无二的属性名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>() === <span class="built_in">Symbol</span>() <span class="comment">// false </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">// symbol</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;[<span class="built_in">Symbol</span>()]: <span class="number">123</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123; [Symbol()]: 123 &#125;</span></span><br></pre></td></tr></table></figure>

<p>用于模拟对象私有成员,在对象内部由于缓存了Symbol的索引，可以对Symbol属性进行操作，在对象外部由于拿不到Symbol的索引所以无法对属性访问</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    [name]: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">    say() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>[name]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>全局使用相同的Symbol时,可以通过Symbol.for() 传入字符串，Symbol内部维护了字符串和Symbol的对应关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// 相当于  const s1 = Symbol(); // const s2 = s1;</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> strtrue = <span class="built_in">Symbol</span>(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> booltrue = <span class="built_in">Symbol</span>(<span class="literal">true</span>);</span><br><span class="line">strtrue === booltrue <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>

<p>Symbol内置常量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toStringTag]: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.toString())</span><br><span class="line"><span class="comment">// [object along]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取Symbol属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Symbol 属性通过    for in ，Object.keys(), JSON.stringify(), 都会被忽略</span></span><br><span class="line"><span class="comment">// 可以通过  getOwnPropertySymbols 获取Symbol的keys</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&#x27;name&#x27;</span>)]: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj));</span><br><span class="line"><span class="comment">// [ Symbol(name) ]</span></span><br></pre></td></tr></table></figure>

<h3 id="for-of-循环，"><a href="#for-of-循环，" class="headerlink" title="for of 循环，"></a>for of 循环，</h3><p>可以作为遍历所有数据结构的统一方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">    <span class="keyword">if</span> (item === <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for of 循环可以通过 break 跳出循环  ， forEach  map 等方式无法跳出循环， 需要跳出循环需要通过arr.some，arr.every方法</span></span><br></pre></td></tr></table></figure>

<p>Map对象通过for of 遍历返回数组，第一个值是键，第二个值是值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(&#123;<span class="attr">name</span>: <span class="string">&#x27;along&#x27;</span>&#125;, <span class="number">25</span>);</span><br><span class="line">map.set(<span class="string">&#x27;school&#x27;</span>, <span class="string">&#x27;黑科&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; name: &#x27;along&#x27; &#125; 25</span></span><br><span class="line"><span class="comment">// school 黑科</span></span><br></pre></td></tr></table></figure>

<p>通过for of 遍历对象， 会发现报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">    age: <span class="number">24</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: person is not iterable</span></span><br></pre></td></tr></table></figure>


<p>通过浏览器控制台打印数组、Set、 Map 等对象会发现，他们的原型上都存在 [Symbol(Symbol.iterator)]属性</p>
<img src="/2020/08/26/ES6/iterator.png" class="">

<p>通过调用iterator查看结果，这里以数组为例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> iterator = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>][<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实现可迭代接口 iterable</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> iterable = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// iterator</span></span><br><span class="line">        next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// iterationResult</span></span><br><span class="line">            <span class="keyword">const</span> iterationResult = &#123;</span><br><span class="line">                value: keys[index],</span><br><span class="line">                done: index &gt;= keys.length,</span><br><span class="line">            &#125;</span><br><span class="line">            index ++;</span><br><span class="line">            <span class="keyword">return</span> iterationResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    <span class="comment">// 实现iterable 接口</span></span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: iterable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代器模式-让用户通过特定的接口访问容器的数据，不需要了解容器内部的数据结构。"><a href="#迭代器模式-让用户通过特定的接口访问容器的数据，不需要了解容器内部的数据结构。" class="headerlink" title="迭代器模式 让用户通过特定的接口访问容器的数据，不需要了解容器内部的数据结构。"></a>迭代器模式 让用户通过特定的接口访问容器的数据，不需要了解容器内部的数据结构。</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">const</span> todos = &#123;</span><br><span class="line">    life: [<span class="string">&#x27;工作&#x27;</span>, <span class="string">&#x27;坐公交&#x27;</span>],</span><br><span class="line">    learn: [<span class="string">&#x27;ES6&#x27;</span>, <span class="string">&#x27;typescript&#x27;</span>],</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> keys = [].concat(<span class="built_in">this</span>.life, <span class="built_in">this</span>.learn);</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> iterationResult = &#123;</span><br><span class="line">                    value: keys[index],</span><br><span class="line">                    done: index &gt;= keys.length,</span><br><span class="line">                &#125;</span><br><span class="line">                index ++;</span><br><span class="line">                <span class="keyword">return</span> iterationResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> todos) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 Generator"></a>生成器 Generator</h3><p>解决异步函数嵌套问题，从而提供更好的异步编程解决方案</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;along&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gen = fn();</span><br><span class="line"><span class="built_in">console</span>.log(gen);</span><br><span class="line"><span class="comment">// Object [Generator] &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next())</span><br><span class="line"><span class="comment">// along</span></span><br><span class="line"><span class="comment">// &#123; value: 100, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>生成器函数可以自动返回一个生成器对象，生成器函数内部的逻辑会惰性执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;22&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gen = fn();</span><br><span class="line"><span class="built_in">console</span>.log(gen.next())</span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// &#123; value: 100, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next())</span><br><span class="line"><span class="comment">// 22</span></span><br><span class="line"><span class="comment">// &#123; value: 200, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next())</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="生成器应用"><a href="#生成器应用" class="headerlink" title="生成器应用"></a>生成器应用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发号器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> id ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gen = fn();</span><br><span class="line"><span class="built_in">console</span>.log(gen.next())</span><br><span class="line"><span class="built_in">console</span>.log(gen.next())</span><br><span class="line"><span class="built_in">console</span>.log(gen.next())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用生成器简化迭代器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">const</span> todos = &#123;</span><br><span class="line">    life: [<span class="string">&#x27;工作&#x27;</span>, <span class="string">&#x27;坐公交&#x27;</span>],</span><br><span class="line">    learn: [<span class="string">&#x27;ES6&#x27;</span>, <span class="string">&#x27;typescript&#x27;</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [Symbol.iterator]: function () &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     const keys = [].concat(this.life, this.learn);</span></span><br><span class="line">    <span class="comment">//     let index = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return &#123;</span></span><br><span class="line">    <span class="comment">//         next: function () &#123;</span></span><br><span class="line">    <span class="comment">//             const iterationResult = &#123;</span></span><br><span class="line">    <span class="comment">//                 value: keys[index],</span></span><br><span class="line">    <span class="comment">//                 done: index &gt;= keys.length,</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             index ++;</span></span><br><span class="line">    <span class="comment">//             return iterationResult;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> keys = [].concat(<span class="built_in">this</span>.life, <span class="built_in">this</span>.learn);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> keys) &#123;</span><br><span class="line">            <span class="keyword">yield</span> item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> todos) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h2><h3 id="数组方法includs"><a href="#数组方法includs" class="headerlink" title="数组方法includs"></a>数组方法includs</h3><p>在ES2016之前需要通过indexOf 返回的下表来判断，但是这种方式也存在一些问题，比如不能查找数组中的NaN</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="number">1</span>, <span class="literal">NaN</span>, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line">arr.indexOf(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line">arr.indexOf(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line">arr.indexOf(<span class="literal">NaN</span>);</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">arr.includes(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">arr.includes(<span class="literal">NaN</span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 1024</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 1024</span></span><br></pre></td></tr></table></figure>

<h2 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h2><p>Object.values 返回对象的值数组<br>Object.entries 返回对象键值对数组<br>Object.getOwnPropertyDescriptors 获取属性描述符，可以通过拷贝属性描述符拷贝getter、setter<br>padEnd 、 padStart  使用指定字符串填充字符串使其达到目标长度<br>参数列表尾逗号， 便于代码修改时参数扩充<br>Async/Await  Promise语法糖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;along&#x27;</span>,</span><br><span class="line">    age: <span class="string">&#x27;24&#x27;</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>()]: <span class="number">123</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.values(person);</span><br><span class="line"><span class="comment">// [ &#x27;along&#x27;, &#x27;24&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.entries(person)</span><br><span class="line"><span class="comment">// [ [ &#x27;name&#x27;, &#x27;along&#x27; ], [ &#x27;age&#x27;, &#x27;24&#x27; ] ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.entries([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// [ [ &#x27;0&#x27;, 1 ], [ &#x27;1&#x27;, 2 ], [ &#x27;2&#x27;, 3 ] ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> description = <span class="built_in">Object</span>.getOwnPropertyDescriptors(person);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   name: &#123;</span></span><br><span class="line"><span class="comment">//     value: &#x27;along&#x27;,</span></span><br><span class="line"><span class="comment">//     writable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     configurable: true</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   age: &#123; value: &#x27;24&#x27;, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   [Symbol()]: &#123; value: 123, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(person)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key.padEnd(<span class="number">16</span>, <span class="string">&#x27;-&#x27;</span>)&#125;</span>|<span class="subst">$&#123;value.padStart(<span class="number">10</span>, <span class="string">&#x27;-&#x27;</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name------------|-----along</span></span><br><span class="line"><span class="comment">// age-------------|--------24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数列表尾逗号</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    name,</span></span></span><br><span class="line"><span class="function"><span class="params">    age,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>notes</tag>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
</search>
